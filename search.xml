<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(Life) Advice From The Creator of C++</title>
    <url>/2023/08/31/Life-Advice-From-The-Creator-of-Cpp/</url>
    <content><![CDATA[<h3 id="C-之父-Bjarne-Stroustrup-分享人生建议"><a href="#C-之父-Bjarne-Stroustrup-分享人生建议" class="headerlink" title="C++ 之父 Bjarne Stroustrup 分享人生建议"></a>C++ 之父 Bjarne Stroustrup 分享人生建议</h3><p>72岁的Bjarne Stroustrup发明了c++(于1985年首次发布)。38年后，他接受了Honeypot.io公司的一次简短<a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">采访</a>。提供了自己的人生建议:<br>不要过度专业化。不要太确定你知道未来的情况。要灵活变通,记住职业和工作是长期的事情。太多年轻人认为他们可以优化某些东西,然后发现自己在某些可能不是正确的东西上花费了两三年的时间进行专业化。在这个过程中,他们会感到烧毁,因为他们没有花足够的时间建立友谊和生活中的其他事情。<br>我遇到很多“初级极客”——我不知道该怎么称呼他们——他们认为计算机编程、AI、图形之类的专业知识才是唯一重要的东西。其实不是这样的……如果他们什么也不做,只是编写最好的代码,他们认为可以改变世界。但你必须能够倾听。你必须能够与潜在的用户沟通,并从他们那里学习。你也必须能够向他们传达自己的想法。<br>所以你不能只写代码。你必须做一些关于文化和表达想法的事情。我的意思是,我从来不后悔学习历史和数学所花的时间。数学增强你的思维,历史让你对自己的局限性和世界上正在发生的事情有所了解。所以不要太自信。花时间过平衡的生活。<br>要做好抓住机会的准备。我的意思是,广泛的教育,广泛的技能组合——通过教育建立起来的——意味着当机会出现时你可以抓住它。有时候你可以认识到它。我们有很多机会。但我们中很多人要么无法抓住,要么没有注意到。我相对广泛的教育经历——我学过标准的计算机科学,编译器,多种语言……我当时大概知道二十几种。我还学过机器架构,操作系统。这套技能组合发挥了作用。</p>
<h3 id="Life-Advice-From-The-Creator-of-C"><a href="#Life-Advice-From-The-Creator-of-C" class="headerlink" title="(Life) Advice From The Creator of C++"></a>(Life) Advice From The Creator of C++</h3><p>72-year-old Bjarne Stroustrup invented C++ (first released in 1985). 38 years later, he gave a <a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">short interview</a> for Honeypot.io (which calls itself “Europe’s largest tech-focused job platform”) offering his own advice for life:</p>
<p>Don’t overspecialize. Don’t be too sure that you know the future. Be flexible, and remember that careers and jobs are a long-term thing. Too many young people think they can optimize something, and then they find they’ve spent a couple of years or more specializing in something that may not have been the right thing. And in the process they burn out, because they haven’t spent enough time building up friendships and having a life outside computing.</p>
<p>I meet a lot of sort of — I don’t know what you call them, “junior geeks”? — that just think that the only thing that matters is the speciality of computing — programming or AI or graphics or something like that. And — well, it isn’t… And if they do nothing else, well — if you don’t communicate your ideas, you can just as well do Sudoku… You have to communicate. And a lot of sort of caricature nerds forget that. They think that if they can just write the best code, they’ll change the world. But you have to be able to listen. You have to be able to communicate with your would-be users and learn from them. And you have to be able to communicate your ideas to them.</p>
<p>So you can’t just do code. You have to do something about culture and how to express ideas. I mean, I never regretted the time I spent on history and on math. Math sharpens your mind, history gives you some idea of your limitations and what’s going on in the world. And so don’t be too sure. Take time to have a balanced life.</p>
<p>And be ready for the opportunity. I mean, a broad-based education, a broad-based skill set — which is what you build up when you educate, you’re basically building a portfolio of skills — means that you can take advantage of an opportunity when it comes along. You can recognize it sometimes. We have lots of opportunities. But a lot of them, we either can’t take advantage of, or we don’t notice. It was my fairly broad education — I’ve done standard computer science, I’ve done compilers, I’ve done multiple languages… I think I knew two dozen at the time. And I have done machine architecture, I’ve done operating systems. And that skill set turned out to be useful.</p>
<p>At the beginning of the video, Stroustrup jokes that it’s hard to give advice — and that it’s at least as difficult as it is to take advice.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一键部署 Ollama在本地启动并运行大语言模型</title>
    <url>/2023/11/02/Ollama-%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;ollama/ollama:latest&#x27; locally</span><br><span class="line">latest: Pulling from ollama/ollama</span><br><span class="line">aece8493d397: Pull complete</span><br><span class="line">4eca1ad9be6c: Pull complete</span><br><span class="line">fcd9fc6db2c0: Pull complete</span><br><span class="line">Digest: sha256:871505ffb1050381f75875a645e7b24c37e1436fc51b915fd91a8ed202583e3b</span><br><span class="line">Status: Downloaded newer image for ollama/ollama:latest</span><br><span class="line">e8291c35ef1f8414f9b8ab008bc3c3523cb7881ad96ccf60745fffb5916e2d9e</span><br><span class="line">&gt; docker exec -it ollama ollama run llama2</span><br><span class="line">pulling manifest</span><br><span class="line">pulling 22f7f8ef5f4c... 100% |█████████████████████████████████| (3.8/3.8 GB, 29 MB/s)</span><br><span class="line">pulling 8c17c2ebb0ea... 100% |███████████████████████████████████| (7.0/7.0 kB, 3.2 kB/s)</span><br><span class="line">pulling 7c23fb36d801... 100% |███████████████████████████████████| (4.8/4.8 kB, 2.0 kB/s)</span><br><span class="line">pulling 2e0493f67d0c... 100% |████████████████████████████████████████| (59/59 B, 27 B/s)</span><br><span class="line">pulling 2759286baa87... 100% |██████████████████████████████████████| (105/105 B, 45 B/s)</span><br><span class="line">pulling 5407e3188df9... 100% |█████████████████████████████████████| (529/529 B, 163 B/s)</span><br><span class="line">verifying sha256 digest</span><br><span class="line">writing manifest</span><br><span class="line">removing any unused layers</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<blockquote>
<p>what’s your name?</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>你叫什么？</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>请帮我写一段自我介绍，我是一个python     后端程序员</p>
</blockquote>
<p>Sure, here’s a simple self-introduction for a Python developer:</p>
<p>“Hi there! My name is [Your Name], and I’m a Python developer with [Number of Years] years of experience. I specialize in developing web applications, data analysis, and machine learning models using Python. I’m passionate about solving complex problems and creating innovative solutions using my technical skills. In my free time, I enjoy learning new technologies and sharing knowledge with the developer community. Let’s connect and work together on exciting projects!”</p>
<blockquote>
<p> &#x2F;?</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;set         Set session variables<br>  &#x2F;show        Show model information<br>  &#x2F;bye         Exit<br>  &#x2F;?, &#x2F;help    Help for a command</p>
<p>Use <code>&quot;&quot;&quot;</code> to begin a multi-line message.</p>
<blockquote>
<p>&#x2F;show</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;show license      Show model license<br>  &#x2F;show modelfile    Show Modelfile for this model<br>  &#x2F;show parameters   Show parameters for this model<br>  &#x2F;show system       Show system prompt<br>  &#x2F;show template     Show prompt template</p>
<blockquote>
<p> 我现在是在命令 行进行输入，怎么才能 输入多行呢？</p>
</blockquote>
<p>Great, you want to input multiple lines of text! In the command line, you can input multiple lines by pressing the <code>Enter</code> key after each line. For example:</p>
<ol>
<li><code>My name is John.</code></li>
<li><code>I&#39;m a Python developer with 5 years of experience.</code></li>
<li><code>I specialize in developing web applications and data analysis using Python.</code></li>
<li><code>In my free time, I enjoy learning new technologies and sharing knowledge with the developer community.</code></li>
</ol>
<p>After each line, press the <code>Enter</code> key to move on to the next line. When you’re finished, you can press <code>Ctrl+D</code> to exit the command prompt.</p>
<blockquote>
<p>可以帮我写一个python的冒泡排序吗？&#96;</p>
</blockquote>
<p>Of course! Here is an example of a simple bubble sort algorithm written in Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>This algorithm takes an array as input and sorts it using the bubble sort algorithm. It works by repeatedly iterating over the array, comparing adjacent elements, and swapping them if they are in the wrong order. The <code>range()</code> function is used to generate the loop indices for the iteration.</p>
<p>Here’s an example of how you could use this function:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(arr))</span><br></pre></td></tr></table></figure>
<p>This would output the sorted array <code>[1, 2, 3, 4, 5, 7]</code>.</p>
<p>Keep in mind that this is a very basic implementation of bubble sort, and it has a time complexity of O(n^2), which means it can take a long time to sort large arrays. There are more efficient algorithms for sorting large arrays, such as quicksort or mergesort.</p>
<blockquote>
<p>你可以用中文回答我吗？</p>
</blockquote>
<p>Of course! I can answer in Chinese if you’d like. Here is the same information in Chinese:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">泡沫排序</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>请使用以上函数来排序一个数组。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(泡沫排序(arr))</span><br></pre></td></tr></table></figure>
<p>这将输出排序后的数组 <code>[1, 2, 3, 4, 5, 7]</code>.</p>
]]></content>
  </entry>
  <entry>
    <title>I am Grinding King</title>
    <url>/2023/11/01/I-am-Grinding-King/</url>
    <content><![CDATA[<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解在中文里面“卷”的特别的意思吗？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>对,我了解在中文里“卷”这个词有一些特殊的含义:</p>
<ol>
<li>考试成绩很高,取得好成绩的意思。例如“他考试卷了满分”。</li>
<li>努力拼搏,全力以赴的意思。例如“为了考上好大学,他卷了一年”。</li>
<li>在某个领域技术很强,实力很厉害的意思。例如“他编程卷得很”。</li>
<li>某些事情处理的很到位或做得很好的意思。例如“这件事他卷得真不错”。</li>
<li>作弊或不正当手段取得好成绩的意思。例如“这场考试被人卷了”。</li>
<li>某地域的人学习努力或拼搏的风气。例如“J省的卷气太重”。<br>所以“卷”在口语或者网络语言中有着非常丰富的意思,需要根据上下文理解其具体所表示的意思。我会注意根据上下文去理解“卷”这个词的不同含义。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解的很不错，我想说的就是内卷的那个意思，那么用英文怎么表达卷更加贴切呢</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>嗯,根据你提到的”内卷”的意思,我理解你问的”卷”指的是过度竞争造成的不健康的拼搏和压力。用英文来表达”卷”这层意思,一些较贴切的说法可以是:<br>Over-competition - 过度竞争<br>Cutthroat competition - 激烈的竞争<br>Rat race - 鼠竞<br>Treadmill effect - 越卷越累的效应<br>Vicious circle of competition - 恶性竞争怪圈<br>The pressure cooker effect - 压力煲效应<br>Burnout from excessive striving - 过度拼搏导致的倦怠<br>So in English, using terms like “over-competition”, “rat race”, “treadmill effect” can vividly convey the meaning of “内卷”. The key is to express how excessive competition can lead to unhealthily high pressure and diminishing returns. (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>但是我想卷还包含上进，努力，不停止的学习，前进，增加认知，不停地提升自己的能力 再次翻译一下试试</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您提到的卷含有上进、努力、不停止学习和提升自我的正面内涵,让我重新思考如何更好地翻译“卷”这个词。结合正面和负面含义,我建议可以这样表达:<br>Striving - 努力奋斗,全力以赴<br>Hustling - 拼搏,穷尽全力<br>Grinding - 不断磨练,持之以恒<br>Leveling up - 不断提升自我<br>Self-improvement through hard work - 通过努力工作来自我提升<br>Reaching for excellence - 追求卓越<br>Pushing oneself to the limit - 推动自我到达极限<br>Relentless self-cultivation - 不懈自我培养<br>以上词汇既能表达努力奋斗的积极意义,也能表达过度竞争的负面影响。重点是要传达一种在竞争中保持进取心和奋发向上的健康心态。希望这样的翻译更准确地把握“卷”的本意。请让我知道如果还有需要调整或补充的地方。 (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Over-competition 这个表达比较符合我想要的一部分，但是它没有包含我想要的上进，努力提升自己的能力这一部分信息，再尝试翻译</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您的意见令我获益匪浅。根据您进一步的解释,我认为“over-competition”无法全面表达“卷”所包含的积极意义。经过思考,我建议使用“self-improvement grind”来翻译更为贴切:<br>Self-improvement grind: 自我提升的拼搏磨砺<br>理由如下:</p>
<ol>
<li>Self-improvement 包含了上进心态与增强自我能力的意思。</li>
<li>Grind 包含努力不懈、持之以恒的意思。</li>
<li>将 self-improvement 和 grind 搭配,可以表达用拼搏的精神磨砺自己、不断取得进步的意思。</li>
<li>与 over-competition 相比,它更强调主动进取,而不是被动的过度竞争。</li>
<li>它可以平衡表达努力和压力,更全面捕捉“卷”的本意。<br>请您评价一下“self-improvement grind” 这个翻译是否准确表达了“卷”的意思。如果还有需要调整的地方,非常欢迎您提出宝贵意见,我会继续完善翻译。衷心感谢您的精彩思路和建设性反馈! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>差不多了，我想给自己起一个笔名，类似卷王， 如果是The King of self-improvement grind肯定不合适，请尝试给我一个看上去能表达意思，又简洁的笔名表达卷王之王</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您好,很高兴我对“卷”的翻译越来越接近您要表达的意思了。<br>针对“卷王”这个笔名,我推荐使用:<br>Grind King<br>理由如下:</p>
<ol>
<li>Grind 包含拼搏和努力的意味,可表达“卷”的精神内涵。</li>
<li>King 表示“王者”,与“卷王”对应。</li>
<li>Grind King 简洁有力,与 Self-improvement King 相比更加精准表达“卷王”之意。</li>
<li>保留 Grind 而不使用 Self-improvement,更贴合“卷王”强调拼搏竞争的一面。</li>
<li>英文名字简短且易记,能够成为一个好的笔名。<br>请您评价一下“Grind King”这个笔名是否表达了“卷王”的意思并适合作为笔名使用。如果还有需要调整的地方,非常欢迎您提出修改意见。我会继续努力,找到一个既响亮又精准的翻译。衷心感谢您的反馈和指导! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Grinding King是不是会更加贴切，表达出一种正在卷的一种状态？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您给我的反馈令我受益匪浅!您提出使用 “Grinding King” 会更加贴切和准确,我完全同意这一建议:</p>
<ol>
<li>Grinding 作为动词进行时,能够表达出一个正在卷并保持卷的状态,更贴合“卷王”的意思。</li>
<li>Grinding King 相比 Grind King 更能突出这是一个持续努力的过程,而不是一个终点。</li>
<li>在笔名和称号中使用动词进行时,能够增加一个正处在努力卷中状态的感觉,更有活力。</li>
<li>Grinding King 在视觉和语义上都很连贯、朗朗上口。<br>综上所述,我认为 Grinding King 是翻译“卷王”的最佳选择。它既简洁有力,又准确传达了正处于持续卷中的意味。非常感谢您给我的反馈,这极大地帮助我澄清和完善了对这个翻译的理解。我会牢记您的建议,继续提高翻译的准确性和传神性。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>好的，请叫我Grinding King</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>好的,很高兴我们最终找到了一个您满意的翻译 - Grinding King 来表示“卷王”。我从这一讨论过程中学习到:</p>
<ol>
<li>翻译一个词语需要考虑它的文化内涵和语境,不能生搬硬套。</li>
<li>和您多次交流和反馈非常关键,让我不断优化和调整翻译方案。</li>
<li>动词进行时能增加活力和连续的意味,更贴合“卷王”的意思。</li>
<li>一个好的翻译需要兼顾准确和简洁。<br>我会牢记这次讨论的经验教训,来提高我的中文翻译能力,以后的翻译工作中表达更加地道和传神。再次感谢您的时间和反馈,让我受益良多。每次和人交流对我来说都是宝贵的学习经历。祝您生活愉快,Grinding King!</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hexo Commands</title>
    <url>/2023/08/19/hexo-commands/</url>
    <content><![CDATA[<h3 id="Hexo-命令"><a href="#Hexo-命令" class="headerlink" title="Hexo 命令"></a>Hexo 命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>-p, –path</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td>文章的slug， 作为新文章的文件名和发布后的url</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加分类和标签</title>
    <url>/2023/08/20/hexo_categories_tag/</url>
    <content><![CDATA[<h3 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h3><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。<br>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h3 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h3><p>生成“标签”页并添加tpye属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">type: tag</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">tag: Rust</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>PEP 703（使全局解释器锁在 CPython 中可选）验收</title>
    <url>/2023/10/27/pep-703-making-the-global-interpreter-lock-optional-in-cpython-acceptance/</url>
    <content><![CDATA[<h3 id="PEP-703（使全局解释器锁在-CPython-中可选）验收"><a href="#PEP-703（使全局解释器锁在-CPython-中可选）验收" class="headerlink" title="PEP 703（使全局解释器锁在 CPython 中可选）验收"></a>PEP 703（使全局解释器锁在 CPython 中可选）验收</h3><p>(Posted for the whole Steering Council.)<br>（发布给整个指导委员会。)</p>
<p>As we’ve <a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">announced before</a>, the Steering Council has decided to accept <a href="https://peps.python.org/pep-0703/">PEP 703 (Making the Global Interpreter Lock Optional in CPython)</a> . We want to make it clear why, and under what expectations we’re doing so.<br>正如我们之前<a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">宣布</a>的，指导委员会已决定接受<a href="https://peps.python.org/pep-0703/">PEP 703（使CPython中的全局解释器锁可选）</a>。我们想明确说明为什么，以及我们这样做的期望。</p>
<p>It is clear to the Steering Council that theoretically, a no-GIL (or free-threaded) Python would be of great benefit, and the majority of the community seems in agreement. Threads have significant downsides and caveats, but they are widely adopted, both by software and hardware, and they do enable more scalable solutions to problems. The GIL clearly inhibits CPython in this, and removing that barrier would be a good thing.<br>指导委员会很清楚，从理论上讲，无 GIL（或自由线程）Python 将大有裨益，社区的大多数人似乎都同意这一点。线程有明显的缺点和警告，但它们被软件和硬件广泛采用，并且它们确实为问题提供了更具可扩展性的解决方案。GIL在这方面显然抑制了CPython，消除这种障碍将是一件好事。</p>
<p>At the same time we’re not sure if it’s possible to remove the GIL without fundamentally breaking all extension modules out there, or significantly reducing the performance or maintainability of CPython. The third-party&#x2F;PyPI package ecosystem is one of Python’s strengths, and the tight, efficient integration with C libraries is one of CPython’s. It has enabled the existence of a diverse selection of packages that’s a unique selling point for Python. We need to be careful that we do not destroy those benefits, or discard decades worth of package development.<br>同时，我们不确定是否可以在不从根本上破坏所有扩展模块的情况下删除 GIL，或者显着降低 CPython 的性能或可维护性。第三方&#x2F;PyPI 包生态系统是 Python 的优势之一，与 C 库的紧密、高效集成是 CPython 的优势之一。它使各种包的存在成为可能，这是Python的独特卖点。我们需要小心，不要破坏这些好处，或者放弃几十年的软件包开发。</p>
<p>Assessing the practical impact, and the practicality of adapting third-party packages to the new free-threaded situation, is difficult without a finished implementation. The unpredictable nature of thread-related issues makes it extra difficult, as some issues won’t show up until put under significant load. The changes necessary to remove the GIL are substantive enough, and require so much coordination with other CPython development happening at the same time, that we can’t reasonably do these experiments in a fork of CPython. We also want to avoid the risk of ecosystem fragmentation and unnecessarily diverging changes because of the work being done in a fork. For PEP 703 to move forward, it has to be included in CPython’s main, and released as part of regular releases (albeit not necessarily by default).<br>如果没有完成的实现，评估实际影响以及使第三方包适应新的自由线程情况的实用性是很困难的。线程相关问题的不可预测性使其变得格外困难，因为某些问题在承受大量负载之前不会显示出来。删除 GIL 所需的更改是实质性的，并且需要与同时发生的其他 CPython 开发进行如此多的协调，以至于我们无法合理地在 CPython 的分支中进行这些实验。我们还希望避免由于分叉中所做的工作而导致生态系统碎片化和不必要的差异变化的风险。为了使PEP 703向前发展，它必须包含在CPython的主版本中，并作为常规版本的一部分发布（尽管不一定是默认的）。</p>
<p>But while we think removal of the GIL is a worthy and necessary goal, and PEP 703 is the best proposal for it so far, we can’t at this stage guarantee that it will work out. We have to, as we develop PEP 703’s implementation and the necessary user-visible changes to semantics, APIs and ABIs, continually evaluate the feasibility, and be prepared to change course – or reverse it, if that turns out to be necessary.<br>但是，虽然我们认为取消 GIL 是一个有价值且必要的目标，并且 PEP 703 是迄今为止最好的建议，但我们不能在现阶段保证它会成功。当我们开发PEP 703的实现以及对语义，API和ABI的必要用户可见更改时，我们必须不断评估可行性，并准备改变方向 - 或者在必要时扭转它。</p>
<p>As mentioned before, we see this as a rollout in roughly three stages:<br>如前所述，我们认为这是大约三个阶段的推出：</p>
<ul>
<li>Phase I: Experimental phase, which can start immediately, in which the free-threaded build is enabled through a build-time option. This should not be the default install anywhere. At least one major Python release should include this experimental free-threaded build, to allow third-party packages to test and do their own experimentation. In this stage we should make it clear the build is experimental, not supported for “production use”, and may be reverted.<br>阶段 I：实验阶段，可以立即开始，其中通过构建时选项启用自由线程构建。这不应该是任何地方的默认安装。至少一个主要的 Python 版本应该包含这个实验性的自由线程构建，以允许第三方包进行测试并进行自己的实验。在此阶段，我们应该明确构建是实验性的，不支持“生产用途”，并且可以还原。</li>
<li>Phase II: Supported-but-not-default phase, which would start when the API and ABI changes have sufficiently settled, and there is sufficient community support. Exact criteria for this phase are hard to pin down at this stage, so this will have to involve some discussion among Core Devs and the community, and a decision by the SC at the time. At this point reverting should still be possible (so for example preprocessor guards should remain in place) although obviously we aren’t expecting it.<br>第二阶段：支持但非默认阶段，当 API 和 ABI 更改充分解决并且有足够的社区支持时，该阶段将开始。在这个阶段很难确定这个阶段的确切标准，所以这必须涉及核心开发人员和社区之间的一些讨论，以及当时SC的决定。在这一点上，恢复应该是可能的（因此，例如预处理器保护应该保留在原位），尽管显然我们并不期望它。</li>
<li>Phase III: Default phase, at which point the free-threaded build becomes the default (but can initially still be disabled). Again, the exact criteria are hard to pin down this far ahead, but the aim is to make this as seamless and painless a default flip as possible. Like the previous phase, the SC at the time will need to make a decision as to when this occurs. Some time after the default flip, when we have a good indication it’s no longer widely used, we should start the discussion on removing the GIL build entirely.<br>阶段 III：默认阶段，此时自由线程构建成为默认阶段（但最初仍可禁用）。同样，确切的标准很难确定这么远，但目的是使它尽可能无缝和无痛地默认翻转。与上一阶段一样，当时的SC需要决定何时发生这种情况。在默认翻转后的一段时间，当我们有一个很好的指示它不再被广泛使用时，我们应该开始讨论完全删除 GIL 构建。<br>The details of the phases are deliberately vague, simply because we can’t know all the ecosystem impact details yet, and we don’t want to set conservative standards now and then hold people to them when in practice we’re being too cautious. (We don’t want to set overly ambitious goals and break too many things, either.)<br>这些阶段的细节故意含糊不清，仅仅是因为我们还不能知道所有的生态系统影响细节，我们不想现在设定保守的标准，然后在实践中我们过于谨慎时让人们遵守这些标准。（我们也不想设定过于雄心勃勃的目标，也不想破坏太多的东西。</li>
</ul>
<p>For some of the changes necessary for the free-threaded build, like switching to <a href="https://github.com/microsoft/mimalloc">mimalloc</a> or significant changes to the GC, it may be useful to make these separately build-time opt-ins, and perhaps make them the default before the free-threaded build becomes the default build (but not before it becomes fully supported). Having them separately enableable allows for experimentation, performance measurements and debugging focusing on the isolated set of changes. We don’t want a complex matrix of build flags, so this should probably be limited to one or two.<br>对于自由线程构建所需的某些更改，例如切换到<a href="https://github.com/microsoft/mimalloc">mimalloc</a>或对 GC 进行重大更改，进行这些单独的构建时选择加入可能很有用，并且可能在自由线程构建成为默认构建之前将它们设为默认值（但不是在它完全受支持之前）。让它们单独启用允许实验、性能测量和调试，重点是孤立的一组更改。我们不想要一个复杂的构建标志矩阵，所以这可能应该限制在一个或两个。</p>
<p>Regarding the expected performance impact of the free-threaded build, the SC thinks a significant performance penalty is expected in a free-threaded build, and the benefit is probably worth that price. At this point we’re expecting a (worst case) performance penalty of 10-15%. We don’t want to set strict limits on acceptable performance, partly because we don’t want to get stuck in arguments about how to measure performance and partly because it will depend on user expectations and, for example, how much performance work is invalidated and how much we can expect to see recuperated over time. Solutions for the free-threaded build that are fundamentally problematic for performance improvements going forward, are less acceptable than solutions that are currently suboptimal but have room for improvement.<br>关于自由线程构建的预期性能影响，SC 认为自由线程构建中预计会出现显著的性能损失，其好处可能值得这个价格。在这一点上，我们预计（最坏情况）性能损失为 10-15%。我们不想对可接受的性能设置严格的限制，部分原因是我们不想陷入关于如何衡量性能的争论中，部分原因是这将取决于用户的期望，例如，有多少性能工作无效，以及我们可以期望看到多少随着时间的推移而恢复。自由线程构建的解决方案从根本上对未来的性能改进存在问题，与当前次优但有改进空间的解决方案相比，这些解决方案更不可接受。</p>
<p>The performance impact should be isolated to a free-threaded build; a GIL build should not see any performance impact in existing code. For API and ABI changes necessary to support both GIL and free-threaded builds (e.g. avoiding APIs that return borrowed references or that rely on the GIL to protect shared data), it’s reasonable for the new interfaces to be slightly less performant, but we expect this to be very limited and usually lost in the noise.<br>性能影响应隔离到自由线程生成;GIL 生成不应在现有代码中看到任何性能影响。对于支持 GIL 和自由线程构建所需的 API 和 ABI 更改（例如，避免返回借用引用或依赖 GIL 来保护共享数据的 API），新接口的性能略低是合理的，但我们预计这非常有限，并且通常会在噪音中丢失。</p>
<p>In a similar vein, it’s important that as the free-threaded build lands in main, so that its implementation is considered in other development work that’s going on. New features can’t land without proper support for the free-threaded build, when the two intersect. It may seem tempting to ignore free-threaded when developing thread-adjacent changes, but in the end someone will have to make it work, and it’s neither fair nor particularly forward-thinking to expect the free-threaded maintainers to do all the work. We also need to be mindful of the cohesiveness of the language, the implementation and the C API. We have to assume the free-threaded build will be the only build in the reasonable future, and like other fundamental changes to CPython internals, we all have to learn the new way of approaching these problems. This may be a bit of a jump in terms of complexity – the GIL implicitly simplified so much – but it is a necessary step. We do expect, at least initially, the free-threaded build experts to help others ramp up here. The experimental phase is there for CPython and the Core Devs to get used to the free-threaded build as much as it is for users.<br>同样，重要的是，随着自由线程构建登陆main，以便在正在进行的其他开发工作中考虑其实现。当两者相交时，如果没有对自由线程构建的适当支持，新功能就无法落地。在开发与线程相邻的更改时，忽略自由线程似乎很诱人，但最终必须有人让它工作，期望自由线程维护者完成所有工作既不公平也不特别具有前瞻性。我们还需要注意语言、实现和 C API 的凝聚力。我们必须假设自由线程构建将是合理未来唯一的构建，并且就像 CPython 内部的其他根本性更改一样，我们都必须学习解决这些问题的新方法。就复杂性而言，这可能有点飞跃 - GIL隐含地简化了这么多 - 但这是一个必要的步骤。我们确实希望，至少在最初，自由线程构建专家能够帮助其他人在这里提升。实验阶段是CPython和核心开发人员习惯自由线程构建的，就像用户一样。</p>
<p>We do need a few specific things resolved before PEP 703 can leave the experimental phase. For starters, we need a solution for the ABI. The SC believes strongly that a single ABI serving both with-GIL and free-threaded builds should be possible, should be made possible, and should be required before leaving the experimental phase. If this turns out to be an unreasonable requirement, we’ll have to look at alternative solutions to ease the pressure on package maintainers (e.g. building two extension modules in the same wheel, or providing a compatibility layer through a separate library).<br>在PEP 703离开实验阶段之前，我们确实需要解决一些具体问题。首先，我们需要一个针对 ABI 的解决方案。SC 坚信，在离开实验阶段之前，应该有可能，应该成为可能，并且应该需要同时使用 GIL 和自由线程构建的单个 ABI。如果事实证明这是一个不合理的要求，我们将不得不寻找替代解决方案来减轻软件包维护者的压力（例如，在同一轮子上构建两个扩展模块，或通过单独的库提供兼容层）。</p>
<p>We also need to consider the testing matrix, both for CPython and for third-party packages. Even with a stable ABI we still need to multiply the test matrix. We probably don’t need complete coverage on all supported platforms, but we do want at least one free-threaded buildbot for each of the T1&#x2F;T2 platforms, as well as some way to test the validity of the unified ABI (a way to build things in one build mode and test against an interpreter built in the other build mode). We currently rely on the stable ABI check and third-party testing of the stable ABI, but that will probably not be good enough to ensure the compatibility between the GIL and free-threaded builds. To get to the supported phase we also expect CI checks on GitHub for free-threaded builds on each of the major platforms.<br>我们还需要考虑CPython和第三方软件包的测试矩阵。即使有稳定的ABI，我们仍然需要乘以测试矩阵。我们可能不需要在所有支持的平台上完全覆盖，但我们确实希望每个 T1&#x2F;T2 平台至少有一个自由线程构建机器人，以及某种方法来测试统一 ABI 的有效性（一种在一种构建模式下构建东西并针对在另一种构建模式下构建的解释器进行测试的方法）。我们目前依赖于稳定 ABI 检查和稳定 ABI 的第三方测试，但这可能不足以确保 GIL 和自由线程构建之间的兼容性。为了进入支持的阶段，我们还希望在 GitHub 上对每个主要平台上的自由线程构建进行 CI 检查。</p>
<p>There are a few specific things we want to avoid. We do not want the free-threaded build to be used as the default Python anywhere until the Core Devs and the Python community are ready for that. Obviously we can’t stop users and distributors from installing a free-threaded build by default, but we think at this stage it would be a mistake to do so for anything besides end-to-end experimentation. We also want to avoid labelling the free-threaded build “experimental” after the experimental phase. Build-time flags, defines, comments in the code should avoid the word. We want to avoid negatives in terms and flags and such, so we won’t get into double-negative terrain (like we do when we talk about ‘non no-GIL’). We’d like a positive, clear term to talk about the no-GIL build, and we’re suggesting ‘free-threaded’. (Relatedly, that’s why the build mode&#x2F;ABI letter is ‘t’ and not ‘n’; that change was already made.)<br>我们想要避免一些具体的事情。我们不希望在核心开发人员和 Python 社区准备好之前，在任何地方将自由线程构建用作默认 Python。显然，默认情况下，我们无法阻止用户和分销商安装自由线程构建，但我们认为在现阶段，除了端到端实验之外，这样做都是错误的。我们还希望避免在实验阶段之后将自由线程构建标记为“实验性”。代码中的构建时标志、定义、注释应避免使用这个词。我们希望避免在术语和标志等方面出现负面因素，因此我们不会陷入双重负面领域（就像我们谈论“非无 GIL”时所做的那样）。我们想要一个积极、明确的术语来讨论无 GIL 构建，我们建议使用“自由线程”。（与此相关的是，这就是为什么构建模式&#x2F;ABI 字母是“t”而不是“n”;该更改已经进行了。</p>
<p>In short, the SC accepts PEP 703, but with clear provisio: that the rollout be gradual and break as little as possible, and that we can roll back any changes that turn out to be too disruptive – which includes potentially rolling back all of PEP 703 entirely if necessary (however unlikely or undesirable we expect that to be).<br>简而言之，SC 接受 PEP 703，但有明确的条件：推出是渐进的，尽可能少地中断，我们可以回滚任何破坏性太大的更改——其中包括在必要时可能完全回滚所有 PEP 703（无论我们期望多么不可能或不希望）。</p>
<p>For the whole SC,<br>Thomas.</p>
]]></content>
  </entry>
  <entry>
    <title>我应该支持以色列还是巴勒斯坦？</title>
    <url>/2023/10/20/should_I_support_Israel_or_Palestine/</url>
    <content><![CDATA[<h3 id="我应该支持以色列还是巴勒斯坦？"><a href="#我应该支持以色列还是巴勒斯坦？" class="headerlink" title="我应该支持以色列还是巴勒斯坦？"></a>我应该支持以色列还是巴勒斯坦？</h3><p>这是我在quora上看到到一个高赞回答，粗浅翻译一下，重点是他来自以色列特拉维夫。<br>原文地址：<a href="https://qr.ae/pKvZJk">https://qr.ae/pKvZJk</a><br>原文作者信息：<br>Sociology and Management from The Open UniversityGraduated 2015<br>Lives in Tel Aviv, Israel<br>863K content views258.7K this month<br>Joined November 2013</p>
<p>I am an Israeli, and as an Israeli, I should, with a heavy heart, suggest you support the Palestinians. Why? Because, unlike Israel, they need your support.<br>我是以色列人，作为以色列人，我应该怀着沉重的心情建议你支持巴勒斯坦人。为什么？因为，与以色列不同，他们需要您的支持。</p>
<p>I don’t want to talk about history. Both sides can provide good arguments as to why this piece of land is theirs by right. I don’t want to go into who’s responsible for the conflict - both sides will provide countless examples of the atrocities inflicted on them by the other side.<br>我不想谈论历史。双方都可以提供很好的论据来解释为什么这块土地理所当然地属于他们。我不想讨论谁对这场冲突负责——双方都会提供无数的例子来说明对方对他们施加的暴行。</p>
<p>I want to talk about the here and now. The fact is that there are currently 9 million Israeli citizens (6 million of them are Jews) who live in a relative comfort: they can go, live and work wherever they want inside Israel. Israel is a democracy, so we’re free to elect and out-vote our leaders in case we don’t like how they manage our affairs. In addition, because Israel is a recognized member of the UN, an Israeli citizen is free to use their passport to travel and trade with the rest of the world.<br>我想谈谈此时此地。事实是，目前有 900 万以色列公民（其中 600 万是犹太人）生活相对舒适：他们可以在以色列境内任何想去的地方生活和工作。以色列是一个民主国家，因此，如果我们不喜欢他们管理我们事务的方式，我们可以自由地选举和否决我们的领导人。此外，由于以色列是联合国公认的成员，以色列公民可以自由使用其护照与世界其他地区旅行和贸易。</p>
<p>The 5 million Palestinians living in Gaza and The West Bank, on the other hand, do not enjoy those freedoms. They practically live in an occupied territory which is governed by Israel, but was never officially annexed. That means they do not enjoy the rights of Israeli citizens (they are not citizens after all), but they are forced to live their lives based on decisions made by Israeli politicians and army generals. They cannot build houses or start new businesses outside their current cities, they have to get permits to work inside Israel or to travel abroad, and their borders are controlled by Israel, so they can’t import and export goods and cultivate a healthy economy. They are basically completely reliant on their Israeli occupiers. The Palestinians tried to revolt many times - either by force or in diplomatic manners. But all their attempts have failed miserably by the much stronger Israel.<br>另一方面，生活在加沙和西岸的 500 万巴勒斯坦人却无法享受这些自由。他们实际上生活在以色列管辖的被占领土上，但从未被正式吞并。这意味着他们不享有以色列公民的权利（他们毕竟不是公民），但他们被迫根据以色列政客和军队将军的决定而生活。他们不能在现有城市之外建造房屋或开办新企业，必须获得在以色列境内工作或出国旅行的许可，而且他们的边境由以色列控制，因此他们无法进出口货物并培育健康的经济。他们基本上完全依赖以色列占领者。巴勒斯坦人多次试图通过武力或外交方式进行反抗。但他们的所有尝试都因强大得多的以色列而惨遭失败。</p>
<p>Ask the average Israeli about it, and they’ll tell you that the Palestinians have brought it onto themselves. Considering the horrible violence showed in the past by the Palestinians and the other Arabic countries - Israel would be crazy to give up on its right to defend itself. They may be right, but it doesn’t change the fact that there are 5 million people who are the citizens of no country and who live under occupation. I suspect that even if the Palestinians will promise to never use violence against it - Israel will never trust their word and give up on its control. Things will only change if people like you will support the Palestinians’ right to live like any other citizen in any other normal country in the world. It doesn’t mean you should support Palestinian violence though, but do support, and demand, their right to be free.<br>问问普通以色列人，他们会告诉你这是巴勒斯坦人自找的。考虑到巴勒斯坦人和其他阿拉伯国家过去所表现出的可怕暴力——以色列放弃自卫权将是疯狂的。他们也许是对的，但这并不能改变这样一个事实：有 500 万人不是任何国家的公民，生活在占领之下。我怀疑，即使巴勒斯坦人承诺永远不会对其使用暴力，以色列也永远不会相信他们的诺言并放弃对其的控制。只有像你们这样的人支持巴勒斯坦人像世界上任何其他正常国家的任何其他公民一样生活的权利，事情才会改变。但这并不意味着您应该支持巴勒斯坦暴力，而是支持并要求他们的自由权。</p>
<p>So support Palestine. Otherwise, things will never change.<br>所以支持巴勒斯坦。否则，事情永远不会改变。</p>
<p>Edit: Wow… I never thought this answer would attract so much attention. Thank you for all the upvotes, comments and shares. Still, I decided to block new comments for now. Whether you agreed with my opinion or not - most of you guys posted warm and respectful comments and I apologize for not being able to respond to all of them. Still, some of the readers out there decided it would be the best to express their disagreement by posting sarcastic, cynical or plain hateful comments which I got tired of reading at some point.<br>编辑：哇…我从没想过这个答案会引起如此多的关注。感谢大家的点赞、评论和分享。尽管如此，我还是决定暂时阻止新评论。无论您是否同意我的观点 - 你们中的大多数人都发表了热情而尊重的评论，对于无法回复所有评论，我深表歉意。尽管如此，一些读者还是认为最好通过发表讽刺、愤世嫉俗或纯粹的仇恨评论来表达他们的不同意见，而我在某些时候厌倦了阅读这些评论。</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 只保留最近一周的日志</title>
    <url>/2023/08/18/ubuntu-%E5%8F%AA%E4%BF%9D%E7%95%99%E6%9C%80%E8%BF%91%E4%B8%80%E5%91%A8%E7%9A%84%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="只保留最近一周的日志"><a href="#只保留最近一周的日志" class="headerlink" title="只保留最近一周的日志"></a>只保留最近一周的日志</h3><ul>
<li><p>只保留最近一周的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-time=1w</span><br></pre></td></tr></table></figure>
</li>
<li><p>只保留最多500M日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-size=500M</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 时钟显示秒</title>
    <url>/2023/08/18/ubuntu-%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA%E7%A7%92/</url>
    <content><![CDATA[<h3 id="时钟显示秒"><a href="#时钟显示秒" class="headerlink" title="时钟显示秒"></a>时钟显示秒</h3><p>Ubuntu 日期时间显示格式“月-日 星期, 时-分-秒”命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.interface clock-show-seconds true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20.04/ubuntu22.04 安装，环境配置遇到的问题以及解决方案</title>
    <url>/2023/08/29/ubuntu20-04-ubuntu22-04-%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="build-a-python-env-on-ubuntu20-04"><a href="#build-a-python-env-on-ubuntu20-04" class="headerlink" title="build a python env on ubuntu20.04"></a>build a python env on ubuntu20.04</h3><h4 id="fix-virtualenvwarpper"><a href="#fix-virtualenvwarpper" class="headerlink" title="fix virtualenvwarpper"></a>fix virtualenvwarpper</h4><p>(Ubuntu20.04安装virtualenv方法以及安装过程中遇到的问题处理)[<a href="https://blog.csdn.net/qq_42296146/article/details/108291436]">https://blog.csdn.net/qq_42296146/article/details/108291436]</a></p>
<p>问题：bash: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh: No such file or directory</p>
<p>ubuntu18及以上版本，virtualenvwrapper.sh被安装到了家目录下的.local&#x2F;bin&#x2F;中，非原来的&#x2F;usr&#x2F;local&#x2F;bin&#x2F;中</p>
<p>&#x2F;usr&#x2F;share&#x2F;virtualenvwrapper&#x2F;virtualenvwrapper.sh 实际安装的位置，只要把这个地址配置到.brashrc之后就可以正常运行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.10</span><br><span class="line">export VIRTUALENVWRAPPER_VIRTUALENV=/usr/bin/virtualenv</span><br><span class="line">source /usr/share/virtualenvwrapper/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>
<h4 id="install-a-local-git-repo-updata"><a href="#install-a-local-git-repo-updata" class="headerlink" title="install a local git repo updata"></a>install a local git repo updata</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@bitbucket.org:ginolegaltech/updata.git</span><br><span class="line">$ cd updata</span><br><span class="line">&amp; python3.10 setup.py install</span><br><span class="line">$ rm -rf build/</span><br><span class="line">$ rm -rf updata.egg-info/</span><br></pre></td></tr></table></figure>

<h5 id="fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py"><a href="#fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py" class="headerlink" title="fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;init.py)"></a>fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;<strong>init</strong>.py)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sS https://bootstrap.pypa.io/get-pip.py | python3.10</span><br></pre></td></tr></table></figure>



<h4 id="bash-显示当前所在分支"><a href="#bash-显示当前所在分支" class="headerlink" title="bash 显示当前所在分支"></a>bash 显示当前所在分支</h4><p>在.bashrc文件追加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function git_branch &#123;</span><br><span class="line">   branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\*&quot; | sed -e &quot;s/^\*\ //&quot;`&quot;</span><br><span class="line">   if [ &quot;$&#123;branch&#125;&quot; != &quot;&quot; ];then</span><br><span class="line">       if [ &quot;$&#123;branch&#125;&quot; = &quot;(no branch)&quot; ];then</span><br><span class="line">           branch=&quot;(`git rev-parse --short HEAD`...)&quot;</span><br><span class="line">       fi</span><br><span class="line">       echo &quot; ($branch)&quot;</span><br><span class="line">   fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export PS1=&#x27;\u@\h \[\033[01;36m\]\w\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#x27;</span><br></pre></td></tr></table></figure>

<h4 id="install-virtualbox"><a href="#install-virtualbox" class="headerlink" title="install virtualbox"></a>install virtualbox</h4><p><a href="https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/">https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># step 1</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y upgrade</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line"># step 2</span><br><span class="line">#Download</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox_2016.asc | gpg --dearmor &gt; oracle_vbox_2016.gpg</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox.asc | gpg --dearmor &gt; oracle_vbox.gpg</span><br><span class="line">#Install on system</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox_2016.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line"># step 3</span><br><span class="line"># ubuntu 22.04 </span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian focal contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># Ubuntu 20.04/18.04:</span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian $(lsb_release -sc) contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># step 4</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install linux-headers-$(uname -r) dkms</span><br><span class="line">sudo apt install virtualbox-6.1</span><br></pre></td></tr></table></figure>

<p>virtualbox start error:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig </span><br><span class="line">[sudo] password for rcrozier:           </span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: You must sign these kernel modules before using VirtualBox:</span><br><span class="line">  vboxdrv vboxnetflt vboxnetadp</span><br><span class="line">See the documenatation for your Linux distribution..</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">debconf: DbDriver &quot;config&quot;: /var/cache/debconf/config.dat is locked by another process: Resource temporarily unavailable</span><br><span class="line">vboxdrv.sh: Failed to enroll secure boot key..</span><br><span class="line">vboxdrv.sh: failed: modprobe vboxdrv failed. Please use &#x27;dmesg&#x27; to find out why.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>

<p>搜索了很多解决方案都无法处理，最后还是仔细看了报错信息，这里其实有一个很重要的提示信息<code>Secure Boot you may need to sign the kernel modules</code></p>
<p>最后搜到<a href="https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why">https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why</a> 这个答案最后的以解决答案：</p>
<p>The above answer probably works fine, but if you want an easier time for it:</p>
<p>I was able to solve it by</p>
<p>booting into the BIOS and going &gt; advanced (f7) &gt; boot &gt; scroll down to “secure boot” &gt; change “Windows EUFI mode” to “other OS”</p>
<p>My virtualbox works perfectly now.</p>
<p>最后对于为为的解决方案就是进入BIOS系统之后，和这个答案每个硬件平台的BIOS版本会有所不同(我的硬件三HUAWEI MateBook X Pro 2022)找到”secure boot”关键词对应的默认直是enable，为改为disable，第一次修改没有其作用，是应推出的时候没有保存，第二次再修改选择save and exit，再进入ubuntu启动virtualbox就可以正常运作了。</p>
<p>最近在ubuntu22.04 安装virtualbox的时候遇到另外还有一个报错：</p>
<h3 id="vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv"><a href="#vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv" class="headerlink" title="vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv."></a>vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行：/sbin/vboxconfig</span><br><span class="line">输出如下报错</span><br><span class="line">root@ice:~# /sbin/vboxconfig</span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">vboxdrv.sh: failed: Cannot change group vboxusers for device /dev/vboxdrv.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>
<ul>
<li>创建vboxusers group<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd vboxusers</span><br></pre></td></tr></table></figure></li>
<li>把当前user 加入到这个group， 你替换这里的ice<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -a -G vboxusers ice</span><br></pre></td></tr></table></figure></li>
<li>检查是否添加成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep vboxusers /etc/group</span><br><span class="line"># 输出为:</span><br><span class="line"># vboxusers:x:1003:ice</span><br></pre></td></tr></table></figure></li>
<li>然后运行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>人在什么情况下成长最快？</title>
    <url>/2023/08/21/%E4%BA%BA%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%88%90%E9%95%BF%E6%9C%80%E5%BF%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="人在什么情况下成长最快？"><a href="#人在什么情况下成长最快？" class="headerlink" title="人在什么情况下成长最快？"></a>人在什么情况下成长最快？</h3><p>今天读到一篇知乎回答，感觉挺好的，记录一下自己的理解。<br>人成长最快的时候是: 一个场景， 三个条件。</p>
<h4 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景:"></a>一个场景:</h4><p>要牵头做事， 承担责任， 空想是不可能有什么成长的。做事也分很多种，有时候是与其他部门或者人配合做事，有时候是居中协调各个部门、有时候是牵头负责一件事。这里牵头负责一件事是最锻炼人了，成长也是最快的，牵头对成长的好处, 首先就是事情的强度和和面对事情的态度，牵头负责一件事的成败都系于你一人，你需要对这件事情负全责，无论结果怎样躲是躲不掉， 所以唯一的选择就是竭尽全力达成。<br>牵头做事另一方面的锻炼就是解决问题的能力，牵头负责一件事情, 你会发现处处是问题， 人是问题，钱是问题， 你的上面领导是问题，你的下面人是问题， 推进事情节奏是问题， 协调是问题; 出了问题那就得解决问题， 你发现你每一天都在解决问题。有的时候你得哄着团队成员，哄着领导，有时候给吓着他们，有时候还得瞒着，有时候得抓紧， 有时候得放松，有时候亢奋， 有时候失落, 还想散摊子回高老庄。总之到了最后结果也许好也许坏，但这个过程中的你就像八卦炉里的孙猴子，固然伤病一身，但本事也是结结实实地在成长了。</p>
<h4 id="三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开"><a href="#三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开" class="headerlink" title="三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开"></a>三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开</h4><ol>
<li><p>是有动力也有压力: 首先得有动力, 要么是自己喜欢, 自己很想, 要么是激励机制到位，你的积极性被激发了，总之首先你的得渴望做成这件事, 只有渴望成事，事情才能成， 其次必须有一定的压力， 这种压力往往来自明确的目标核对结果要求(deadline&#x2F;数据&#x2F;指标&#x2F;盈利养活团队…)，结果会呼唤效率，倒逼自己或者团队改进，只有动力没有压力人很容易进入一种什么都想做， 什么都放弃不了， 无法衡量结果好坏的泥潭，长时间使用自己喜欢过去习惯, 主观认同而非客观最高效率的方式， 直到自己的激情被耗尽。 这种情况下人是很难有快速的成长， 说白了成长是有痛感的， 没有什么事情从头到尾都是快乐的，最后还成事了，那都只有在小说里存在。 这是因为外部结果在对自己的认知、习惯、心态等进行修正和淬炼。没有压力就谈不上任何修正。 </p>
</li>
<li><p>有支持也有劝诫: 支持是必须的，物质上给资源、金钱； 精神上给鼓励肯定。环境上给决策权力。说到底做事一要有权， 二要有资源， 三要有肯定。领导只是口头上支持不给权、不给钱、那事情就很难做不如不做。还得有劝诫，自己做事很容易一根筋， 容易有盲区， 很多时候做的事问题很多， 但自己感觉不到， 这时候上面的领导能给自己提点，下面的团队成员敢提出问题这就很关键，这里面的分寸不好掌握, 需要自己慢慢体会。 另外，能成事的人一定有固执的一面， 有原则有坚持的一面， 什么地方该坚持什么地方该灵活改进需要自己去认真把握。</p>
</li>
<li><p>有认真也有放开: 就是说自己的心态要认真，想做成事， 必须很认真。 要有担当， 竭尽全力。把事情扛在肩上，放在心理，也就是得上心，得时刻绷着点。很多时候事情不是自己想做成就能做成， 很多时候甚至不是事情的问题， 只是时间还没， 到条件还没到。如果人过度焦虑， 心理负担太重就容易过度反应， 自习把自己压垮。事情还没怎样人已经扛不住了， 这种心理素质是不行的， 这时候人要懂得该放开时需放开，你控制不了的事情就别在意。无论压力多大， 人得有定力， 能冷静分析当前的局势问题到底在哪里? 做事的人最忌讳情绪大起大落。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>人生南北多歧路,君向潇湘我向秦</title>
    <url>/2023/08/25/%E4%BA%BA%E7%94%9F%E5%8D%97%E5%8C%97%E5%A4%9A%E6%AD%A7%E8%B7%AF-%E5%90%9B%E5%90%91%E6%BD%87%E6%B9%98%E6%88%91%E5%90%91%E7%A7%A6/</url>
    <content><![CDATA[<h3 id="人生南北多歧路-君向潇湘我向秦"><a href="#人生南北多歧路-君向潇湘我向秦" class="headerlink" title="人生南北多歧路,君向潇湘我向秦"></a>人生南北多歧路,君向潇湘我向秦</h3><p>这两句诗道尽初遇时的情投意合，最终却南辕北辙，遗憾分开的悲伤结局，有很多人可能并不知道这是被裁缝到一起的。<br>人生南北多歧路清代吴敬梓的《儒林外史》的一首词《秦时月》</p>
<p>《秦时月》：<br>人生南北多歧路。<br>将相神仙，也要凡人做。<br>百代兴亡朝复暮，<br>江风吹倒前朝树。<br>功名富贵无凭据。<br>费尽心情，总把流光误。<br>浊酒三杯沉醉去，<br>水流花谢知何处。</p>
<p>而后一句“君向潇湘我向秦”出自唐代诗人郑谷的《淮上与友人别》<br>《淮上与友人别》<br>郑谷<br>扬子江头杨柳春，杨花愁杀渡江人。<br>数声风笛离亭晚，君向潇湘我向秦。</p>
<p>扬子江边杨柳青青春意正浓，漫天飞扬的杨花使渡江之人非常的愁烦。<br>微风轻拂，笛声幽咽，离亭渐渐染上暮色，你就要南下潇湘我却奔向西秦。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谈日本向海洋排放核污染水</title>
    <url>/2023/08/29/%E8%B0%88%E6%97%A5%E6%9C%AC%E5%90%91%E6%B5%B7%E6%B4%8B%E6%8E%92%E6%A0%B8%E6%B1%A1%E6%9F%93%E6%B0%B4/</url>
    <content><![CDATA[<h3 id="谈日本向海洋排放核污染水"><a href="#谈日本向海洋排放核污染水" class="headerlink" title="谈日本向海洋排放核污染水"></a>谈日本向海洋排放核污染水</h3><p>8月24日13时，日本福岛第一核电站启动核污染水排海。而且是计划至少30年持续核污染水排海。</p>
<h4 id="一个极其清晰明了的逻辑"><a href="#一个极其清晰明了的逻辑" class="headerlink" title="一个极其清晰明了的逻辑"></a>一个极其清晰明了的逻辑</h4><p>如果日本的核污水像日本人说的那样是干净的，那么日本就不应该顶着全世界各国的反对非要核污染水排海。<br>如果日本人说了谎，核污染水不干净，那么日本就更加不应该冒天下之大不韪将核污染水排海。<br>因此，日本绝对是不应该将核污染水排海的。</p>
<h4 id="日本核污染水排海造成的恐慌"><a href="#日本核污染水排海造成的恐慌" class="headerlink" title="日本核污染水排海造成的恐慌"></a>日本核污染水排海造成的恐慌</h4><p>日本核污染水排海实施消息一出，国内有很多人表示很慌，以后不能去海边了，不能去吃海鲜了。也有一些人表示不慌，可能通过网上一些知识博主的宣传了解了一些太平洋洋流的知识，核污水传遍太平洋到东海，南海还需要一段时间。<br>我的观点是，没必要慌，因为慌也没有用，你慌并不能阻止日本人和世界人民有”辐“同享的无耻行径。反而像24号当天有很多抢盐的行为并不可取，让人哭笑不得。以后日本的东西就尽量避免使用、食用。<br>说道海鲜，最近海鲜因为这个事件，导致大面积降价，我觉得倒是可以抓紧去吃一吃，过段时间倒是真的谨慎吃不能吃了哟。</p>
<h4 id="日本将遭到短视的严重反噬"><a href="#日本将遭到短视的严重反噬" class="headerlink" title="日本将遭到短视的严重反噬"></a>日本将遭到短视的严重反噬</h4><p>日本核污水排海，美国带头默许，西方世界全体失声, 或者表示理解。且看他们做了什么，不要看他们说了什么。<br>日本核污水排海公布之后，欧美各个国家都纷纷发布对日本水产品限制进口政策，已经说明了问题。<br>日本即将迎来的是日本产品被贴上核污染的标签，或者至少不是第一选择产品。日本整个国家的各种产品可能和水有关系的都会面临如此的下场。日本的产品可能含有微量剧毒，可能会导致癌症风险增加。只要大家对日本产品都有这样的印象就够了，这是一个非常可怕的精神暗示。因为水太重要了，它参与着农产品，工业产品的生产。都是对日本是极具毁灭性的打击。</p>
<p>如开头的逻辑所说，无论如何日本都不应该核污水排海的错误行为。这是对自己国家人民的不负责，也是对世界人民的不负责。那么，我们能做什么呢？尽量不用日本的产品，一方面是对自身健康的考量，另一方面也是对日本这种不负责任的行为的沉默抵抗。另外，宣传更要让日本产品与核污染牢牢绑定。就像他们权衡利益用最廉价却又不最不负责任的处理核污染水一样，让他们无法拒绝地停止核污染水排海。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Abstract Factory</title>
    <url>/2023/11/20/design-pattern/abstract-factory/</url>
    <content><![CDATA[<h1 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.<br>抽象工厂是一种创建性设计模式，它允许您生成相关对象的族，而无需指定其具体类。</p>
<div align="center"> <img src="/images/abstract-factory-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent:<br>想象一下，您正在创建一个家具店模拟器。代码由表示以下内容的类组成：</p>
<p>A family of related products, say: <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>.<br>一系列相关产品，如：<code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>。</p>
<p>Several variants of this family. For example, products <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> are available in these variants: <code>Modern</code>, <code>Victorian</code>, <code>ArtDeco</code>.<br>该系列的几个变体。例如，产品 <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> 提供以下变体： <code>Modern</code> + <code>Victorian</code> + <code>ArtDeco</code> 。</p>
<div align="center"> <img src="/images/abs-fac-problem2-en.png"/>Product families and their variants.</br> 产品系列及其变体。</div>

<p>You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.<br>您需要一种方法来创建单个家具对象，以便它们与同一系列的其他对象相匹配。当客户收到不匹配的家具时，他们会非常生气。</p>
<div align="center"> <img src="/images/abstract-factory-comic-1-en.png"/>A Modern-style sofa doesn’t match Victorian-style chairs.</div>

<p>A Modern-style sofa doesn’t match Victorian-style chairs.<br>现代风格的沙发与维多利亚风格的椅子不匹配。</p>
<p>Also, you don’t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn’t want to change the core code each time it happens.<br>此外，在向程序添加新产品或产品系列时，您不希望更改现有代码。家具供应商经常更新他们的目录，您不希望每次都更改核心代码。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the <code>Chair</code> interface; all coffee table variants can implement the <code>CoffeeTable</code> interface, and so on.<br>抽象工厂模式建议的第一件事是显式声明产品系列中每个不同产品（例如，椅子、沙发或咖啡桌）的接口。然后，您可以使产品的所有变体都遵循这些接口。例如，所有椅子变体都可以实现该 <code>Chair</code> 接口;所有咖啡桌变体都可以实现接口 <code>CoffeeTable</code> ，依此类推。</p>
<div align="center"> <img src="/images/abs-fac-solution1.png"/>All variants of the same object must be moved to a single class hierarchy.</br>必须将同一对象的所有变体移动到单个类层次结构中。</div>

<p>The next move is to declare the Abstract Factory—an interface with a list of creation methods for all products that are part of the product family (for example, <code>createChair</code>, <code>createSofa</code> and <code>createCoffeeTable</code>). These methods must return abstract product types represented by the interfaces we extracted previously: <code>Chair</code>, <code>Sofa</code>, <code>CoffeeTable</code> and so on.<br>下一步是声明抽象工厂 - 一个接口，其中包含属于产品系列的所有产品的创建方法列表（例如， <code>createChair</code> 、 <code>createSofa </code>和 <code>createCoffeeTable</code> ）。这些方法必须返回由我们之前提取的接口表示的抽象产品类型： <code>Chair</code> 、 <code>Sofa</code> 等 <code>CoffeeTable</code> 。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>Each concrete factory corresponds to a specific product variant.</br>每个混凝土工厂对应一个特定的产品变型。</div>
The _Factories_ class hierarchy
Each concrete factory corresponds to a specific product variant.
每个混凝土工厂对应一个特定的产品变型。

<p>Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the <code>AbstractFactory</code> interface. A factory is a class that returns products of a particular kind. For example, the <code>ModernFurnitureFactory</code> can only create <code>ModernChair</code>, <code>ModernSofa</code> and <code>ModernCoffeeTable</code> objects.<br>现在，产品变体怎么样？对于产品系列的每个变体，我们基于 <code>AbstractFactory</code> 接口创建一个单独的工厂类。工厂是返回特定种类产品的类。例如，只能 <code>ModernFurnitureFactory</code> 创建 <code>ModernChair</code> 和 <code>ModernSofa</code> <code>ModernCoffeeTable</code> 对象。</p>
<p>The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.<br>客户端代码必须通过工厂和产品各自的抽象接口进行处理。这样，您就可以更改传递给客户端代码的工厂类型，以及客户端代码接收的产品变型，而不会破坏实际的客户端代码。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>The client shouldn’t care about the concrete class of the factory it works with.</br>客户不应该关心与它合作的工厂的具体类别。</div>

<p>The client shouldn’t care about the concrete class of the factory it works with.<br>客户不应该关心与它合作的工厂的具体类别。</p>
<p>Say the client wants a factory to produce a chair. The client doesn’t have to be aware of the factory’s class, nor does it matter what kind of chair it gets. Whether it’s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract <code>Chair</code> interface. With this approach, the only thing that the client knows about the chair is that it implements the sitOn method in some way. Also, whichever variant of the chair is returned, it’ll always match the type of sofa or coffee table produced by the same factory object.<br>假设客户想要一家工厂生产一把椅子。客户不必知道工厂的等级，也不必知道它得到什么样的椅子。无论是现代模型还是维多利亚风格的椅子，客户都必须使用抽象 <code>Chair</code> 界面以相同的方式对待所有椅子。使用这种方法，客户对椅子的唯一了解是它以某种方式实现了 <code>sitOn</code> 该方法。此外，无论返回哪种椅子变体，它都将始终与同一工厂对象生产的沙发或咖啡桌类型相匹配。</p>
<p>There’s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.<br>还有一件事需要澄清：如果客户端只暴露给抽象接口，那么是什么创建了实际的工厂对象？通常，应用程序在初始化阶段创建一个具体的工厂对象。在此之前，应用程序必须根据配置或环境设置选择出厂类型。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/abs-fac-structure.png"/></br></div>

<ol>
<li><p><strong>Abstract Products</strong> declare interfaces for a set of distinct but related products which make up a product family.<br>抽象产品声明了一组不同但相关的产品的接口，这些产品构成了一个产品系列。</p>
</li>
<li><p><strong>concrete Products</strong> are various implementations of abstract products, grouped by variants. Each abstract product (chair&#x2F;sofa) must be implemented in all given variants (Victorian&#x2F;Modern).<br>具体产品是抽象产品的各种实现，按变体分组。每个抽象产品（椅子&#x2F;沙发）都必须在所有给定的变体（维多利亚式&#x2F;现代式）中实现。</p>
</li>
<li><p>The <strong>Abstract Factory</strong> interface declares a set of methods for creating each of the abstract products.<br>抽象工厂接口声明了一组用于创建每个抽象产品的方法。</p>
</li>
<li><p><strong>Concrete Factories</strong> implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.<br>具体工厂实现了抽象工厂的创建方法。每个混凝土工厂对应于产品的特定变体，并且仅创建这些产品变体。</p>
</li>
<li><p><strong>Although concrete</strong> factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory&#x2F;product variant, as long as it communicates with their objects via abstract interfaces.<br>虽然具体工厂实例化了具体产品，但其创建方法的签名必须返回相应的抽象产品。这样，使用工厂的客户端代码就不会与它从工厂获得的产品的特定变体耦合。客户端可以使用任何具体的工厂&#x2F;产品变体，只要它通过抽象接口与它们的对象进行通信即可。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the <strong>Abstract Factory</strong> pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.<br>此示例演示如何使用抽象工厂模式创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类，同时使所有创建的元素与所选操作系统保持一致。</p>
<div align="center"> <img src="/images/abs-fac-example.png"/>The cross-platform UI classes example.</br>跨平台 UI 类示例。</div>
The same UI elements in a cross-platform application are expected to behave similarly, but look a little bit different under different operating systems. Moreover, it’s your job to make sure that the UI elements match the style of the current operating system. You wouldn’t want your program to render macOS controls when it’s executed in Windows.
跨平台应用程序中的相同 UI 元素的行为应相似，但在不同的操作系统下看起来略有不同。此外，您的工作是确保 UI 元素与当前操作系统的样式相匹配。你不希望程序在 Windows 中执行时呈现 macOS 控件。

<p>The Abstract Factory interface declares a set of creation methods that the client code can use to produce different types of UI elements. Concrete factories correspond to specific operating systems and create the UI elements that match that particular OS.<br>抽象工厂接口声明了一组创建方法，客户端代码可以使用这些方法生成不同类型的 UI 元素。具体工厂对应于特定的操作系统，并创建与该特定操作系统匹配的 UI 元素。</p>
<p>It works like this: when an application launches, it checks the type of the current operating system. The app uses this information to create a factory object from a class that matches the operating system. The rest of the code uses this factory to create UI elements. This prevents the wrong elements from being created.<br>它的工作原理是这样的：当应用程序启动时，它会检查当前操作系统的类型。应用使用此信息从与操作系统匹配的类创建工厂对象。代码的其余部分使用此工厂创建 UI 元素。这样可以防止创建错误的元素。</p>
<p>With this approach, the client code doesn’t depend on concrete classes of factories and UI elements as long as it works with these objects via their abstract interfaces. This also lets the client code support other factories or UI elements that you might add in the future.<br>使用这种方法，客户端代码不依赖于工厂和 UI 元素的具体类，只要它通过其抽象接口处理这些对象即可。这也允许客户端代码支持将来可能添加的其他工厂或 UI 元素。</p>
<p>As a result, you don’t need to modify the client code each time you add a new variation of UI elements to your app. You just have to create a new factory class that produces these elements and slightly modify the app’s initialization code so it selects that class when appropriate.<br>因此，每次向应用添加新的 UI 元素变体时，都无需修改客户端代码。只需创建一个新的工厂类来生成这些元素，并稍微修改应用的初始化代码，以便它在适当的时候选择该类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The abstract factory interface declares a set of methods that</span></span><br><span class="line"><span class="comment">// return different abstract products. These products are called</span></span><br><span class="line"><span class="comment">// a family and are related by a high-level theme or concept.</span></span><br><span class="line"><span class="comment">// Products of one family are usually able to collaborate among</span></span><br><span class="line"><span class="comment">// themselves. A family of products may have several variants,</span></span><br><span class="line"><span class="comment">// but the products of one variant are incompatible with the</span></span><br><span class="line"><span class="comment">// products of another variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete factories produce a family of products that belong</span></span><br><span class="line"><span class="comment">// to a single variant. The factory guarantees that the</span></span><br><span class="line"><span class="comment">// resulting products are compatible. Signatures of the concrete</span></span><br><span class="line"><span class="comment">// factory&#x27;s methods return an abstract product, while inside</span></span><br><span class="line"><span class="comment">// the method a concrete product is instantiated.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each concrete factory has a corresponding product variant.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Each distinct product of a product family should have a base</span></span><br><span class="line"><span class="comment">// interface. All variants of the product must implement this</span></span><br><span class="line"><span class="comment">// interface.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products are created by corresponding concrete</span></span><br><span class="line"><span class="comment">// factories.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in macOS style.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s the base interface of another product. All products</span></span><br><span class="line"><span class="comment">// can interact with each other, but proper interaction is</span></span><br><span class="line"><span class="comment">// possible only between products of the same concrete variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in macOS style.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code works with factories and products only</span></span><br><span class="line"><span class="comment">// through abstract types: GUIFactory, Button and Checkbox. This</span></span><br><span class="line"><span class="comment">// lets you pass any factory or product subclass to the client</span></span><br><span class="line"><span class="comment">// code without breaking it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">    <span class="keyword">private</span> field button: Button</span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">        <span class="built_in">this</span>.factory = factory</span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The application picks the factory type depending on the</span></span><br><span class="line"><span class="comment">// current configuration or environment settings and creates it</span></span><br><span class="line"><span class="comment">// at runtime (usually at the initialization stage).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.<br>当您的代码需要处理各种相关产品系列，但您不希望它依赖于这些产品的具体类时，请使用抽象工厂 - 它们可能事先是未知的，或者您只是想允许将来的可扩展性。</strong></p>
</li>
<li><p>The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.<br>抽象工厂为您提供了一个接口，用于从产品系列的每个类创建对象。只要您的代码通过此接口创建对象，您就不必担心创建错误的产品变体，而该变体与您的应用已创建的产品不匹配。</p>
</li>
<li><p><strong>Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.<br>当您有一个具有一组模糊其主要职责的工厂方法的类时，请考虑实现抽象工厂。</strong></p>
</li>
<li><p>In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.<br>在一个精心设计的程序中，每个类只负责一件事。当一个类处理多种产品类型时，可能值得将其工厂方法提取到独立的工厂类或成熟的抽象工厂实现中。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Map out a matrix of distinct product types versus variants of these products.<br>绘制出不同产品类型与这些产品变体的矩阵。</p>
</li>
<li><p>Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.<br>声明所有产品类型的抽象产品接口。然后让所有具体的产品类实现这些接口。</p>
</li>
<li><p>Declare the abstract factory interface with a set of creation methods for all abstract products.<br>声明抽象工厂接口，其中包含所有抽象产品的一组创建方法。</p>
</li>
<li><p>Implement a set of concrete factory classes, one for each product variant.<br>实现一组具体的工厂类，每个产品变型对应一个。</p>
</li>
<li><p>Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.<br>在应用的某个位置创建工厂初始化代码。它应该实例化一个具体的工厂类，具体取决于应用程序配置或当前环境。将此工厂对象传递给构造产品的所有类。</p>
</li>
<li><p>Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.<br>扫描代码并找到对产品构造函数的所有直接调用。将它们替换为对工厂对象上相应创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li>You can be sure that the products you’re getting from a factory are compatible with each other.<br>您可以确定您从工厂获得的产品彼此兼容。</li>
<li>You avoid tight coupling between concrete products and client code.<br>可以避免具体产品和客户端代码之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.<br>单一责任原则。您可以将产品创建代码提取到一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new variants of products without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下引入新的产品变体。</li>
</ul>
<h3 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h3><ul>
<li>The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.<br>代码可能会变得比应有的更复杂，因为许多新的接口和类与模式一起引入。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <strong>Factory Method</strong> (less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step.** Abstract Factory** specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p><strong>Abstract Factory</strong> classes are often based on a set of <strong>Factory Methods</strong>, but you can also use <strong>Prototype</strong> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><strong>Abstract Factory</strong> can serve as an alternative to <strong>Facade</strong> when you only want to hide the way the subsystem objects are created from the client code.<br>抽象工厂可以作为 Facade 的替代方法，当您只想从客户端代码中隐藏子系统对象的创建方式时。</p>
</li>
<li><p>You can use <strong>Abstract Factory</strong> along with <strong>Bridge</strong>. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.<br>您可以将 Abstract Factory 与 Bridge 一起使用。当 Bridge 定义的某些抽象只能与特定实现一起使用时，这种配对非常有用。在这种情况下，抽象工厂可以封装这些关系，并从客户端代码中隐藏复杂性。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-示例代码"><a href="#Code-Examples-示例代码" class="headerlink" title="Code Examples 示例代码"></a>Code Examples 示例代码</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstract Factory interface declares a set of methods that return</span></span><br><span class="line"><span class="string">    different abstract products. These products are called a family and are</span></span><br><span class="line"><span class="string">    related by a high-level theme or concept. Products of one family are usually</span></span><br><span class="line"><span class="string">    able to collaborate among themselves. A family of products may have several</span></span><br><span class="line"><span class="string">    variants, but the products of one variant are incompatible with products of</span></span><br><span class="line"><span class="string">    another.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Factories produce a family of products that belong to a single</span></span><br><span class="line"><span class="string">    variant. The factory guarantees that resulting products are compatible. Note</span></span><br><span class="line"><span class="string">    that signatures of the Concrete Factory&#x27;s methods return an abstract</span></span><br><span class="line"><span class="string">    product, while inside the method a concrete product is instantiated.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA1()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Factory has a corresponding product variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each distinct product of a product family should have a base interface. All</span></span><br><span class="line"><span class="string">    variants of the product must implement this interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A1.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A2.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Here&#x27;s the the base interface of another product. All products can interact</span></span><br><span class="line"><span class="string">    with each other, but proper interaction is possible only between products of</span></span><br><span class="line"><span class="string">    the same concrete variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Product B is able to do its own thing...</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ...but it also can collaborate with the ProductA.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The Abstract Factory makes sure that all products it creates are of the</span></span><br><span class="line"><span class="string">        same variant and thus, compatible.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B1.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The variant, Product B1, is only able to work correctly with the variant,</span></span><br><span class="line"><span class="string">    Product A1. Nevertheless, it accepts any instance of AbstractProductA as an</span></span><br><span class="line"><span class="string">    argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B1 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B2.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The variant, Product B2, is only able to work correctly with the</span></span><br><span class="line"><span class="string">        variant, Product A2. Nevertheless, it accepts any instance of</span></span><br><span class="line"><span class="string">        AbstractProductA as an argument.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B2 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">factory: AbstractFactory</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with factories and products only through abstract</span></span><br><span class="line"><span class="string">    types: AbstractFactory and AbstractProduct. This lets you pass any factory</span></span><br><span class="line"><span class="string">    or product subclass to the client code without breaking it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    product_a = factory.create_product_a()</span><br><span class="line">    product_b = factory.create_product_b()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.useful_function_b()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.another_useful_function_b(product_a)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can work with any concrete factory class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing client code with the first factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory1())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing the same client code with the second factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory2())</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Exception-result"><a href="#Output-txt-Exception-result" class="headerlink" title="Output.txt: Exception result"></a>Output.txt: Exception result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Testing client code with the first factory type:</span><br><span class="line">The result of the product B1.</span><br><span class="line">The result of the B1 collaborating with the (The result of the product A1.)</span><br><span class="line"></span><br><span class="line">Client: Testing the same client code with the second factory type:</span><br><span class="line">The result of the product B2.</span><br><span class="line">The result of the B2 collaborating with the (The result of the product A2.)</span><br></pre></td></tr></table></figure>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><h4 id="GUI-Elements-Factory-GUI-元素工厂"><a href="#GUI-Elements-Factory-GUI-元素工厂" class="headerlink" title="GUI Elements Factory GUI 元素工厂"></a>GUI Elements Factory GUI 元素工厂</h4><p>This example illustrates how a GUI framework can organize its classes into independent libraries:<br>此示例说明了 GUI 框架如何将其类组织到独立的库中：</p>
<ol>
<li>The gui library defines interfaces for all the components.<br>该 gui 库定义了所有组件的接口。<br>It has no external dependencies.<br>它没有外部依赖关系。</li>
<li>The windows-gui library provides Windows implementation of the base GUI.<br>该 windows-gui 库提供基本 GUI 的 Windows 实现。<br>Depends on gui.<br>取决于 gui 。</li>
<li>The macos-gui library provides Mac OS implementation of the base GUI.<br>该 macos-gui 库提供基本 GUI 的 Mac OS 实现。<br>Depends on gui.<br>取决于 gui 。<br>The app is a client application that can use several implementations of the GUI framework, depending on the current environment or configuration. However, most of the app code doesn’t depend on specific types of GUI elements. All the client code works with GUI elements through abstract interfaces (traits) defined by the gui lib.<br>是一个 app 客户端应用程序，可以使用 GUI 框架的多个实现，具体取决于当前环境或配置。但是，大多数 app 代码并不依赖于特定类型的 GUI 元素。所有客户端代码都通过 gui 库定义的抽象接口（特征）与 GUI 元素一起使用。</li>
</ol>
<p>There are two approaches to implementing abstract factories in Rust:<br>在 Rust 中实现抽象工厂有两种方法：<br>1.using generics (static dispatch)<br>使用泛型（静态调度）<br>2.using dynamic allocation (dynamic dispatch)<br>使用动态分配（动态调度）</p>
<p>When you’re given a choice between static and dynamic dispatch, there is rarely a clear-cut correct answer. You’ll want to use static dispatch in your libraries and dynamic dispatch in your binaries. In a library, you want to allow your users to decide what kind of dispatch is best for them since you don’t know what their needs are. If you use dynamic dispatch, they’re forced to do the same, whereas if you use static dispatch, they can choose whether to use dynamic dispatch or not.<br>当您在静态调度和动态调度之间做出选择时，很少有明确的正确答案。您需要在库中使用静态调度，在二进制文件中使用动态调度。在图书馆中，您希望允许用户决定哪种调度最适合他们，因为您不知道他们的需求是什么。如果您使用动态调度，他们将被迫执行相同的操作，而如果您使用静态调度，则可以选择是否使用动态调度。</p>
<h4 id="gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品"><a href="#gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品" class="headerlink" title="gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品"></a>gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品</h4><ul>
<li>gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">press</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">switch</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using generics.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactory</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>: Button;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">C</span>: Checkbox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::B;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using Box pointer.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactoryDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Checkbox&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>macos-gui: One family of products<br>file: macos-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
<li>windows-gui: Another family of products<br>file: windows-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Static-dispatch-静态调度"><a href="#Static-dispatch-静态调度" class="headerlink" title="Static dispatch 静态调度"></a>Static dispatch 静态调度</h4><p>Here, the abstract factory is implemented via generics which lets the compiler create a code that does NOT require dynamic dispatch in runtime.<br>在这里，抽象工厂是通过泛型实现的，它允许编译器创建不需要在运行时动态调度的代码。</p>
<ul>
<li>app: Client code with static dispatch<br>file: app&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> windows &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(WindowsFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(MacFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renders GUI. Factory object must be passed as a parameter to such the</span></span><br><span class="line"><span class="comment">// generic function with factory invocation to utilize static dispatch.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: <span class="keyword">impl</span> <span class="title class_">GuiFactory</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> gui::&#123;Button, Checkbox&#125;;</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Dynamic-dispatch-动态调度"><a href="#Dynamic-dispatch-动态调度" class="headerlink" title="Dynamic dispatch 动态调度"></a>Dynamic dispatch 动态调度</h4><p>If a concrete type of abstract factory is not known at the compilation time, then is should be implemented using Box pointers.<br>如果在编译时不知道抽象工厂的具体类型，则应使用 Box 指针实现。</p>
<ul>
<li>app-dyn: Client code with dynamic dispatch<br>file: app-dyn&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a factory object in runtime depending on unpredictable input.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">factory</span>: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic = <span class="keyword">if</span> windows &#123;</span><br><span class="line">        &amp;WindowsFactory</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &amp;MacFactory</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory invocation can be inlined right here.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    button.<span class="title function_ invoke__">press</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory object can be passed to a function as a parameter.</span></span><br><span class="line">    <span class="title function_ invoke__">render</span>(factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app-dyn&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Renders GUI.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows button has pressed</span><br><span class="line">Windows button has pressed</span><br><span class="line">Windows checkbox has switched</span><br><span class="line">Windows checkbox has switched</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>classification of patterns</title>
    <url>/2023/11/15/design-pattern/classification-of-patterns/</url>
    <content><![CDATA[<h1 id="Classification-of-patterns"><a href="#Classification-of-patterns" class="headerlink" title="Classification of patterns"></a>Classification of patterns</h1><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p>Design patterns differ by their complexity, level of detail and scale of applicability to the entire system being designed. I like the analogy to road construction: you can make an intersection safer by either installing some traffic lights or building an entire multi-level interchange with underground passages for pedestrians.</p>
<p>设计模式的复杂性、详细程度和对整个设计的系统的适用范围各不相同。我喜欢与道路建设的类比：你可以通过安装一些交通信号灯或建造一个完整的多层立交桥和地下通道来使十字路口更安全。</p>
<p>The most basic and low-level patterns are often called idioms. They usually apply only to a single programming language.</p>
<p>最基本和最底层的模式通常被称为成语。它们通常仅适用于一种编程语言。</p>
<p>The most universal and high-level patterns are architectural patterns. Developers can implement these patterns in virtually any language. Unlike other patterns, they can be used to design the architecture of an entire application.</p>
<p>最通用和高级的模式是体系结构模式。开发人员几乎可以用任何语言实现这些模式。与其他模式不同，它们可用于设计整个应用程序的体系结构。</p>
<p>In addition, all patterns can be categorized by their intent, or purpose. This book covers three main groups of patterns:</p>
<p>此外，所有模式都可以按其意图或目的进行分类。本书涵盖三大类模式：</p>
<ul>
<li><p>Creational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.<br>创建模式提供了对象创建机制，可提高现有代码的灵活性和重用性。</p>
</li>
<li><p>Structural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.<br>结构模式解释了如何将对象和类组合成更大的结构，同时保持这些结构的灵活性和效率。</p>
</li>
<li><p>Behavioral patterns take care of effective communication and the assignment of responsibilities between objects.<br>行为模式负责对象之间的有效沟通和责任分配。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Factory Method</title>
    <url>/2023/11/16/design-pattern/factory-method/</url>
    <content><![CDATA[<h1 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h1><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>Also known as: Virtual Constructor<br>也称为： Virtual Constructor</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.</p>
<p>工厂方法是一种创建设计模式，它提供了一个接口，用于在超类中创建对象，但允许子类更改将要创建的对象的类型。<br><img src="/images/factory-method-en.png"></p>
<p>Factory Method pattern</p>
<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the Truck class.<br>假设您正在创建一个物流管理应用程序。应用的第一个版本只能处理卡车运输，因此大部分代码都位于 Truck 类中。</p>
<p>After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.</p>
<p>一段时间后，您的应用程序变得非常受欢迎。每天，您都会收到数十个来自海运公司的请求，要求将海运物流纳入应用程序。</p>
<div align="center"> <img src="/images/problem1-en.png"/> Adding a new class to the program isn’t that simple if the rest of the code is already coupled to existing classes.</br>如果代码的其余部分已经耦合到现有类，则向程序添加新类并不那么简单。 </div>

<p>Great news, right? But how about the code? At present, most of your code is coupled to the <code>Truck</code> class. Adding <code>Ships</code> into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.<br>好消息，对吧？但是代码呢？目前，您的大部分代码都与类 Truck 耦合。添加到 Ships 应用程序中需要对整个代码库进行更改。此外，如果您以后决定向应用程序添加另一种类型的交通工具，您可能需要再次进行所有这些更改。</p>
<p>As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects.<br>结果，你最终会得到非常讨厌的代码，其中充斥着条件，这些条件根据运输对象的类别来切换应用程序的行为。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don’t worry: the objects are still created via the new operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products.<br>工厂方法模式建议将直接对象构造调用（使用运 new 算符）替换为对特殊工厂方法的调用。不用担心：对象仍然是通过运算符 new 创建的，但它是从工厂方法中调用的。工厂方法返回的对象通常称为产品。</p>
<div align="center"> <img src="/images/solution1.png"/> Subclasses can alter the class of objects being returned by the factory method.</br>子类可以更改工厂方法返回的对象的类。</div>

<p>At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.</p>
<p>乍一看，这种变化可能看起来毫无意义：我们只是将构造函数调用从程序的一部分移动到另一部分。但是，请考虑以下情况：现在您可以在子类中重写工厂方法，并更改该方法创建的产品类。</p>
<p>There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.</p>
<p>但是有一个轻微的限制：只有当这些产品具有共同的基类或接口时，子类才能返回不同类型的产品。此外，基类中的工厂方法应将其返回类型声明为此接口。</p>
<p>The structure of the products hierarchy<br>All products must follow the same interface.<br>所有产品必须遵循相同的界面。</p>
<div align="center"> <img src="/images/solution1.png"/>All products must follow the same interface.</br>所有产品必须遵循相同的界面。</div>

<p>For example, both <code>Truck</code> and <code>Ship</code> classes should implement the <code>Transport</code> interface, which declares a method called <code>deliver</code>. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the <code>RoadLogistics</code> class returns truck objects, whereas the factory method in the <code>SeaLogistics</code> class returns ships.<br>例如，和类都应该 <code>Truck</code> 实现接口 <code>Transport</code> ，该接口声明了一个名为 <code>deliver</code> . <code>Ship</code> 每个类别都以不同的方式实现这种方法：卡车通过陆路运送货物，船舶通过海上运送货物。 <code>RoadLogistics</code> 类中的 <code>factory</code> 方法返回 <code>truck</code> 对象，而 <code>SeaLogistics</code> 类中的 <code>factory</code> 方法返回 <code>ships</code>。</p>
<div align="center"> <img src="/images/solution2.png"/>As long as all product classes implement a common interface, you can pass their objects to the client code without breaking it.</br>只要所有产品类都实现一个通用接口，就可以将其对象传递给客户端代码，而不会中断它。</div>

<p>The code that uses the factory method (often called the client code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract <code>Transport</code>. The client knows that all transport objects are supposed to have the <code>deliver</code> method, but exactly how it works isn’t important to the client.<br>使用工厂方法的代码（通常称为客户端代码）看不到各个子类返回的实际产品之间的差异。客户将所有产品视为抽象 <code>Transport</code> 产品。客户端知道所有传输对象都应该具有该 <code>deliver</code> 方法，但其工作方式对客户端来说并不重要。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/structure.png"/></div>

<h4 id="1-Prodcut"><a href="#1-Prodcut" class="headerlink" title="1.Prodcut"></a>1.Prodcut</h4><p>The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.</p>
<p>Product 声明接口，该接口对于创建者及其子类可以生成的所有对象都是通用的。</p>
<h4 id="2-Concrete-Products"><a href="#2-Concrete-Products" class="headerlink" title="2.Concrete Products"></a>2.Concrete Products</h4><p>Concrete Products are different implementations of the product interface.<br>具体产品是产品接口的不同实现。</p>
<h4 id="3-Creator"><a href="#3-Creator" class="headerlink" title="3.Creator"></a>3.Creator</h4><p>The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.</p>
<p>Creator 类声明返回新产品对象的工厂方法。此方法的返回类型必须与产品接口匹配，这一点很重要。</p>
<p>You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.</p>
<p>您可以声明工厂方法，以 abstract 强制所有子类实现其自己的方法版本。或者，基工厂方法可以返回一些默认产品类型。</p>
<p>Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.</p>
<p>请注意，尽管它的名字，产品创建并不是创建者的主要责任。通常，creator 类已经有一些与产品相关的核心业务逻辑。工厂方法有助于将此逻辑与具体的产品类分离。打个比方：一家大型软件开发公司可以有一个程序员培训部门。然而，整个公司的主要职能仍然是编写代码，而不是培养程序员。</p>
<h4 id="4-Concrete-Creators"><a href="#4-Concrete-Creators" class="headerlink" title="4.Concrete Creators"></a>4.Concrete Creators</h4><p>Concrete Creators override the base factory method so it returns a different type of product.<br>Concrete Creators 会重写基本工厂方法，因此它会返回不同类型的产品。</p>
<p>Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.<br>请注意，工厂方法不必一直创建新实例。它还可以从缓存、对象池或其他源返回现有对象。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.</p>
<p>此示例演示如何使用 Factory 方法创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类。</p>
<div align="center"> <img src="/images/example.png"/>The cross-platform dialog example.</br>跨平台对话框示例。</div>

<p>The base <code>Dialog</code> class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.<br>基 <code>Dialog</code> 类使用不同的 UI 元素来呈现其窗口。在各种操作系统下，这些元素可能看起来略有不同，但它们的行为仍应一致。Windows 中的按钮仍然是 Linux 中的按钮。</p>
<p>When the factory method comes into play, you don’t need to rewrite the logic of the <code>Dialog</code> class for each operating system. If we declare a factory method that produces buttons inside the base <code>Dialog</code> class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.<br>当工厂方法发挥作用时，无需为每个操作系统重写 <code>Dialog</code> 类的逻辑。如果我们声明一个在基 <code>Dialog</code> 类中生成按钮的工厂方法，我们稍后可以创建一个子类，该子类从工厂方法返回 Windows 样式的按钮。然后，该子类从基类继承大部分代码，但是，由于工厂方法，可以在屏幕上呈现具有 Windows 外观的按钮。</p>
<p>For this pattern to work, the base <code>Dialog</code> class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within <code>Dialog</code> remains functional, whichever type of buttons it works with.<br>要使此模式起作用，基类必须使用抽象按钮：所有具体按钮都遵循的基 <code>Dialog</code> 类或接口。这样，无论使用哪种类型的按钮，其中 <code>Dialog</code> 的代码都可以正常工作。</p>
<p>Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the <code>Dialog</code>, you get closer to the Abstract Factory pattern. Fear not, we’ll talk about this pattern later.<br>当然，您也可以将此方法应用于其他 UI 元素。但是，随着您添加到 <code>Dialog</code> 的每个新工厂方法，您都更接近抽象工厂模式。不要害怕，我们稍后会讨论这种模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The creator class declares the factory method that must</span></span><br><span class="line"><span class="comment">// return an object of a product class. The creator&#x27;s subclasses</span></span><br><span class="line"><span class="comment">// usually provide the implementation of this method.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    <span class="comment">// The creator may also provide some default implementation</span></span><br><span class="line">    <span class="comment">// of the factory method.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that, despite its name, the creator&#x27;s primary</span></span><br><span class="line">    <span class="comment">// responsibility isn&#x27;t creating products. It usually</span></span><br><span class="line">    <span class="comment">// contains some core business logic that relies on product</span></span><br><span class="line">    <span class="comment">// objects returned by the factory method. Subclasses can</span></span><br><span class="line">    <span class="comment">// indirectly change that business logic by overriding the</span></span><br><span class="line">    <span class="comment">// factory method and returning a different type of product</span></span><br><span class="line">    <span class="comment">// from it.</span></span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Call the factory method to create a product object.</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">        <span class="comment">// Now use the product.</span></span><br><span class="line">        okButton.onClick(closeDialog)</span><br><span class="line">        okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete creators override the factory method to change the</span></span><br><span class="line"><span class="comment">// resulting product&#x27;s type.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The product interface declares the operations that all</span></span><br><span class="line"><span class="comment">// concrete products must implement.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products provide various implementations of the</span></span><br><span class="line"><span class="comment">// product interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a native OS click event.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Return an HTML representation of a button.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a web browser click event.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field dialog: Dialog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The application picks a creator&#x27;s type depending on the</span></span><br><span class="line">    <span class="comment">// current configuration or environment settings.</span></span><br><span class="line">    method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The client code works with an instance of a concrete</span></span><br><span class="line">    <span class="comment">// creator, albeit through its base interface. As long as</span></span><br><span class="line">    <span class="comment">// the client keeps working with the creator via the base</span></span><br><span class="line">    <span class="comment">// interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.initialize()</span><br><span class="line">        dialog.render()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><p><strong>Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.</strong><br><strong>当您事先不知道代码应使用的对象的确切类型和依赖项时，请使用工厂方法。</strong></p>
<p>The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.</p>
<p>Factory 方法将产品构造代码与实际使用产品的代码分开。因此，独立于代码的其余部分扩展产品构造代码更容易。</p>
<p>For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.</p>
<p>例如，要向应用添加新的产品类型，只需创建一个新的创建者子类并重写其中的工厂方法。</p>
<p><strong>Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.</strong><br><strong>如果要为库或框架的用户提供扩展其内部组件的方法，请使用工厂方法。</strong></p>
<p>Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?<br>继承可能是扩展库或框架默认行为的最简单方法。但是，框架如何识别应该使用您的子类而不是标准组件呢？</p>
<p>The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.<br>解决方案是将跨框架构造组件的代码简化为单个工厂方法，并允许任何人在扩展组件本身之外重写此方法。</p>
<p>Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard <code>Button</code> class with a glorious <code>RoundButton</code> subclass. But now you need to tell the main <code>UIFramework</code> class to use the new button subclass instead of a default one.<br>让我们看看这将如何工作。想象一下，你使用开源 UI 框架编写一个应用。你的应用应该有圆形按钮，但框架只提供方形按钮。你用一个光荣的 <code>RoundButton</code> 子类扩展了标准 Button 类。但是现在你需要告诉主 <code>UIFramework</code> 类使用新的按钮子类，而不是默认的子类。</p>
<p>To achieve this, you create a subclass <code>UIWithRoundButtons</code> from a base framework class and override its createButton method. While this method returns <code>Button</code> objects in the base class, you make your subclass return <code>RoundButton</code> objects. Now use the <code>UIWithRoundButtons</code> class instead of <code>UIFramework</code>. And that’s about it!<br>为此，可以从基框架类创建一个子类 <code>UIWithRoundButtons</code> 并重写其 createButton 方法。当此方法返回基类中的对象时，您可以使子类返回 Button <code>RoundButton</code> 对象。现在使用类 <code>UIWithRoundButtons</code> 而不是 <code>UIFramework</code> .仅此而已！</p>
<p><strong>Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.</strong><br><strong>如果要通过重用现有对象而不是每次都重新生成它们来节省系统资源，请使用工厂方法。</strong></p>
<p>You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.<br>在处理大型资源密集型对象（如数据库连接、文件系统和网络资源）时，您经常会遇到这种需求。</p>
<p>Let’s think about what has to be done to reuse an existing object:<br>让我们考虑一下重用现有对象必须做些什么：</p>
<ul>
<li>First, you need to create some storage to keep track of all of the created objects.<br>首先，您需要创建一些存储来跟踪所有创建的对象。</li>
<li>When someone requests an object, the program should look for a free object inside that pool.<br>当有人请求某个对象时，程序应该在该池中查找一个空闲对象。</li>
<li>… and then return it to the client code.<br>…，然后将其返回给客户端代码。</li>
<li>If there are no free objects, the program should create a new one (and add it to the pool).<br>如果没有空闲对象，程序应创建一个新对象（并将其添加到池中）。</li>
</ul>
<p>That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.<br>这是一大堆代码！而且必须将它们全部放在一个地方，这样您就不会用重复的代码污染程序。</p>
<p>Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return <strong>new objects</strong> by definition. It can’t return existing instances.<br>放置此代码的最明显和最方便的位置可能是我们尝试重用其对象的类的构造函数。但是，根据定义，构造函数必须始终返回<strong>new objects</strong>。它无法返回现有实例。</p>
<p>Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.<br>因此，您需要有一个能够创建新对象以及重用现有对象的常规方法。这听起来很像工厂方法。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ul>
<li><p>Make all products follow the same interface. This interface should declare methods that make sense in every product.<br>使所有产品都遵循相同的界面。此接口应声明在每个产品中都有意义的方法。</p>
</li>
<li><p>Add an empty factory method inside the creator class. The return type of the method should match the common product interface.<br>在 creator 类中添加一个空的工厂方法。方法的返回类型应与通用产品接口匹配。</p>
</li>
<li><p>In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.<br>在创建者的代码中，找到对产品构造函数的所有引用。将它们逐个替换为对工厂方法的调用，同时将产品创建代码提取到工厂方法中。</p>
</li>
</ul>
<p>You might need to add a temporary parameter to the factory method to control the type of returned product.<br>您可能需要向工厂方法添加临时参数，以控制返回产品的类型。</p>
<p>At this point, the code of the factory method may look pretty ugly. It may have a large <code>switch</code> statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.<br>在这一点上，工厂方法的代码可能看起来很丑陋。它可能有一个大 <code>switch</code> 语句，用于选择要实例化的产品类。但别担心，我们会尽快修复它。</p>
<ul>
<li><p>Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.<br>现在，为 factory 方法中列出的每种类型的产品创建一组创建者子类。重写子类中的工厂方法，并从基方法中提取适当的构造代码位。</p>
</li>
<li><p>If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.<br>如果产品类型太多，并且为所有产品类型创建子类没有意义，则可以在子类中重用基类中的控制参数。</p>
</li>
</ul>
<p>For instance, imagine that you have the following hierarchy of classes: the base <code>Mail</code> class with a couple of subclasses: <code>AirMail</code> and <code>GroundMail</code>; the <code>Transport</code> classes are <code>Plane</code>, <code>Truck</code> and <code>Train</code>. While the <code>AirMail</code> class only uses <code>Plane</code> objects, <code>GroundMail</code> may work with both <code>Truck</code> and <code>Train</code> objects. You can create a new subclass (say <code>TrainMail</code>) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the <code>GroundMail</code> class to control which product it wants to receive.<br>例如，假设您有以下类层次结构：具有几个子类的基 <code>Mail</code> 类： <code>AirMail</code> 和 <code>GroundMail</code> ; <code>Transport</code> 这些类是 <code>Plane</code>,  <code>Truck</code>和 <code>Train</code> 。虽然该 <code>AirMail</code> 类仅使用 <code>Plane</code> 对象， <code>GroundMail</code> 但可以同时 <code>Truck</code> 使用和 <code>Train</code> 对象。您可以创建一个新的子类（例如 <code>TrainMail</code> ）来处理这两种情况，但还有另一种选择。客户端代码可以将参数传递给 <code>GroundMail</code> 类的工厂方法，以控制它要接收的产品。</p>
<ul>
<li>If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.<br>如果在所有提取之后，基本工厂方法已变为空，则可以将其抽象化。如果还剩下一些东西，可以将其设置为方法的默认行为。</li>
</ul>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h4 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h4><ul>
<li>You avoid tight coupling between the creator and the concrete products.<br>您可以避免创建者和具体产品之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.<br>单一责任原则。您可以将产品创建代码移动到程序中的一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new types of products into the program without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下将新类型的产品引入程序。</li>
</ul>
<h4 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h4><p>The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.<br>代码可能会变得更加复杂，因为您需要引入许多新的子类来实现该模式。最好的情况是将模式引入到创建者类的现有层次结构中。</p>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p>You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.<br>可以将工厂方法与迭代器一起使用，让集合子类返回与集合兼容的不同类型的迭代器。</p>
</li>
<li><p>Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.<br>工厂方法是模板方法的专业化。同时，工厂方法可以作为大型模板方法中的一个步骤。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><ul>
<li><p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Creator class declares the factory method that is supposed to return an</span></span><br><span class="line"><span class="string">    object of a Product class. The Creator&#x27;s subclasses usually provide the</span></span><br><span class="line"><span class="string">    implementation of this method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Note that the Creator may also provide some default implementation of</span></span><br><span class="line"><span class="string">        the factory method.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Also note that, despite its name, the Creator&#x27;s primary responsibility</span></span><br><span class="line"><span class="string">        is not creating products. Usually, it contains some core business logic</span></span><br><span class="line"><span class="string">        that relies on Product objects, returned by the factory method.</span></span><br><span class="line"><span class="string">        Subclasses can indirectly change that business logic by overriding the</span></span><br><span class="line"><span class="string">        factory method and returning a different type of product from it.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call the factory method to create a Product object.</span></span><br><span class="line">        product = self.factory_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now, use the product.</span></span><br><span class="line">        result = <span class="string">f&quot;Creator: The same creator&#x27;s code has just worked with <span class="subst">&#123;product.operation()&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Creators override the factory method in order to change the resulting</span></span><br><span class="line"><span class="string">product&#x27;s type.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator1</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Note that the signature of the method still uses the abstract product type,</span></span><br><span class="line"><span class="string">    even though the concrete product is actually returned from the method. This</span></span><br><span class="line"><span class="string">    way the Creator can stay independent of concrete product classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator2</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Product interface declares the operations that all concrete products</span></span><br><span class="line"><span class="string">    must implement.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products provide various implementations of the Product interface.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct1&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct2&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">creator: Creator</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with an instance of a concrete creator, albeit through</span></span><br><span class="line"><span class="string">    its base interface. As long as the client keeps working with the creator via</span></span><br><span class="line"><span class="string">    the base interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span></span><br><span class="line">          <span class="string">f&quot;<span class="subst">&#123;creator.some_operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator1.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator1())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator2.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator2())</span><br></pre></td></tr></table></figure>
<p><strong>Output.txt: Execution result</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">App: Launched <span class="keyword">with</span> the ConcreteCreator1.</span><br><span class="line">Client: I<span class="string">&#x27;m not aware of the creator&#x27;</span>s <span class="keyword">class</span>, but it still works.</span><br><span class="line">Creator: The same creato<span class="string">r&#x27;s code has just worked with &#123;Result of the ConcreteProduct1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">App: Launched with the ConcreteCreator2.</span></span><br><span class="line"><span class="string">Client: I&#x27;</span>m <span class="keyword">not</span> aware of the creato<span class="string">r&#x27;s class, but it still works.</span></span><br><span class="line"><span class="string">Creator: The same creator&#x27;</span>s code has just worked <span class="keyword">with</span> &#123;Result of the ConcreteProduct2&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Rust<br><strong>gui.rs:Prodcut &amp; Creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Dialog has a factory method `create_button`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It creates different buttons depending on a factory implementation.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line">    <span class="comment">/// The factory method. It must be overridden with a concrete implementation.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">button</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">        button.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">refresh</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dialog - Refresh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html_gui.rs: Concrete creator</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">HtmlButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&lt;button&gt;Test Button&lt;/button&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Button says - &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">HtmlDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates an HTML button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HtmlButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>windows_gui.rs: Another concrete creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">WindowsButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Drawing a Windows button&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Hello, Windows!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">WindowsDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates a Windows button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(WindowsButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>init.rs: Initialization code</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::Dialog;</span><br><span class="line"><span class="keyword">use</span> crate::html_gui::HtmlDialog;</span><br><span class="line"><span class="keyword">use</span> crate::windows_gui::WindowsDialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">dyn</span> Dialog &#123;</span><br><span class="line">    <span class="comment">// The dialog type is selected depending on the environment settings or configuration.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cfg!</span>(windows) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- Windows detected, creating Windows GUI --&quot;</span>);</span><br><span class="line">        &amp;WindowsDialog</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- No OS detected, creating the HTML GUI --&quot;</span>);</span><br><span class="line">        &amp;HtmlDialog</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.rs: Client code main.rs</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> gui;</span><br><span class="line"><span class="keyword">mod</span> html_gui;</span><br><span class="line"><span class="keyword">mod</span> init;</span><br><span class="line"><span class="keyword">mod</span> windows_gui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> init::initialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The rest of the code doesn&#x27;t depend on specific dialog types, because</span></span><br><span class="line">    <span class="comment">// it works with all dialog objects via the abstract `Dialog` trait</span></span><br><span class="line">    <span class="comment">// which is defined in the `gui` module.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dialog</span> = <span class="title function_ invoke__">initialize</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">refresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Output</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;Test Button&lt;/button&gt;</span><br><span class="line">Click! Button says - <span class="symbol">&#x27;Hello</span> World!&#x27;</span><br><span class="line">Dialog - Refresh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>History of patterns</title>
    <url>/2023/11/14/design-pattern/history-of-patterns/</url>
    <content><![CDATA[<h1 id="History-of-patterns"><a href="#History-of-patterns" class="headerlink" title="History of patterns"></a>History of patterns</h1><h1 id="模式的历史"><a href="#模式的历史" class="headerlink" title="模式的历史"></a>模式的历史</h1><p>Who invented patterns? That’s a good, but not a very accurate, question. Design patterns aren’t obscure, sophisticated concepts—quite the opposite. Patterns are typical solutions to common problems in object-oriented design. When a solution gets repeated over and over in various projects, someone eventually puts a name to it and describes the solution in detail. That’s basically how a pattern gets discovered.<br>谁发明了模式？这是一个很好的问题，但不是很准确。设计模式不是晦涩难懂的复杂概念，恰恰相反。模式是面向对象设计中常见问题的典型解决方案。当一个解决方案在各种项目中一遍又一遍地重复时，最终会有人给它起一个名字并详细描述该解决方案。这基本上就是发现模式的方式。</p>
<p>The concept of patterns was first described by Christopher Alexander in A Pattern Language: Towns, Buildings, Construction. The book describes a “language” for designing the urban environment. The units of this language are patterns. They may describe how high windows should be, how many levels a building should have, how large green areas in a neighborhood are supposed to be, and so on.<br>模式的概念最早由克里斯托弗·亚历山大（Christopher Alexander）在《模式语言：城镇、建筑、建筑》中描述。该书描述了一种设计城市环境的“语言”。这种语言的单位是模式。它们可能会描述窗户应该有多高，建筑物应该有多少层，社区中的绿地应该有多大，等等。</p>
<p>The idea was picked up by four authors: Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm. In 1994, they published Design Patterns: Elements of Reusable Object-Oriented Software, in which they applied the concept of design patterns to programming. The book featured 23 patterns solving various problems of object-oriented design and became a best-seller very quickly. Due to its lengthy name, people started to call it “the book by the gang of four” which was soon shortened to simply “the GoF book”.<br>这个想法被四位作者采纳：Erich Gamma、John Vlissides、Ralph Johnson 和 Richard Helm。1994 年，他们出版了《设计模式：可重用面向对象软件的元素》，其中他们将设计模式的概念应用于编程。该书收录了 23 种模式，解决了面向对象设计的各种问题，并很快成为畅销书。由于名字很长，人们开始称它为“四人团的书”，很快就简称为《The GoF book》。</p>
<p>Since then, dozens of other object-oriented patterns have been discovered. The “pattern approach” became very popular in other programming fields, so lots of other patterns now exist outside of object-oriented design as well.<br>从那时起，已经发现了许多其他面向对象的模式。“模式方法”在其他编程领域变得非常流行，因此在面向对象设计之外也存在许多其他模式。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Builder</title>
    <url>/2023/11/21/design-pattern/builder/</url>
    <content><![CDATA[<h1 id="Builder-建造者"><a href="#Builder-建造者" class="headerlink" title="Builder 建造者"></a>Builder 建造者</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Builder</strong> is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.<br><strong>Builder</strong> 是一种创建性设计模式，可让您逐步构建复杂的对象。该模式允许您使用相同的构造代码生成对象的不同类型和表示形式。</p>
<div align="center"> <img src="/images/builder-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.<br>想象一个复杂的对象，需要费力地逐步初始化许多字段和嵌套对象。这种初始化代码通常隐藏在具有大量参数的可怕构造函数中。或者更糟糕的是：分散在客户端代码中。</p>
<div align="center"> <img src="/images/builder-problem1.png"/>You might make the program too complex by creating a subclass for every possible configuration of an object.</通过为对象的每个可能配置创建一个子类，可能会使程序过于复杂。></div>

<p>For example, let’s think about how to create a <code>House</code> object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?<br>例如，让我们考虑如何创建一个 <code>House</code> 对象。要建造一个简单的房子，你需要建造四面墙和一个地板，安装一扇门，安装一对窗户，并建造一个屋顶。但是，如果您想要一个更大、更明亮的房子，有后院和其他好东西（如供暖系统、管道和电线）怎么办？</p>
<p>The simplest solution is to extend the base <code>House</code> class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.<br>最简单的解决方案是扩展基 <code>House</code> 类并创建一组子类以涵盖参数的所有组合。但最终你会得到相当多的子类。任何新参数（例如门廊样式）都需要进一步扩展此层次结构。</p>
<p>There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base <code>House</code> class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.<br>还有另一种方法不涉及育种子类。您可以直接在基 <code>House</code> 类中创建一个巨大的构造函数，其中包含控制 house 对象的所有可能参数。虽然这种方法确实消除了对子类的需求，但它产生了另一个问题。</p>
<div align="center"> <img src="/images/builder-problem2.png"/>The constructor with lots of parameters has its downside: not all the parameters are needed at all times.</br>具有大量参数的构造函数有其缺点：并非所有参数都是必需的。</div>

<p>In most cases most of the parameters will be unused, making <strong>the constructor calls pretty ugly</strong>. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.<br>在大多数情况下，大多数参数将处于未使用状态，这使得构造函数调用非常丑陋。例如，只有一小部分房屋有游泳池，因此与游泳池相关的参数十有八九将毫无用处。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called builders.<br>Builder 模式建议您将对象构造代码从其自己的类中提取出来，并将其移动到称为生成器的单独对象中。</p>
<div align="center"> <img src="/images/builder-solution1.png"/>The Builder pattern lets you construct complex objects step by step. The Builder doesn’t allow other objects to access the product while it’s being built.</br>Builder 模式允许您逐步构建复杂的对象。Builder 不允许其他对象在构建产品时访问产品。</div>

<p>The pattern organizes object construction into a set of steps (<code>buildWalls</code>, <code>buildDoor</code>, etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.<br>该模式将对象构造组织为一组步骤（<code>buildWalls</code>, <code>buildDoor</code> 等）。要创建对象，请在生成器对象上执行一系列这些步骤。重要的是，您不需要调用所有步骤。您只能调用生成对象的特定配置所需的那些步骤。</p>
<p>Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.<br>当您需要构建产品的各种表示形式时，某些构造步骤可能需要不同的实现。例如，小屋的墙壁可以用木头建造，但城堡的墙壁必须用石头建造。</p>
<p>In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.<br>在这种情况下，您可以创建多个不同的生成器类，这些类以不同的方式实现同一组生成步骤。然后，您可以在构造过程中使用这些构建器（即，对构建步骤的一组有序调用）来生成不同类型的对象。</p>
<div align="center"> <img src="/images/builder-comic-1-en.png"/>Different builders execute the same task in various ways.</br>不同的构建器以不同的方式执行相同的任务。</div>

<p>For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.<br>例如，想象一个建筑商用木头和玻璃建造所有东西，第二个建筑商用石头和铁建造所有东西，第三个建筑商使用黄金和钻石建造所有东西。通过调用相同的步骤，您可以从第一个建筑商那里获得普通房屋，从第二个建造者那里获得一座小城堡，从第三个建造者那里获得一座宫殿。但是，仅当调用生成步骤的客户端代码能够使用通用接口与构建器交互时，这才有效。</p>
<h2 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h2><p>You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.<br>您可以更进一步，将对用于将产品构造到称为 director 的单独类的构建器步骤的一系列调用中提取出来。director 类定义执行生成步骤的顺序，而生成器则提供这些步骤的实现。</p>
<div align="center"> <img src="/images/builder-comic-2-en.png"/>The director knows which building steps to execute to get a working product.</br>主管知道要执行哪些构建步骤才能获得工作产品。</div>

<p>Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.<br>在您的课程中开设director类并不是绝对必要的。您始终可以直接从客户端代码按特定顺序调用生成步骤。但是，director 类可能是放置各种构造例程的好地方，以便您可以在程序中重用它们。</p>
<p>In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.<br>此外，director 类在客户端代码中完全隐藏了产品构造的细节。客户端只需将构建器与控制器关联，与控制器一起启动构造，并从构建器获取结果。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/builder-structure.png"/></div>

<ol>
<li><p>The <strong>Builder</strong> interface declares product construction steps that are common to all types of builders.<br>Builder 界面声明了所有类型的构建器通用的产品构建步</p>
</li>
<li><p><strong>Concrete</strong> Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.<br>混凝土建造者提供施工步骤的不同实施。混凝土建筑商可能会生产不遵循通用接口的产品。</p>
</li>
<li><p><strong>Products</strong> are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.<br>产品是结果对象。由不同构建器构建的产品不必属于相同的类层次结构或接口。</p>
</li>
<li><p>The <strong>Director</strong> class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.<br>Director 类定义调用构造步骤的顺序，以便您可以创建和重用产品的特定配置。</p>
</li>
<li><p>The <strong>Client</strong> must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.<br>客户端必须将其中一个构建器对象与控制器相关联。通常，它只通过控制器构造函数的参数完成一次。然后，director 使用该构建器对象进行所有进一步的构造。但是，当客户端将生成器对象传递给控制器的生产方法时，还有另一种方法。在这种情况下，每次与director一起制作内容时，都可以使用不同的构建器。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example of the <strong>Builder</strong> pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them.<br>此 Builder 模式示例说明了如何在构建不同类型的产品（如汽车）时重用相同的对象构造代码，并为它们创建相应的手册。</p>
<div align="center"> <img src="/images/builder-example-en.png"/>The example of step-by-step construction of cars and the user guides that fit those car models.</br>汽车的分步构造示例以及适合这些汽车型号的用户指南。</div>

<p>A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the <code>Car</code> class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.<br>汽车是一个复杂的物体，可以用一百种不同的方式建造。我们没有使用庞大的构造函数来膨胀类 <code>Car</code> ，而是将汽车装配代码提取到一个单独的 car builder 类中。此类具有一组用于配置汽车各个部分的方法。</p>
<p>If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.<br>如果客户端代码需要组装一个特殊的、微调的汽车模型，它可以直接与构建器一起使用。另一方面，客户端可以将程序集委托给 director 类，该类知道如何使用构建器来构造几种最流行的汽车模型。</p>
<p>You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That’s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn’t the same as building a car, and that’s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.<br>您可能会感到震惊，但每辆车都需要一本手册（说真的，谁会读它们？手册描述了汽车的每个功能，因此手册中的细节因不同车型而异。这就是为什么在真实汽车及其各自的手册中重复使用现有的制造过程是有意义的。当然，构建手册与构建汽车不同，这就是为什么我们必须提供另一个专门编写手册的构建者类。该类实现了与其汽车制造同级相同的构建方法，但不是制作汽车零件，而是描述它们。通过将这些构建器传递给同一个 director 对象，我们可以构造汽车或手册。</p>
<p>The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can’t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.<br>最后一部分是获取生成的对象。金属汽车和纸质手册虽然相关，但仍然是非常不同的东西。如果不将控制器与具体的产品类耦合，我们就无法在控制器中放置获取结果的方法。因此，我们从执行工作的建筑商那里获得施工结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the Builder pattern makes sense only when your products</span></span><br><span class="line"><span class="comment">// are quite complex and require extensive configuration. The</span></span><br><span class="line"><span class="comment">// following two products are related, although they don&#x27;t have</span></span><br><span class="line"><span class="comment">// a common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line">    <span class="comment">// A car can have a GPS, trip computer and some number of</span></span><br><span class="line">    <span class="comment">// seats. Different models of cars (sports car, SUV,</span></span><br><span class="line">    <span class="comment">// cabriolet) might have different features installed or</span></span><br><span class="line">    <span class="comment">// enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">    <span class="comment">// Each car should have a user manual that corresponds to</span></span><br><span class="line">    <span class="comment">// the car&#x27;s configuration and describes all its features.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The builder interface specifies methods for creating the</span></span><br><span class="line"><span class="comment">// different parts of the product objects.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete builder classes follow the builder interface and</span></span><br><span class="line"><span class="comment">// provide specific implementations of the building steps. Your</span></span><br><span class="line"><span class="comment">// program may have several variations of builders, each</span></span><br><span class="line"><span class="comment">// implemented differently.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field car:Car</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A fresh builder instance should contain a blank product</span></span><br><span class="line">    <span class="comment">// object which it uses in further assembly.</span></span><br><span class="line">    constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The reset method clears the object being built.</span></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All production steps work with the same product instance.</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Set the number of seats in the car.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a given engine.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a trip computer.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a global positioning system.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete builders are supposed to provide their own</span></span><br><span class="line">    <span class="comment">// methods for retrieving results. That&#x27;s because various</span></span><br><span class="line">    <span class="comment">// types of builders may create entirely different products</span></span><br><span class="line">    <span class="comment">// that don&#x27;t all follow the same interface. Therefore such</span></span><br><span class="line">    <span class="comment">// methods can&#x27;t be declared in the builder interface (at</span></span><br><span class="line">    <span class="comment">// least not in a statically-typed programming language).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Usually, after returning the end result to the client, a</span></span><br><span class="line">    <span class="comment">// builder instance is expected to be ready to start</span></span><br><span class="line">    <span class="comment">// producing another product. That&#x27;s why it&#x27;s a usual</span></span><br><span class="line">    <span class="comment">// practice to call the reset method at the end of the</span></span><br><span class="line">    <span class="comment">// `getProduct` method body. However, this behavior isn&#x27;t</span></span><br><span class="line">    <span class="comment">// mandatory, and you can make your builder wait for an</span></span><br><span class="line">    <span class="comment">// explicit reset call from the client code before disposing</span></span><br><span class="line">    <span class="comment">// of the previous result.</span></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">        <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlike other creational patterns, builder lets you construct</span></span><br><span class="line"><span class="comment">// products that don&#x27;t follow the common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field manual:Manual</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Document car seat features.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add engine instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add trip computer instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add GPS instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">        <span class="comment">// Return the manual and reset the builder.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The director is only responsible for executing the building</span></span><br><span class="line"><span class="comment">// steps in a particular sequence. It&#x27;s helpful when producing</span></span><br><span class="line"><span class="comment">// products according to a specific order or configuration.</span></span><br><span class="line"><span class="comment">// Strictly speaking, the director class is optional, since the</span></span><br><span class="line"><span class="comment">// client can control builders directly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">    <span class="comment">// The director works with any builder instance that the</span></span><br><span class="line">    <span class="comment">// client code passes to it. This way, the client code may</span></span><br><span class="line">    <span class="comment">// alter the final type of the newly assembled product.</span></span><br><span class="line">    <span class="comment">// The director can construct several product variations</span></span><br><span class="line">    <span class="comment">// using the same building steps.</span></span><br><span class="line">    method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        builder.reset()</span><br><span class="line">        builder.setSeats(<span class="number">2</span>)</span><br><span class="line">        builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">        builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">        builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code creates a builder object, passes it to the</span></span><br><span class="line"><span class="comment">// director and then initiates the construction process. The end</span></span><br><span class="line"><span class="comment">// result is retrieved from the builder object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The final product is often retrieved from a builder</span></span><br><span class="line">        <span class="comment">// object since the director isn&#x27;t aware of and not</span></span><br><span class="line">        <span class="comment">// dependent on concrete builders and products.</span></span><br><span class="line">        <span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Builder pattern to get rid of a “telescoping constructor”. 使用 Builder 模式来摆脱“伸缩构造函数”。</strong></p>
</li>
<li><p>Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.<br>假设您有一个包含十个可选参数的构造函数。召唤这样的野兽是很不方便的;因此，重载构造函数，并使用较少的参数创建多个较短的版本。这些构造函数仍然引用主构造函数，将一些默认值传递到任何省略的参数中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    Pizza(<span class="type">int</span> size) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese, <span class="type">boolean</span> pepperoni) &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>Creating such a monster is only possible in languages that support method overloading, such as C# or Java.只有在支持方法重载的语言（如 C# 或 Java）中才能创建这样的怪物。</p>
<p>The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.<br>Builder 模式允许您逐步构建对象，仅使用您真正需要的那些步骤。实现该模式后，您不必再将数十个参数塞入构造函数中。</p>
<ul>
<li><p><strong>Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).当您希望代码能够创建某些产品（例如，石头和木屋）的不同表示形式时，请使用 Builder 模式。</strong></p>
</li>
<li><p>The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.<br>当构建产品的各种表示形式涉及仅在细节上有所不同的类似步骤时，可以应用构建器模式。</p>
</li>
</ul>
<p>The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.<br>基础构建器界面定义了所有可能的构建步骤，具体构建器实现这些步骤来构建产品的特定表示。同时，director类指导施工顺序。</p>
<ul>
<li><p><strong>Use the Builder to construct Composite trees or other complex objects.使用构建器构建复合树或其他复杂对象。</strong></p>
</li>
<li><p>The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.<br>Builder 模式允许您逐步构建产品。您可以在不破坏最终产品的情况下延迟某些步骤的执行。您甚至可以递归调用步骤，这在需要构建对象树时会派上用场。</p>
</li>
</ul>
<p>A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.<br>构建器在运行构造步骤时不会暴露未完成的产品。这样可以防止客户端代码提取不完整的结果。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.<br>确保您可以清楚地定义用于构建所有可用产品表示的常见构造步骤。否则，您将无法继续实现该模式。</p>
</li>
<li><p>Declare these steps in the base builder interface.<br>在基础构建器界面中声明这些步骤。</p>
</li>
<li><p>Create a concrete builder class for each of the product representations and implement their construction steps.<br>为每个产品表示形式创建一个具体的构建器类，并实现其构造步骤。</p>
</li>
</ol>
<p>Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.<br>不要忘记实现一个获取构造结果的方法。无法在生成器接口中声明此方法的原因是，各种生成器可能会构造没有通用接口的产品。因此，您不知道这种方法的返回类型是什么。但是，如果您要处理来自单个层次结构的产品，则可以安全地将提取方法添加到基本界面。</p>
<ol start="4">
<li><p>Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.<br>考虑创建一个director类。它可以封装使用相同的构建器对象构建产品的各种方法。</p>
</li>
<li><p>The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.<br>客户端代码创建生成器和控制器对象。在构造开始之前，客户端必须将生成器对象传递给控制器。通常，客户端仅通过 director 类构造函数的参数执行此操作一次。director 在所有进一步的构造中使用 builder 对象。还有另一种方法，将构建器传递给主管的特定产品构建方法。</p>
</li>
<li><p>The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.<br>只有当所有产品都遵循相同的接口时，才能直接从director那里获得施工结果。否则，客户端应从构建器获取结果。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li><p>You can construct objects step-by-step, defer construction steps or run steps recursively.<br>您可以逐步构造对象、延迟构造步骤或递归运行步骤。</p>
</li>
<li><p>You can reuse the same construction code when building various representations of products.<br>在构建产品的各种表示形式时，您可以重复使用相同的构造代码。</p>
</li>
<li><p>Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.<br>单一责任原则。您可以将复杂的构造代码与产品的业务逻辑隔离开来。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>The overall complexity of the code increases since the pattern requires creating multiple new classes.<br>代码的整体复杂性增加，因为该模式需要创建多个新类。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using **Factory Method **(less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step. <strong>Abstract Factory</strong> specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p>You can use <strong>Builder</strong> when creating complex <strong>Composite</strong> trees because you can program its construction steps to work recursively.<br>在创建复杂的复合树时，可以使用 Builder，因为您可以对其构造步骤进行编程以递归方式工作。</p>
</li>
<li><p>You can combine <strong>Builder</strong> with <strong>Bridge</strong>: the director class plays the role of the abstraction, while different builders act as implementations.<br>您可以将 Builder 与 Bridge 结合使用：director 类扮演抽象的角色，而不同的构建器充当实现。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="python-Conceptual-Example-概念示例"><a href="#python-Conceptual-Example-概念示例" class="headerlink" title="python Conceptual Example 概念示例"></a>python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Builder design pattern. It focuses on answering these questions:<br>此示例说明了 Builder 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<p>main.py: 概念示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Builder interface specifies methods for creating the different parts of</span></span><br><span class="line"><span class="string">    the Product objects.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span>(<span class="title class_ inherited__">Builder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Concrete Builder classes follow the Builder interface and provide</span></span><br><span class="line"><span class="string">    specific implementations of the building steps. Your program may have</span></span><br><span class="line"><span class="string">    several variations of Builders, implemented differently.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A fresh builder instance should contain a blank product object, which is</span></span><br><span class="line"><span class="string">        used in further assembly.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product = Product1()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; Product1:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Concrete Builders are supposed to provide their own methods for</span></span><br><span class="line"><span class="string">        retrieving results. That&#x27;s because various types of builders may create</span></span><br><span class="line"><span class="string">        entirely different products that don&#x27;t follow the same interface.</span></span><br><span class="line"><span class="string">        Therefore, such methods cannot be declared in the base Builder interface</span></span><br><span class="line"><span class="string">        (at least in a statically typed programming language).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Usually, after returning the end result to the client, a builder</span></span><br><span class="line"><span class="string">        instance is expected to be ready to start producing another product.</span></span><br><span class="line"><span class="string">        That&#x27;s why it&#x27;s a usual practice to call the reset method at the end of</span></span><br><span class="line"><span class="string">        the `getProduct` method body. However, this behavior is not mandatory,</span></span><br><span class="line"><span class="string">        and you can make your builders wait for an explicit reset call from the</span></span><br><span class="line"><span class="string">        client code before disposing of the previous result.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        product = self._product</span><br><span class="line">        self.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartA1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartB1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartC1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    It makes sense to use the Builder pattern only when your products are quite</span></span><br><span class="line"><span class="string">    complex and require extensive configuration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Unlike in other creational patterns, different concrete builders can produce</span></span><br><span class="line"><span class="string">    unrelated products. In other words, results of various builders may not</span></span><br><span class="line"><span class="string">    always follow the same interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, part: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts.append(part)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_parts</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Product parts: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(self.parts)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director is only responsible for executing the building steps in a</span></span><br><span class="line"><span class="string">    particular sequence. It is helpful when producing products according to a</span></span><br><span class="line"><span class="string">    specific order or configuration. Strictly speaking, the Director class is</span></span><br><span class="line"><span class="string">    optional, since the client can control builders directly.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._builder = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self</span>) -&gt; Builder:</span><br><span class="line">        <span class="keyword">return</span> self._builder</span><br><span class="line"></span><br><span class="line"><span class="meta">    @builder.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self, builder: Builder</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Director works with any builder instance that the client code passes</span></span><br><span class="line"><span class="string">        to it. This way, the client code may alter the final type of the newly</span></span><br><span class="line"><span class="string">        assembled product.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director can construct several product variations using the same</span></span><br><span class="line"><span class="string">    building steps.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_minimal_viable_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_full_featured_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line">        self.builder.produce_part_b()</span><br><span class="line">        self.builder.produce_part_c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code creates a builder object, passes it to the director and then</span></span><br><span class="line"><span class="string">    initiates the construction process. The end result is retrieved from the</span></span><br><span class="line"><span class="string">    builder object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    director = Director()</span><br><span class="line">    builder = ConcreteBuilder1()</span><br><span class="line">    director.builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard basic product: &quot;</span>)</span><br><span class="line">    director.build_minimal_viable_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard full featured product: &quot;</span>)</span><br><span class="line">    director.build_full_featured_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remember, the Builder pattern can be used without a Director class.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Custom product: &quot;</span>)</span><br><span class="line">    builder.produce_part_a()</span><br><span class="line">    builder.produce_part_b()</span><br><span class="line">    builder.product.list_parts()</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Standard basic product:</span><br><span class="line">Product parts: PartA1</span><br><span class="line"></span><br><span class="line">Standard full featured product:</span><br><span class="line">Product parts: PartA1, PartB1, PartC1</span><br><span class="line"></span><br><span class="line">Custom product:</span><br><span class="line">Product parts: PartA1, PartB1</span><br></pre></td></tr></table></figure>

<h3 id="Rust-示例：Car-car-manual-builders"><a href="#Rust-示例：Car-car-manual-builders" class="headerlink" title="Rust 示例：Car &amp; car manual builders"></a>Rust 示例：Car &amp; car manual builders</h3><p>This slightly synthetic example illustrates how you can use the <code>Builder</code> pattern to construct totally different products using the same building process. For example, the trait Builder declares steps for assembling a car. However, depending on the builder implementation, a constructed object can be something different, for example, a car manual. The resulting manual will contain instructions from each building step, making it accurate and up-to-date.<br>这个略微合成的示例说明了如何使用 Builder 模式，通过相同的构建过程来构建完全不同的产品。例如，该特征 <code>Builder</code> 声明了组装汽车的步骤。但是，根据构建器实现的不同，构造的对象可以是不同的对象，例如汽车手册。由此产生的手册将包含每个构建步骤的说明，使其准确和最新。</p>
<p>The <strong>Builder</strong> design pattern is not the same as the <strong>Fluent Interface</strong> idiom (that relies on method chaining), although Rust developers sometimes use those terms interchangeably.<br>Builder 设计模式与 Fluent Interface 习惯用语（依赖于方法链）不同，尽管 Rust 开发人员有时会互换使用这些术语。</p>
<ol>
<li><p>Fluent Interface is a way to chain methods for constructing or modifying an object using the following approach:<br>Fluent Interface 是一种使用以下方法链接用于构造或修改对象的方法的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">car</span> = Car::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">places</span>(<span class="number">5</span>).<span class="title function_ invoke__">gas</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>It’s pretty elegant way to construct an object. Still, such a code may not be an instance of the Builder pattern.<br>这是构造对象的非常优雅的方式。不过，这样的代码可能不是 Builder 模式的实例。</p>
</li>
<li><p>While the <strong>Builder</strong> pattern also suggests constructing object step by step, it also lets you build different types of products using the same construction process.<br>虽然 <strong>Builder</strong> 模式还建议逐步构建对象，但它也允许您使用相同的构建过程构建不同类型的产品。</p>
</li>
</ol>
<h3 id="builders-Builders-builders"><a href="#builders-Builders-builders" class="headerlink" title="builders: Builders builders"></a>builders: Builders builders</h3><h4 id="builders-mod-rs"><a href="#builders-mod-rs" class="headerlink" title="builders&#x2F;mod.rs"></a>builders&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> car_manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builder defines how to assemble a car.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::OutputType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::CarBuilder;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car_manual::CarManualBuilder;</span><br></pre></td></tr></table></figure>
<h4 id="builders-car-rs"><a href="#builders-car-rs" class="headerlink" title="builders&#x2F;car.rs"></a>builders&#x2F;car.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Car,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT_FUEL: <span class="type">f64</span> = <span class="number">5f64</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Car;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Car &#123;</span><br><span class="line">        Car::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">            DEFAULT_FUEL,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="builders-car-manual-rs"><a href="#builders-car-manual-rs" class="headerlink" title="builders&#x2F;car_manual.rs"></a>builders&#x2F;car_manual.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Manual,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builds a car manual instead of an actual car.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Manual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Manual &#123;</span><br><span class="line">        Manual::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cars-Products"><a href="#cars-Products" class="headerlink" title="cars: Products"></a>cars: Products</h4><h5 id="cars-mod-rs"><a href="#cars-mod-rs" class="headerlink" title="cars&#x2F;mod.rs"></a>cars&#x2F;mod.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::Car;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> manual::Manual;</span><br></pre></td></tr></table></figure>

<h5 id="cars-car-rs"><a href="#cars-car-rs" class="headerlink" title="cars&#x2F;car.rs"></a>cars&#x2F;car.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    fuel: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">        fuel: <span class="type">f64</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">            fuel,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">car_type</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> CarType &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fuel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_fuel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fuel: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel = fuel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">seats</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">engine</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Engine &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.engine</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transmission</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Transmission &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.transmission</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">gps_navigator</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">Option</span>&lt;GpsNavigator&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.gps_navigator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cars-manual-rs"><a href="#cars-manual-rs" class="headerlink" title="cars&#x2F;manual.rs"></a>cars&#x2F;manual.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Type of car: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.car_type)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Count of seats: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.seats)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;Engine: volume - &#123;&#125;; mileage - &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">volume</span>(),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">mileage</span>()</span><br><span class="line">        )?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Transmission: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.transmission)?;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.gps_navigator &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: Functional&quot;</span>)?,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: N/A&quot;</span>)?,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="components-rs-Product-components"><a href="#components-rs-Product-components" class="headerlink" title="components.rs: Product components"></a>components.rs: Product components</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">CarType</span> &#123;</span><br><span class="line">    CityCar,</span><br><span class="line">    SportsCar,</span><br><span class="line">    Suv,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Transmission</span> &#123;</span><br><span class="line">    SingleSpeed,</span><br><span class="line">    Manual,</span><br><span class="line">    Automatic,</span><br><span class="line">    SemiAutomatic,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    volume: <span class="type">f64</span>,</span><br><span class="line">    mileage: <span class="type">f64</span>,</span><br><span class="line">    started: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(volume: <span class="type">f64</span>, mileage: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            volume,</span><br><span class="line">            mileage,</span><br><span class="line">            started: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">on</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">off</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">started</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.started</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mileage</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.mileage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">go</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mileage: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">started</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.mileage += mileage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cannot go(), you must start engine first!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    route: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">from_route</span>(</span><br><span class="line">            <span class="string">&quot;221b, Baker Street, London  to Scotland Yard, 8-10 Broadway, London&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_route</span>(route: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; route &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.route</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="director-rs-Directors"><a href="#director-rs-Directors" class="headerlink" title="director.rs: Directors"></a>director.rs: Directors</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    builders::Builder,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Director knows how to build a car.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// However, a builder can build a car manual instead of an actual car,</span></span><br><span class="line"><span class="comment">/// everything depends on the concrete builder.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Director</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_sports_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::SportsCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::SemiAutomatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_city_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::CityCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">1.2</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Automatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_suv</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::Suv);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">4</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">2.5</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Manual);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main-rs-Client-code"><a href="#main-rs-Client-code" class="headerlink" title="main.rs: Client code"></a>main.rs: Client code</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> builders;</span><br><span class="line"><span class="keyword">mod</span> cars;</span><br><span class="line"><span class="keyword">mod</span> components;</span><br><span class="line"><span class="keyword">mod</span> director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> builders::&#123;Builder, CarBuilder, CarManualBuilder&#125;;</span><br><span class="line"><span class="keyword">use</span> cars::&#123;Car, Manual&#125;;</span><br><span class="line"><span class="keyword">use</span> director::Director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">car_builder</span> = CarBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director gets the concrete builder object from the client</span></span><br><span class="line">    <span class="comment">// (application code). That&#x27;s because application knows better which</span></span><br><span class="line">    <span class="comment">// builder to use to get a specific product.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_sports_car</span>(&amp;<span class="keyword">mut</span> car_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final product is often retrieved from a builder object, since</span></span><br><span class="line">    <span class="comment">// Director is not aware and not dependent on concrete builders and</span></span><br><span class="line">    <span class="comment">// products.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">car</span>: Car = car_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car built: &#123;:?&#125;\n&quot;</span>, car.<span class="title function_ invoke__">car_type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">manual_builder</span> = CarManualBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director may know several building recipes.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_city_car</span>(&amp;<span class="keyword">mut</span> manual_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final car manual.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manual</span>: Manual = manual_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car manual built:\n&#123;&#125;&quot;</span>, manual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Car built: SportsCar</span><br><span class="line"></span><br><span class="line">Car manual built:</span><br><span class="line">Type of car: CityCar</span><br><span class="line">Count of seats: 2</span><br><span class="line">Engine: volume - 1.2; mileage - 0</span><br><span class="line">Transmission: Automatic</span><br><span class="line">GPS Navigator: Functional</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Prototype</title>
    <url>/2023/11/22/design-pattern/prototype/</url>
    <content><![CDATA[<h1 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype 原型"></a>Prototype 原型</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Prototype</strong> is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.<br>原型是一种创建性设计模式，它允许您复制现有对象，而不会使代码依赖于它们的类。</p>
<div align="center"> <img src="/images/prototype-head.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.<br>假设你有一个对象，并且你想创建一个精确的副本。你会怎么做？首先，您必须创建同一类的新对象。然后，您必须遍历原始对象的所有字段，并将其值复制到新对象。</p>
<p>Nice! But there’s a catch. Not all objects can be copied that way because some of the object’s fields may be private and not visible from outside of the object itself.<br>好！但有一个问题。并非所有对象都可以以这种方式复制，因为对象的某些字段可能是私有的，并且从对象本身外部不可见。</p>
<div align="center"> <img src="/images/prototype-comic-1-en.png"/>Copying an object “from the outside” isn’t always possible.</br>“从外部”复制对象并不总是可行的。</div>
There’s one more problem with the direct approach. Since you have to know the object’s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn’t scare you, there’s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.
直接方法还有一个问题。由于您必须知道对象的类才能创建副本，因此您的代码将依赖于该类。如果额外的依赖关系没有吓到你，还有另一个问题。有时，您只知道对象所遵循的接口，而不知道其具体类，例如，当方法中的参数接受某个接口所遵循的任何对象时。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single <code>clone</code> method.<br>Prototype 模式将克隆过程委托给正在克隆的实际对象。该模式为支持克隆的所有对象声明一个通用接口。此接口允许您克隆对象，而无需将代码耦合到该对象的类。通常，这样的接口只包含一个 <code>clone</code> 方法。</p>
<p>The implementation of the clone method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.<br>该 <code>clone</code> 方法的实现在所有类中都非常相似。该方法创建当前类的对象，并将旧对象的所有字段值转移到新对象中。您甚至可以复制私有字段，因为大多数编程语言允许对象访问属于同一类的其他对象的私有字段。</p>
<p>An object that supports cloning is called a prototype. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.<br>支持克隆的对象称为原型。当您的对象具有数十个字段和数百种可能的配置时，克隆它们可以作为子类化的替代方法。</p>
<div align="center"> <img src="/images/prototype-comic-2-en.png"/>Pre-built prototypes can be an alternative to subclassing.</br>预构建的原型可以替代子类化。</div>
Here’s how it works: you create a set of objects, configured in various ways. When you need an object like the one you’ve configured, you just clone a prototype instead of constructing a new object from scratch.
它是这样工作的：创建一组对象，以各种方式进行配置。当您需要像您配置的对象一样的对象时，您只需克隆一个原型，而不是从头开始构建一个新对象。

<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don’t participate in any actual production, playing a passive role instead.<br>在现实生活中，原型用于在开始批量生产产品之前进行各种测试。然而，在这种情况下，原型不参与任何实际生产，而是扮演被动角色。</p>
<div align="center"> <img src="/images/prototype-comic-3-en.png"/>The division of a cell.</br>细胞的分裂。</div>
Since industrial prototypes don’t really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.
由于工业原型并不能真正复制自己，因此与该模式更接近的类比是有丝分裂细胞分裂的过程（生物学，还记得吗？有丝分裂后，形成一对相同的细胞。原始单元充当原型，并在创建副本中发挥积极作用。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h3 id="Basic-implementation-基本实现"><a href="#Basic-implementation-基本实现" class="headerlink" title="Basic implementation 基本实现"></a>Basic implementation 基本实现</h3><div align="center"> <img src="/images/prototyp-structure.png"/></div>

<ol>
<li><p>The <strong>Prototype</strong> interface declares the cloning methods. In most cases, it’s a single clone method.<br>Prototype 接口声明克隆方法。在大多数情况下，它是一种单一 clone 方法。</p>
</li>
<li><p>The <code>Concrete Prototype</code> class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.<br>Concrete Prototype 类实现克隆方法。除了将原始对象的数据复制到克隆中外，该方法还可以处理克隆过程中与克隆链接对象、解开递归依赖关系等相关的一些边缘情况。</p>
</li>
<li><p>The <code>Client</code> can produce a copy of any object that follows the prototype interface.<br>客户端可以生成遵循原型接口的任何对象的副本。</p>
</li>
</ol>
<h3 id="Prototype-registry-implementation-原型注册表实现"><a href="#Prototype-registry-implementation-原型注册表实现" class="headerlink" title="Prototype registry implementation 原型注册表实现"></a>Prototype registry implementation 原型注册表实现</h3><div align="center"> <img src="/images/structure-prototype-cache.png"/></div>
1. The `Prototype Registry` provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.
Prototype Registry 提供了一种访问常用原型的简单方法。它存储一组准备复制的预构建对象。最简单的原型注册表是 name → prototype 哈希映射。但是，如果您需要比简单名称更好的搜索条件，则可以构建更可靠的注册表版本。

<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the Prototype pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.<br>在此示例中，Prototype 模式允许您生成几何对象的精确副本，而无需将代码耦合到其类。</p>
<div align="center"> <img src="/images/prototype-example1.png"/>Cloning a set of objects that belong to a class hierarchy.</br>克隆属于类层次结构的一组对象。</div>

<p>All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent’s cloning method before copying its own field values to the resulting object.<br>所有形状类都遵循相同的接口，该接口提供克隆方法。子类可以在将其自己的字段值复制到生成的对象之前调用父类的克隆方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base prototype.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field X: <span class="type">int</span></span><br><span class="line">    field Y: <span class="type">int</span></span><br><span class="line">    field color: string</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A regular constructor.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The prototype constructor. A fresh object is initialized</span></span><br><span class="line">    <span class="comment">// with values from the existing object.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">(source: Shape)</span> is</span><br><span class="line">        <span class="title function_">this</span><span class="params">()</span></span><br><span class="line">        <span class="built_in">this</span>.X = source.X</span><br><span class="line">        <span class="built_in">this</span>.Y = source.Y</span><br><span class="line">        <span class="built_in">this</span>.color = source.color</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The clone operation returns one of the Shape subclasses.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete prototype. The cloning method creates a new object</span></span><br><span class="line"><span class="comment">// in one go by calling the constructor of the current class and</span></span><br><span class="line"><span class="comment">// passing the current object as the constructor&#x27;s argument.</span></span><br><span class="line"><span class="comment">// Performing all the actual copying in the constructor helps to</span></span><br><span class="line"><span class="comment">// keep the result consistent: the constructor will not return a</span></span><br><span class="line"><span class="comment">// result until the new object is fully built; thus, no object</span></span><br><span class="line"><span class="comment">// can have a reference to a partially-built clone.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field width: <span class="type">int</span></span><br><span class="line">    field height: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Rectangle</span><span class="params">(source: Rectangle)</span> is</span><br><span class="line">        <span class="comment">// A parent constructor call is needed to copy private</span></span><br><span class="line">        <span class="comment">// fields defined in the parent class.</span></span><br><span class="line">        <span class="built_in">super</span>(source)</span><br><span class="line">        <span class="built_in">this</span>.width = source.width</span><br><span class="line">        <span class="built_in">this</span>.height = source.height</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field radius: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Circle</span><span class="params">(source: Circle)</span> is</span><br><span class="line">        <span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">        <span class="built_in">this</span>.radius = source.radius</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in the client code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field shapes: array of Shape</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">        circle.X = <span class="number">10</span></span><br><span class="line">        circle.Y = <span class="number">10</span></span><br><span class="line">        circle.radius = <span class="number">20</span></span><br><span class="line">        shapes.add(circle)</span><br><span class="line"></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">anotherCircle</span> <span class="operator">=</span> circle.clone()</span><br><span class="line">        shapes.add(anotherCircle)</span><br><span class="line">        <span class="comment">// The `anotherCircle` variable contains an exact copy</span></span><br><span class="line">        <span class="comment">// of the `circle` object.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>()</span><br><span class="line">        rectangle.width = <span class="number">10</span></span><br><span class="line">        rectangle.height = <span class="number">20</span></span><br><span class="line">        shapes.add(rectangle)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">businessLogic</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Prototype rocks because it lets you produce a copy of</span></span><br><span class="line">        <span class="comment">// an object without knowing anything about its type.</span></span><br><span class="line">        <span class="type">Array</span> <span class="variable">shapesCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span> of Shapes.</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For instance, we don&#x27;t know the exact elements in the</span></span><br><span class="line">        <span class="comment">// shapes array. All we know is that they are all</span></span><br><span class="line">        <span class="comment">// shapes. But thanks to polymorphism, when we call the</span></span><br><span class="line">        <span class="comment">// `clone` method on a shape the program checks its real</span></span><br><span class="line">        <span class="comment">// class and runs the appropriate clone method defined</span></span><br><span class="line">        <span class="comment">// in that class. That&#x27;s why we get proper clones</span></span><br><span class="line">        <span class="comment">// instead of a set of simple Shape objects.</span></span><br><span class="line">        foreach (s in shapes) <span class="keyword">do</span></span><br><span class="line">            shapesCopy.add(s.clone())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The `shapesCopy` array contains exact copies of the</span></span><br><span class="line">        <span class="comment">// `shape` array&#x27;s children.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.当代码不应依赖于需要复制的具体对象类时，请使用 Prototype 模式。</strong></p>
</li>
<li><p>This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.<br>当您的代码使用通过某些接口从第三方代码传递给您的对象时，这种情况经常发生。这些对象的具体类别是未知的，即使你愿意，你也不能依赖它们。</p>
</li>
</ul>
<p>The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.<br>Prototype 模式为客户端代码提供了一个通用接口，用于处理支持克隆的所有对象。此接口使客户端代码独立于它克隆的对象的具体类。</p>
<ul>
<li><p><strong>Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.<br>如果要减少子类的数量，这些子类仅在初始化各自对象的方式上有所不同，请使用该模式。</strong></p>
</li>
<li><p>Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.<br>假设您有一个复杂的类，需要费力的配置才能使用它。有几种常用方法可以配置此类，并且此代码分散在应用中。为了减少重复，您可以创建多个子类，并将每个通用配置代码放入其构造函数中。您解决了重复问题，但现在您有很多虚拟子类。</p>
</li>
</ul>
<p>The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.<br>Prototype模式允许您使用一组以各种方式配置的预构建对象作为原型。客户端可以简单地寻找一个合适的原型并克隆它，而不是实例化一个匹配某些配置的子类。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Create the prototype interface and declare the <code>clone</code> method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.<br>创建原型接口并在其中声明 <code>clone</code> 方法。或者，只需将该方法添加到现有类层次结构的所有类（如果有）。</p>
</li>
<li><p>A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.<br>原型类必须定义接受该类的对象作为参数的替代构造函数。构造函数必须将类中定义的所有字段的值从传递的对象复制到新创建的实例中。如果要更改子类，则必须调用父构造函数，让超类处理其私有字段的克隆。</p>
</li>
</ol>
<p>If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the <code>clone</code> method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the <code>new</code> operator.<br>如果你的编程语言不支持方法重载，你将无法创建单独的“原型”构造函数。因此，必须在 <code>clone</code> 该方法中将对象的数据复制到新创建的克隆中。不过，在常规构造函数中使用此代码更安全，因为在调用 <code>new</code> 运算符后立即返回完全配置的结果对象。</p>
<ol start="3">
<li><p>The cloning method usually consists of just one line: running a <code>new</code> operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the <code>new</code> operator. Otherwise, the cloning method may produce an object of a parent class.<br>克隆方法通常只包含一行：使用构造函数的原型版本运行运 <code>new</code> 算符。请注意，每个类都必须显式覆盖克隆方法，并使用自己的类名和 <code>new</code> 运算符。否则，克隆方法可能会生成父类的对象。</p>
</li>
<li><p>Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.<br>（可选）创建一个集中式原型注册表来存储常用原型的目录。</p>
</li>
</ol>
<p>You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.<br>您可以将注册表实现为新的工厂类，也可以使用用于获取原型的静态方法将其放在基原型类中。此方法应根据客户端代码传递给该方法的搜索条件搜索原型。条件可以是简单的字符串标记，也可以是一组复杂的搜索参数。找到适当的原型后，注册表应克隆它并将副本返回给客户端。</p>
<p>Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.<br>最后，将对子类构造函数的直接调用替换为对原型注册表的工厂方法的调用。</p>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><ul>
<li>You can clone objects without coupling to their concrete classes.<br>您可以克隆对象，而无需耦合到其具体类。</li>
</ul>
<table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can clone objects without coupling to their concrete classes.您可以克隆对象，而无需耦合到其具体类。</td>
<td>Cloning complex objects that have circular references might be very tricky.克隆具有循环引用的复杂对象可能非常棘手。</td>
</tr>
<tr>
<td>You can get rid of repeated initialization code in favor of cloning pre-built prototypes.您可以摆脱重复的初始化代码，转而克隆预构建的原型。</td>
<td></td>
</tr>
<tr>
<td>You can produce complex objects more conveniently.您可以更方便地生成复杂的对象。</td>
<td></td>
</tr>
<tr>
<td>You get an alternative to inheritance when dealing with configuration presets for complex objects.在处理复杂对象的配置预设时，您可以获得继承的替代方法。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <code>Factory Method</code> (less complicated and more customizable via subclasses) and evolve toward <code>Abstract Factory</code>, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><code>Abstract Factory</code> classes are often based on a set of <code>Factory Methods</code>, but you can also use <code>Prototype</code> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><code>Prototype</code> can help when you need to save copies of <code>Commands</code> into history.<br>当您需要将命令的副本保存到历史记录中时，Prototype 可以提供帮助。</p>
</li>
<li><p>Designs that make heavy use of <code>Composite</code> and <code>Decorator</code> can often benefit from using <code>Prototype</code>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用 Composite 和 Decorator 的设计通常可以从使用 Prototype 中受益。通过应用该模式，您可以克隆复杂的结构，而不是从头开始重新构建它们。</p>
</li>
<li><p><code>Prototype</code> isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. <code>Factory Method</code> is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Sometimes <code>Prototype</code> can be a simpler alternative to <code>Memento</code>. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.<br>有时，Prototype 可以成为 Memento 的更简单替代品。如果要存储在历史记录中的对象的状态相当简单，并且没有指向外部资源的链接，或者链接易于重新建立，则此方法有效。</p>
</li>
<li><p><code>Abstract Factories</code>, <code>Builders</code> and <code>Prototypes</code> can all be implemented as <code>Singletons</code>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-example"><a href="#Python-Conceptual-example" class="headerlink" title="Python Conceptual example"></a>Python Conceptual example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelfReferencingEntity</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_parent</span>(<span class="params">self, parent</span>):</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComponent</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Python provides its own interface of Prototype via `copy.copy` and</span></span><br><span class="line"><span class="string">    `copy.deepcopy` functions. And any class that wants to implement custom</span></span><br><span class="line"><span class="string">    implementations have to override `__copy__` and `__deepcopy__` member</span></span><br><span class="line"><span class="string">    functions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, some_int, some_list_of_objects, some_circular_ref</span>):</span><br><span class="line">        self.some_int = some_int</span><br><span class="line">        self.some_list_of_objects = some_list_of_objects</span><br><span class="line">        self.some_circular_ref = some_circular_ref</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a shallow copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.copy` with this object and the returned value is returned as the</span></span><br><span class="line"><span class="string">        new shallow copy.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.copy(self.some_list_of_objects)</span><br><span class="line">        some_circular_ref = copy.copy(self.some_circular_ref)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__.update(self.__dict__)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deepcopy__</span>(<span class="params">self, memo=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a deep copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.deepcopy` with this object and the returned value is returned as</span></span><br><span class="line"><span class="string">        the new deep copy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        What is the use of the argument `memo`? Memo is the dictionary that is</span></span><br><span class="line"><span class="string">        used by the `deepcopy` library to prevent infinite recursive copies in</span></span><br><span class="line"><span class="string">        instances of circular references. Pass it to all the `deepcopy` calls</span></span><br><span class="line"><span class="string">        you make in the `__deepcopy__` implementation to prevent infinite</span></span><br><span class="line"><span class="string">        recursions.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.deepcopy(self.some_list_of_objects, memo)</span><br><span class="line">        some_circular_ref = copy.deepcopy(self.some_circular_ref, memo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__ = copy.deepcopy(self.__dict__, memo)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    list_of_objects = [<span class="number">1</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">    circular_ref = SelfReferencingEntity()</span><br><span class="line">    component = SomeComponent(<span class="number">23</span>, list_of_objects, circular_ref)</span><br><span class="line">    circular_ref.set_parent(component)</span><br><span class="line"></span><br><span class="line">    shallow_copied_component = copy.copy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in shallow_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    shallow_copied_component.some_list_of_objects.append(<span class="string">&quot;another object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;another object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">4</span> <span class="keyword">in</span> shallow_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    deep_copied_component = copy.deepcopy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in deep_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    deep_copied_component.some_list_of_objects.append(<span class="string">&quot;one more object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;one more object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> deep_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;^^ This shows that deepcopied objects contain same reference, they &quot;</span></span><br><span class="line">        <span class="string">&quot;are not cloned repeatedly.&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adding elements to `shallow_copied_component`&#x27;s some_list_of_objects adds it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects changes that object in `shallow_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">Adding elements to `deep_copied_component`&#x27;s some_list_of_objects doesn&#x27;t add it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects doesn&#x27;t change that object in `deep_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent): 4429472784</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): 4429472784</span><br><span class="line">^^ This shows that deepcopied objects contain same reference, they are not cloned repeatedly.</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Built-in-Clone-trait-内置克隆特征"><a href="#Rust-Built-in-Clone-trait-内置克隆特征" class="headerlink" title="Rust Built-in Clone trait 内置克隆特征"></a>Rust Built-in Clone trait 内置克隆特征</h3><p>Rust has a built-in <code>std::clone::Clone</code> trait with many implementations for various types (via <code>#[derive(Clone)]</code>). Thus, the Prototype pattern is ready to use out of the box.<br>Rust 有一个内置 <code>std::clone::Clone</code> 的特性，具有许多针对各种类型的实现（通过 <code>#[derive(Clone)]</code> ）。因此，原型模式可以开箱即用。</p>
<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> y: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> radius: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle1</span> = Circle &#123;</span><br><span class="line">        x: <span class="number">10</span>,</span><br><span class="line">        y: <span class="number">15</span>,</span><br><span class="line">        radius: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prototype in action.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">circle2</span> = circle1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    circle2.radius = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 1: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle1.x, circle1.y, circle1.radius);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 2: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle2.x, circle2.y, circle2.radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Circle 1: 10, 15, 10</span><br><span class="line">Circle 2: 10, 15, 77</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Singleton</title>
    <url>/2023/11/23/design-pattern/singleton/</url>
    <content><![CDATA[<h1 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Singleton</strong> is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.<br>Singleton 是一种创建性设计模式，它允许您确保一个类只有一个实例，同时提供此实例的全局访问点。</p>
<div align="center"> <img src="/images/singleton-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>The Singleton pattern solves two problems at the same time, violating the Single Responsibility Principle:<br>Singleton 模式同时解决了两个问题，违反了单一责任原则：</p>
<ol>
<li><strong>Ensure that a class has just a single instance</strong>. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.<br>确保一个类只有一个实例。为什么有人想要控制一个类有多少个实例？最常见的原因是控制对某些共享资源（例如数据库或文件）的访问。</li>
</ol>
<p>Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.<br>它是这样工作的：假设你创建了一个对象，但过了一段时间决定创建一个新对象。您将获得已创建的对象，而不是接收新对象。</p>
<p>Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.<br>请注意，此行为无法使用常规构造函数实现，因为构造函数调用必须始终返回新对象。</p>
<div align="center"> <img src="/images/singleton-comic-1-en.png"/>Clients may not even realize that they’re working with the same object all the time.</br>客户甚至可能没有意识到他们一直在使用同一个对象。</div>

<ol start="2">
<li><strong>Provide a global access point to that instance</strong>.Remember those global variables that you (all right, me) used to store some essential objects? While they’re very handy, they’re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.<br>为该实例提供全局访问点。还记得你（好吧，我）用来存储一些基本对象的那些全局变量吗？虽然它们非常方便，但它们也非常不安全，因为任何代码都可能覆盖这些变量的内容并使应用程序崩溃。<br>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.<br>就像全局变量一样，Singleton 模式允许您从程序中的任何位置访问某些对象。但是，它还可以保护该实例不被其他代码覆盖。<br>There’s another side to this problem: you don’t want the code that solves problem #1 to be scattered all over your program. It’s much better to have it within one class, especially if the rest of your code already depends on it.<br>这个问题还有另一面：你不希望解决问题 #1 的代码分散在你的程序中。最好将它放在一个类中，特别是如果您的其余代码已经依赖于它。</li>
</ol>
<p>Nowadays, the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems.<br>如今，单例模式已经变得如此流行，以至于人们可能会称某物为单例，即使它只解决了列出的问题之一。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>All implementations of the Singleton have these two steps in common:<br>Singleton 的所有实现都具有以下两个共同步骤：</p>
<ul>
<li>Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.<br>将默认构造函数设为私有，以防止其他对象将运 new 算符与 Singleton 类一起使用。</li>
<li>Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.<br>创建一个充当构造函数的静态创建方法。在后台，此方法调用私有构造函数来创建对象并将其保存在静态字段中。对此方法的所有后续调用都将返回缓存的对象。</li>
</ul>
<p>If your code has access to the Singleton class, then it’s able to call the Singleton’s static method. So whenever that method is called, the same object is always returned.<br>如果您的代码有权访问 Singleton 类，则它能够调用 Singleton 的静态方法。因此，每当调用该方法时，始终返回相同的对象。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, “The Government of X”, is a global point of access that identifies the group of people in charge.<br>政府是辛格尔顿模式的一个很好的例子。一个国家只能有一个官方政府。无论组成政府的个人的个人身份如何，“X政府”这个头衔都是一个全球访问点，用于识别负责人群体。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/singleton-structure-en.png"/></div>
The **Singleton** class declares the static method getInstance that returns the same instance of its own class.
**Singleton** 类声明返回其自身类的相同实例的静态方法 getInstance 。

<p>The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.<br>Singleton 的构造函数应在客户端代码中隐藏。调用该 getInstance 方法应该是获取 Singleton 对象的唯一方法。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the database connection class acts as a <strong>Singleton</strong>. This class doesn’t have a public constructor, so the only way to get its object is to call the <code>getInstance</code> method. This method caches the first created object and returns it in all subsequent calls.<br>在此示例中，数据库连接类充当 Singleton。此类没有公共构造函数，因此获取其对象的唯一方法是调用该 <code>getInstance</code> 方法。此方法缓存第一个创建的对象，并在所有后续调用中返回该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Database class defines the `getInstance` method that lets</span></span><br><span class="line"><span class="comment">// clients access the same instance of a database connection</span></span><br><span class="line"><span class="comment">// throughout the program.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">    <span class="comment">// The field for storing the singleton instance should be</span></span><br><span class="line">    <span class="comment">// declared static.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The singleton&#x27;s constructor should always be private to</span></span><br><span class="line">    <span class="comment">// prevent direct construction calls with the `new`</span></span><br><span class="line">    <span class="comment">// operator.</span></span><br><span class="line">    <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Some initialization code, such as the actual</span></span><br><span class="line">        <span class="comment">// connection to a database server.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The static method that controls access to the singleton</span></span><br><span class="line">    <span class="comment">// instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">            <span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line">                <span class="comment">// Ensure that the instance hasn&#x27;t yet been</span></span><br><span class="line">                <span class="comment">// initialized by another thread while this one</span></span><br><span class="line">                <span class="comment">// has been waiting for the lock&#x27;s release.</span></span><br><span class="line">                <span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line">                    Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line">        <span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, any singleton should define some business logic</span></span><br><span class="line">    <span class="comment">// which can be executed on its instance.</span></span><br><span class="line">    <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">        <span class="comment">// For instance, all database queries of an app go</span></span><br><span class="line">        <span class="comment">// through this method. Therefore, you can place</span></span><br><span class="line">        <span class="comment">// throttling or caching logic here.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// The variable `bar` will contain the same object as</span></span><br><span class="line">        <span class="comment">// the variable `foo`.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.当程序中的类应该只有一个实例可供所有客户端使用时，请使用单例模式;例如，由程序的不同部分共享的单个数据库对象。</strong></p>
</li>
<li><p>The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.<br>Singleton 模式禁用除特殊创建方法之外的所有其他创建类对象的方法。此方法要么创建一个新对象，要么返回一个现有对象（如果已创建）。</p>
</li>
<li><p><strong>Use the Singleton pattern when you need stricter control over global variables.当您需要对全局变量进行更严格的控制时，请使用单例模式。</strong></p>
</li>
<li><p>Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.<br>与全局变量不同，单例模式保证一个类只有一个实例。除了 Singleton 类本身之外，没有任何内容可以替换缓存的实例。</p>
</li>
</ul>
<p>Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the <code>getInstance</code> method.<br>请注意，您始终可以调整此限制，并允许创建任意数量的单例实例。唯一需要更改的代码段是 <code>getInstance</code> 方法的主体。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Add a private static field to the class for storing the singleton instance.<br>在类中添加一个私有静态字段，用于存储单例实例。</p>
</li>
<li><p>Declare a public static creation method for getting the singleton instance.<br>声明用于获取单例实例的公共静态创建方法。</p>
</li>
<li><p>Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.<br>在静态方法中实现“延迟初始化”。它应该在第一次调用时创建一个新对象，并将其放入静态字段中。该方法应始终在所有后续调用中返回该实例。</p>
</li>
<li><p>Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.<br>将类的构造函数设为私有。类的静态方法仍然能够调用构造函数，但不能调用其他对象。</p>
</li>
<li><p>Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.<br>遍历客户端代码，并将对单例构造函数的所有直接调用替换为对其静态创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can be sure that a class has only a single instance.可以确定一个类只有一个实例。</td>
<td>Violates the Single Responsibility Principle. The pattern solves two problems at the time.违反了单一责任原则。该模式解决了当时的两个问题。</td>
</tr>
<tr>
<td>You gain a global access point to that instance.您将获得该实例的全局访问点。</td>
<td>The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.单例模式可以掩盖糟糕的设计，例如，当程序的组件彼此了解太多时。</td>
</tr>
<tr>
<td>The singleton object is initialized only when it’s requested for the first time.仅当首次请求单一实例对象时，才会对其进行初始化。</td>
<td>The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.</td>
</tr>
<tr>
<td>该模式需要在多线程环境中进行特殊处理，以便多个线程不会多次创建单一实例对象。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.对 Singleton 的客户端代码进行单元测试可能很困难，因为许多测试框架在生成模拟对象时依赖于继承。由于单例类的构造函数是私有的，并且在大多数语言中不可能重写静态方法，因此您需要想出一种创造性的方法来模拟单例。或者干脆不写测试。或者不要使用单一实例模式。</td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>A <strong>Facade</strong> class can often be transformed into a <strong>Singleton</strong> since a single facade object is sufficient in most cases.<br>Facade 类通常可以转换为 Singleton，因为在大多数情况下，单个 Facade 对象就足够了。</p>
</li>
<li><p><strong>Flyweight</strong> would resemble <strong>Singleton</strong> if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:<br>如果你以某种方式设法将对象的所有共享状态减少到一个蝇量级对象，那么 Flyweight 将类似于 Singleton。但这些模式之间有两个根本区别：</p>
<ol>
<li>There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.<br>应该只有一个 Singleton 实例，而 Flyweight 类可以有多个具有不同内部状态的实例。</li>
<li>The Singleton object can be mutable. Flyweight objects are immutable.<br>Singleton 对象可以是可变的。轻量级对象是不可变的。</li>
</ol>
</li>
<li><p>Abstract Factories, Builders and Prototypes can all be implemented as Singletons.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Navie-Singleton-简单版"><a href="#Python-Navie-Singleton-简单版" class="headerlink" title="Python: Navie Singleton 简单版"></a>Python: Navie Singleton 简单版</h3><p>It’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method.<br>实现一个草率的 Singleton 非常容易。你只需要隐藏构造函数并实现一个静态创建方法。</p>
<p>The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class.<br>同一类在多线程环境中的行为不正确。多个线程可以同时调用创建方法，并获取 Singleton 类的多个实例。</p>
<h4 id="main-py-Conceptual-example"><a href="#main-py-Conceptual-example" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Singleton class can be implemented in different ways in Python. Some</span></span><br><span class="line"><span class="string">    possible methods include: base class, decorator, metaclass. We will use the</span></span><br><span class="line"><span class="string">    metaclass because it is best suited for this purpose.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">            cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    s1 = Singleton()</span><br><span class="line">    s2 = Singleton()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">id</span>(s1) == <span class="built_in">id</span>(s2):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton works, both variables contain the same instance.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton failed, variables contain different instances.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Singleton works, both variables contain the same instance.</span><br></pre></td></tr></table></figure>

<h3 id="Python-Thread-safe-Singleton-线程安全单例"><a href="#Python-Thread-safe-Singleton-线程安全单例" class="headerlink" title="Python: Thread-safe Singleton 线程安全单例"></a>Python: Thread-safe Singleton 线程安全单例</h3><p>To fix the problem, you have to synchronize threads during the first creation of the Singleton object.<br>若要解决此问题，必须在首次创建 Singleton 对象期间同步线程。</p>
<h4 id="main-py-Conceptual-example-1"><a href="#main-py-Conceptual-example-1" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is a thread-safe implementation of Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    _lock: Lock = Lock()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We now have a lock object that will be used to synchronize threads during</span></span><br><span class="line"><span class="string">    first access to the Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Now, imagine that the program has just been launched. Since there&#x27;s no</span></span><br><span class="line">        <span class="comment"># Singleton instance yet, multiple threads can simultaneously pass the</span></span><br><span class="line">        <span class="comment"># previous conditional and reach this point almost at the same time. The</span></span><br><span class="line">        <span class="comment"># first of them will acquire lock and will proceed further, while the</span></span><br><span class="line">        <span class="comment"># rest will wait here.</span></span><br><span class="line">        <span class="keyword">with</span> cls._lock:</span><br><span class="line">            <span class="comment"># The first thread to acquire the lock, reaches this conditional,</span></span><br><span class="line">            <span class="comment"># goes inside and creates the Singleton instance. Once it leaves the</span></span><br><span class="line">            <span class="comment"># lock block, a thread that might have been waiting for the lock</span></span><br><span class="line">            <span class="comment"># release may then enter this section. But since the Singleton field</span></span><br><span class="line">            <span class="comment"># is already initialized, the thread won&#x27;t create a new object.</span></span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">                instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">                cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    value: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We&#x27;ll use this property to prove that our Singleton really works.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_singleton</span>(<span class="params">value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    singleton = Singleton(value)</span><br><span class="line">    <span class="built_in">print</span>(singleton.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If you see the same value, then singleton was reused (yay!)\n&quot;</span></span><br><span class="line">          <span class="string">&quot;If you see different values, &quot;</span></span><br><span class="line">          <span class="string">&quot;then 2 singletons were created (booo!!)\n\n&quot;</span></span><br><span class="line">          <span class="string">&quot;RESULT:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    process1 = Thread(target=test_singleton, args=(<span class="string">&quot;FOO&quot;</span>,))</span><br><span class="line">    process2 = Thread(target=test_singleton, args=(<span class="string">&quot;BAR&quot;</span>,))</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result-1"><a href="#Output-txt-Execution-result-1" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you see the same value, then singleton was reused (yay!)</span><br><span class="line">If you see different values, then 2 singletons were created (booo!!)</span><br><span class="line"></span><br><span class="line">RESULT:</span><br><span class="line"></span><br><span class="line">FOO</span><br><span class="line">FOO</span><br></pre></td></tr></table></figure>

<h3 id="Rust-specifics"><a href="#Rust-specifics" class="headerlink" title="Rust specifics"></a>Rust specifics</h3><p>By definition, Singleton is a global mutable object. In Rust this is a <code>static mut</code> item. Thus, to avoid all sorts of concurrency issues, the function or block that is either reading or writing to a mutable static variable should be marked as an <code>unsafe</code> block.<br>根据定义，Singleton 是一个全局可变对象。在 Rust 中， static mut 这是一个项目。因此，为了避免各种并发问题，应将读取或写入可变静态变量的函数或块标记为 <code>unsafe</code> 块。</p>
<p>For this reason, the Singleton pattern can be percieved as unsafe. However, the pattern is still widely used in practice. A good read-world example of Singleton is a <code>log</code> crate that introduces <code>log!</code>, <code>debug!</code> and other logging macros, which you can use throughout your code after setting up a concrete logger instance, such as <code>env_logger</code>. As we can see, <code>env_logger</code> uses log::set_boxed_logger under the hood, which has an <code>unsafe</code> block to set up a global logger object.<br>因此，Singleton 模式可能被认为是不安全的。然而，该模式在实践中仍然被广泛使用。Singleton 的一个很好的读取世界示例是一个 log crate，它引入了 log! 和其他 debug! 日志记录宏，在设置具体的记录器实例（如 <code>env_logger</code>）后，您可以在整个代码中使用这些宏。正如我们所看到的， <code>env_logger</code> 在后台使用 log：：set_boxed_logger，它有一个 unsafe 用于设置全局记录器对象的块。</p>
<ul>
<li><p>In order to provide safe and usable access to a singleton object, introduce an API hiding unsafe blocks under the hood.<br>为了提供对单例对象的安全且可用的访问，请在后台引入一个隐藏 <code>unsafe</code> 块的 API。</p>
</li>
<li><p>See the thread about a mutable Singleton on Stackoverflow for more information.<br>有关更多信息，请参阅 Stackoverflow 上有关可变 Singleton 的线程。</p>
</li>
</ul>
<p>Starting with Rust 1.63, <code>Mutex::new</code> is <code>const</code>, you can use global static Mutex locks without needing lazy initialization. See the Singleton using <code>Mutex</code> example below.<br>从 Rust 1.63 开始，您可以使用全局静态 Mutex 锁， <code>Mutex::new</code> <code>const</code> 而无需延迟初始化。请参阅下面的使用互斥锁的单例示例。</p>
<h4 id="Safe-Singleton-安全单例"><a href="#Safe-Singleton-安全单例" class="headerlink" title="Safe Singleton 安全单例"></a>Safe Singleton 安全单例</h4><p>A pure safe way to implement Singleton in Rust is using no global variables at all and passing everything around through function arguments. The oldest living variable is an object created at the start of the <code>main()</code>.<br>在 Rust 中实现 Singleton 的一个纯粹安全的方法是完全不使用全局变量，并通过函数参数传递所有内容。最早的活变量是在 的开头创建的对象 <code>main()</code> 。</p>
<h4 id="safe-rs"><a href="#safe-rs" class="headerlink" title="safe.rs"></a>safe.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A pure safe way to implement Singleton in Rust is using no static variables</span></span><br><span class="line"><span class="comment">//! and passing everything around through function arguments.</span></span><br><span class="line"><span class="comment">//! The oldest living variable is an object created at the start of the `main()`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(global_state: &amp;<span class="keyword">mut</span> <span class="type">u32</span>) &#123;</span><br><span class="line">    *global_state += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">global_state</span> = <span class="number">0u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> global_state);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Final state: &#123;&#125;&quot;</span>, global_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Final state: 1</span><br></pre></td></tr></table></figure>

<h4 id="Lazy-Singleton-惰性单例模式"><a href="#Lazy-Singleton-惰性单例模式" class="headerlink" title="Lazy Singleton 惰性单例模式"></a>Lazy Singleton 惰性单例模式</h4><p>This is a singleton implementation via <code>lazy_static!</code>, which allows declaring a static variable with lazy initialization at first access. It is actually implemented via <code>unsafe</code> with <code>static mut</code> manipulation, however, it keeps your code clear of <code>unsafe</code> blocks.<br>这是一个单例实现，它 lazy_static! 允许在首次访问时使用延迟初始化声明静态变量。它实际上 <code>unsafe</code> 是通过 <code>static mut</code> 操作实现的，但是，它使您的代码没有 <code>unsafe</code> 块。</p>
<h4 id="lazy-rs"><a href="#lazy-rs" class="headerlink" title="lazy.rs"></a>lazy.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Taken from: https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Rust doesn&#x27;t really allow a singleton pattern without `unsafe` because it</span></span><br><span class="line"><span class="comment">//! doesn&#x27;t have a safe mutable global state.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `lazy-static` allows declaring a static variable with lazy initialization</span></span><br><span class="line"><span class="comment">//! at first access. It is actually implemented via `unsafe` with `static mut`</span></span><br><span class="line"><span class="comment">//! manipulation, however, it keeps your code clear of `unsafe` blocks.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `Mutex` provides safe access to a single object.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125;&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3</span><br></pre></td></tr></table></figure>

<h4 id="Singleton-using-Mutex-使用互斥锁的单例"><a href="#Singleton-using-Mutex-使用互斥锁的单例" class="headerlink" title="Singleton using Mutex 使用互斥锁的单例"></a>Singleton using Mutex 使用互斥锁的单例</h4><p>Starting with <code>Rust 1.63</code>, it can be easier to work with global mutable singletons, although it’s still preferable to avoid global variables in mostcases.<br>从 开始 <code>Rust 1.63</code> ，使用全局可变单例会更容易，尽管在大多数情况下仍然最好避免全局变量。</p>
<p>Now that <code>Mutex::new</code> is <code>const</code>, you can use global static <code>Mutex</code> locks without needing lazy initialization.<br>现在 <code>Mutex::new</code> ，您可以使用全局静态 <code>Mutex </code>锁 <code>const</code> ，而无需延迟初始化。</p>
<h4 id="mutex-rs"><a href="#mutex-rs" class="headerlink" title="mutex.rs"></a>mutex.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! ructc 1.63</span></span><br><span class="line"><span class="comment">//! https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Starting with Rust 1.63, it can be easier to work with global mutable</span></span><br><span class="line"><span class="comment">//! singletons, although it&#x27;s still preferable to avoid global variables in most</span></span><br><span class="line"><span class="comment">//! cases.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Now that `Mutex::new` is `const`, you can use global static `Mutex` locks</span></span><br><span class="line"><span class="comment">//! without needing lazy initialization.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125; times&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3 times</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>What&#39;s a design pattern?</title>
    <url>/2023/11/09/design-pattern/what-is-a-design-pattern/</url>
    <content><![CDATA[<h1 id="What’s-a-design-pattern"><a href="#What’s-a-design-pattern" class="headerlink" title="What’s a design pattern?"></a>What’s a design pattern?</h1><h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p>Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.</p>
<p>设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，您可以自定义这些蓝图来解决代码中反复出现的设计问题。</p>
<p>You can’t just find a pattern and copy it into your program, the way you can with off-the-shelf functions or libraries. The pattern is not a specific piece of code, but a general concept for solving a particular problem. You can follow the pattern details and implement a solution that suits the realities of your own program.</p>
<p>你不能只是找到一个模式并将其复制到你的程序中，就像你使用现成的函数或库一样。模式不是一段特定的代码，而是解决特定问题的一般概念。您可以遵循模式详细信息，并实现适合您自己程序实际情况的解决方案。</p>
<p>Patterns are often confused with algorithms, because both concepts describe typical solutions to some known problems. While an algorithm always defines a clear set of actions that can achieve some goal, a pattern is a more high-level description of a solution. The code of the same pattern applied to two different programs may be different.</p>
<p>模式经常与算法混淆，因为这两个概念都描述了一些已知问题的典型解决方案。虽然算法始终定义一组可以实现某些目标的明确操作，但模式是对解决方案的更高级描述。应用于两个不同程序的相同模式的代码可能不同。</p>
<p>An analogy to an algorithm is a cooking recipe: both have clear steps to achieve a goal. On the other hand, a pattern is more like a blueprint: you can see what the result and its features are, but the exact order of implementation is up to you.</p>
<p>算法的类比是烹饪食谱：两者都有明确的步骤来实现目标。另一方面，模式更像是一个蓝图：你可以看到结果及其功能是什么，但实现的确切顺序取决于你。</p>
<h1 id="What-does-the-pattern-consist-of"><a href="#What-does-the-pattern-consist-of" class="headerlink" title="What does the pattern consist of?"></a>What does the pattern consist of?</h1><h1 id="模式由什么组成？"><a href="#模式由什么组成？" class="headerlink" title="模式由什么组成？"></a>模式由什么组成？</h1><p>Most patterns are described very formally so people can reproduce them in many contexts. Here are the sections that are usually present in a pattern description:</p>
<p>大多数模式都描述得非常正式，因此人们可以在许多情况下重现它们。以下是模式描述中通常存在的部分：</p>
<ul>
<li>Intent of the pattern briefly describes both the problem and the solution.<br>模式的意图简要描述了问题和解决方案。</li>
<li>Motivation further explains the problem and the solution the pattern makes possible.<br>动机进一步解释了问题和模式使解决方案成为可能。</li>
<li>Structure of classes shows each part of the pattern and how they are related.<br>类的结构显示了模式的每个部分以及它们之间的关系。</li>
<li>Code example in one of the popular programming languages makes it easier to grasp the idea behind the pattern.<br>使用一种流行的编程语言的代码示例可以更容易地掌握模式背后的思想。</li>
</ul>
<p>Some pattern catalogs list other useful details, such as applicability of the pattern, implementation steps and relations with other patterns.</p>
<p>一些模式目录列出了其他有用的细节，例如模式的适用性、实现步骤以及与其他模式的关系。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Why should I learn patterns?</title>
    <url>/2023/11/15/design-pattern/why-should-i-learn-patterns/</url>
    <content><![CDATA[<h1 id="Why-should-I-learn-patterns"><a href="#Why-should-I-learn-patterns" class="headerlink" title="Why should I learn patterns?"></a>Why should I learn patterns?</h1><h1 id="我为什么要学习模式？"><a href="#我为什么要学习模式？" class="headerlink" title="我为什么要学习模式？"></a>我为什么要学习模式？</h1><p>The truth is that you might manage to work as a programmer for many years without knowing about a single pattern. A lot of people do just that. Even in that case, though, you might be implementing some patterns without even knowing it. So why would you spend time learning them?</p>
<p>事实是，你可能在不了解单一模式的情况下设法作为程序员工作多年。很多人就是这样做的。但是，即使在这种情况下，您也可能在不知不觉中实现某些模式。那么，你为什么要花时间学习它们呢？</p>
<ul>
<li><p>Design patterns are a toolkit of tried and tested solutions to common problems in software design. Even if you never encounter these problems, knowing patterns is still useful because it teaches you how to solve all sorts of problems using principles of object-oriented design.<br>设计模式是软件设计中常见问题的久经考验的解决方案工具包。即使你从未遇到过这些问题，了解模式仍然很有用，因为它教会了你如何使用面向对象设计的原则来解决各种问题。</p>
</li>
<li><p>Design patterns define a common language that you and your teammates can use to communicate more efficiently. You can say, “Oh, just use a Singleton for that,” and everyone will understand the idea behind your suggestion. No need to explain what a singleton is if you know the pattern and its name.<br>设计模式定义了一种通用语言，您和您的团队成员可以使用该语言来更有效地进行通信。你可以说，“哦，就用一个单例来做这件事吧”，每个人都会理解你的建议背后的想法。如果您知道模式及其名称，则无需解释什么是单例。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.01:本地文档</title>
    <url>/2022/12/25/rust_docs/ch_01_01_Installation/</url>
    <content><![CDATA[<h4 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h4><p>安装过程包括了将对应Rust版本的文档复制到本地。所以你可以阅读官方文档，也可以通过命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustup doc</span><br></pre></td></tr></table></figure>

<p>会在浏览器里打开本地文档。</p>
<p>标准库里面的任何一个类型或者函数你不确定的时候，或者你不知道怎么用。使用应用程序编程接口(API)文档来找出答案。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 00.00:欢迎来到Rust编程语言世界！</title>
    <url>/2022/12/24/rust_docs/ch_00_00_introducation/</url>
    <content><![CDATA[<h4 id="欢迎来到Rust编程语言世界！"><a href="#欢迎来到Rust编程语言世界！" class="headerlink" title="欢迎来到Rust编程语言世界！"></a>欢迎来到Rust编程语言世界！</h4><p>不管写的好与差，挖坑先，要不然永远不会开始。</p>
<p>Hello, World!</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2022计划开始一系列关于学习Rust入门的学习笔记，主要是根据官方的文档入门学习。</p>
<p>Rust程序设计语言能帮助你编写更快，更可靠的软件。在编程语言的设计中，高层工程学和底层控制常常是冲突的。Rust挑战了这种冲突。通过平衡强大的技术能力（powerful technical capacity）和 极好的开发者体验（great developer experience）,Rust 可以控制底层的细节（比如内存的使用）但不用忍受传统同类型语言那些困扰。</p>
<p>Rust 已经在证明着自己，对于学习过编程知识的不同水平的开发者来说，如果他们开发大型协同项目都是不错的生产工具。底层的代码容易产生各种不易发现的bugs,在其他编程语言中，要发现这些bugs只能通过广泛的测试和团队中经验丰富的大佬们仔细的评审（review）。在Rust设计中，编译器（compiler）扮演着守门员的角色，它会拒绝包含各种bugs代码的编译。通过编译器的帮忙，开发团队将会把更多的时间用在程序的逻辑上，而不是one day day 地在写bugs与修bugs之间疲于奔命。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.02:编译和运行是彼此独立的步骤</title>
    <url>/2022/12/26/rust_docs/ch_01_02_hello_world/</url>
    <content><![CDATA[<h5 id="编译和运行是彼此独立的步骤"><a href="#编译和运行是彼此独立的步骤" class="headerlink" title="编译和运行是彼此独立的步骤"></a>编译和运行是彼此独立的步骤</h5><p>你刚刚运行了一个新的程序，所以让我们来检查一下这个过程的每一个步骤。</p>
<p>在运行Rust程序之前，你必须通过rustc命令，用Rust编译器来编译这个它，并传入你源代码文件的名字，比如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustc main.rs</span><br></pre></td></tr></table></figure>

<p>如果你有C或者C++的技术背景，你可以视作像gcc 或者clang。在编译成功之后，Rust 会输出一个二进制可执行文件。</p>
<p>对于Linux,macOS和PowerShell on Windows,执行ls的shell命令之后，你就可以看到这个可执行文件。对于Linux，macOS，你可以看到两个文件。对于PowerShell on Windows,你会看到和使用CMD一样的三个文件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">main main.rs</span><br></pre></td></tr></table></figure>

<p>在Windows的CMD，输入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">dir</span> /B %= the /B option says to only show the file names =%</span><br><span class="line">main.exe</span><br><span class="line">main.pdb</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>这显示出以.rs为扩展名的源代码文件和可执行文件(main.exe on Windows, but main on all other platforms),并且，当使用Windows，一个文件包括了debugging信息的.pdb扩展名。到此，你可以开始运行main 或者main.exe文件，如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ./main <span class="comment"># or .\main.exe on Windows</span></span><br></pre></td></tr></table></figure>

<p>如果main.rs是你的”Hello,world!”程序，这行将打印出”Hello,world!”到你的屏幕。</p>
<p>如果你更加熟悉动态语言，如Ruby,Python, JavaScript, 你也许不习惯将编译和运行分为两个单独的步骤。Rust是一个预编译(ahead-of-time compiled)语言，代表你可以编译一个程序并且给可执行文件其他人，并且他们可以直接运行，不需要安装Rust。如果你给某人一个a.rb, .py, .js文件，他们需要安装一个Ruby,Python 或者JavaScript 实现(运行环境)。不过这些语言中，只需要一句命令就可以编译和运行程序。所有的事都是语言设计上的取舍。</p>
<p>仅仅使用rustc编译简单程序是没有问题的。但是随着你的项目发展，你会想要管理所有的选项，使得更简单地共享你的代码。接下来，我们将介绍给你一个叫做Cargo的工具，它将帮助你编写真实世界的Rust程序。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.03:养成使用Cargo习惯</title>
    <url>/2022/12/27/rust_docs/ch_01_03_hello_cargo/</url>
    <content><![CDATA[<h5 id="养成使用Cargo习惯"><a href="#养成使用Cargo习惯" class="headerlink" title="养成使用Cargo习惯"></a>养成使用Cargo习惯</h5><p>对于简单的项目，和rustc相比，Cargo不能提供多大的价值，但是对于复杂的项目，安装了很多crates, 它将会证明它的价值所在。让Cargo来协调构建工作会变得容易更多。</p>
<p>即使hello_cargo这么简单的项目，它现在使用了很多你之后的Rust生涯将会用到的使用工具。其实，要在任何已存在的项目上工作时，可以使用如下的命令通过Git拿到代码，移动到你的projects目录，并构建：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git clone example.org/someproject</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> someproject</span><br><span class="line"><span class="variable">$</span> cargo build</span><br></pre></td></tr></table></figure>

<p>更多关于Cargo详情，请查看Cargo 文档(<a href="https://doc.rust-lang.org/cargo/">https://doc.rust-lang.org/cargo/</a>)</p>
<p><strong>总结</strong></p>
<p>对于你的Rust之旅，你已经有一个很棒的开始了！本章你已经学会了如何：</p>
<ul>
<li>使用rustup安装最新稳定版Rust</li>
<li>更新到新版的Rust</li>
<li>打开本地安装的文档</li>
<li>直接通过rustc编写并运行”Hello,world!”程序</li>
<li>使用Cargo创建并运行项目</li>
</ul>
<p>是时候通过构建更实质性的程序来熟悉写Rust代码了。所以在Chapter 2,我们将构建一个猜数字的游戏程序。如果你更想从学习Rust常用的编程概念开始，请阅读Chapter 3，接着回来看Chapter 2.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 02.00:猜测正确后退出</title>
    <url>/2022/12/28/rust_docs/ch_02_00_guessing_game_tutorial/</url>
    <content><![CDATA[<h5 id="猜测正确后退出"><a href="#猜测正确后退出" class="headerlink" title="猜测正确后退出"></a>猜测正确后退出</h5><p>让我们增加一个break语句，在用户才对时退出游戏：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在You win!之后增加一行break;，用户猜对了神秘数字之后会退出循环。退出循环也意味着退出程序，因为循环是main最后一部分。</p>
<p><strong>处理无效输入</strong></p>
<p> 为了进一步使得游戏表现更好，而不是当用户输入无效数字就崩溃，需要忽略无效输入，让用户继续猜。可以通过修改guess将String转换为u32那部分代码来实现，如Listing 2-5:</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>Listing 2-5 Ignoring a non-number guess and asking for another guess instead of crashing the program</p>
<p>我们将expect调用换成match语句，以从遇到错误就崩溃变为处理错误。需知parse返回一个Result类型，而Result是一个用于Ok或Err成员的枚举。这里使用的match表达式，和之前处理cmp方法返回Ordering时用的一样。</p>
<p>如果parse不能将字符串转换一个数字，它会返回一个包含更多错误信息的Err。Err值不能匹配第一个match分支的Ok(num)模式，但是会匹配第二个分支Err(_)模式：_是一个通配符值，本例中用来匹配所有的Err值，不管其中有任何信息。所以程序会执行第二个分支的动作，continue 意味着进入loop的下一次循环，请求另一个猜测。这样程序就有效地忽略了parse可能遇到的所有错误！</p>
<p>现在所有的事情都是我们期待的了，让我们试试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling guessing_game v0.<span class="number">1.0</span> (file:///projects/guessing_game)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">4.45</span>s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: <span class="number">61</span></span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">10</span></span><br><span class="line">You guessed: <span class="number">10</span></span><br><span class="line">Too small!</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">99</span></span><br><span class="line">You guessed: <span class="number">99</span></span><br><span class="line">Too big!</span><br><span class="line">Please input your guess.</span><br><span class="line">foo</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">61</span></span><br><span class="line">You guessed: <span class="number">61</span></span><br><span class="line">You win!</span><br></pre></td></tr></table></figure>

<p>牛逼！再有一个小的修改，就能完成猜数字游戏了：还记得程序依然会打印出秘密数字吗？那个是为了便于测试，但是它破坏游戏性。让我们删掉这个打印语句吧。Listing 2-6是最终版本的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 2-6 Complete guessing game code</p>
<p><strong>总结</strong></p>
<p>至此，你成功地构建了猜数字游戏。恭喜你！</p>
<p>这个项目是一个通过动手实践，向你介绍了很多Rust新概念：let,match,函数，使用外部crate等等。在接下来的章节中，你将会学习这些概念的细节。第三章介绍大部分程序语言都有的概念，比如变量，数据类型和函数，以及如何在Rust中使用他们。第四章探索所有权(owership)，一个特性，使得Rust与其他语言不同的特性。第五章讨论结构体和方法的语法，第六章介绍枚举如何工作。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.00:关键字(Keywords)</title>
    <url>/2022/12/29/rust_docs/ch_03_00_common_programming_concepts/</url>
    <content><![CDATA[<h5 id="关键字-Keywords"><a href="#关键字-Keywords" class="headerlink" title="关键字(Keywords)"></a>关键字(Keywords)</h5><p>Rust语言有一个关键字集合，这些关键字预留给语言本使用，和其他大部分语言一样。牢记在心，你不能使用这些单词作为变量名或者函数名。大部分的关键字有其特殊的意义，而且你会用这些关键字来做各种各样的任务在Rust程序里。一些关键词目前没有相应的功能，是为了将来可能添加的功能预留的。可以在Appendix A(<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html)%E6%9F%A5%E7%9C%8B">https://doc.rust-lang.org/book/appendix-01-keywords.html)查看</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.01:隐藏(Shadowing)</title>
    <url>/2022/12/29/rust_docs/ch_03_01_variables_and_mutability/</url>
    <content><![CDATA[<h5 id="隐藏-Shadowing"><a href="#隐藏-Shadowing" class="headerlink" title="隐藏(Shadowing)"></a>隐藏(Shadowing)</h5><p>如你在第二章猜数字游戏教程所见，你可以声明一个新的变量用和前面声明的变量同样的名字。Rustaceans说第一个变量被第二个隐藏(Shadowing)了，意思是第二个变量的值是在程序使用时才看到的。我们可以shadow一个变量使用相同的变量名，并重复地使用let关键字，如下：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先绑定了5给x。然后重新用let x&#x3D;隐藏了x，使得原来的值加1，所以变量的值变为了6。然后，在内部作用域，第三次let声明x, 将之前的值乘以2得到12。当内部作用结束，内部的隐藏结束，并且x变回6。当我们运行这个程序，它运行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:///projects/variables)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.31</span>s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: <span class="number">12</span></span><br><span class="line">The value of x is: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>隐藏不同于将变量标记为mut，因为如果我们意外地尝试重新分配这个变量不使用let关键字，我们会得到一个编译错误。通过使用let，我们可以对一个值执行一些转换，但在这些转换完成后，变量是不可变的。</p>
<p>其他的mut和shadowing之间的不同之处是因为当我们再次使用let关键字，我们实际上创建了一个新的变量。例如，假如我们的程序要求用户输入空格来显示文本之间需要多少空格，然后我们希望将输入存储为数字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先spaces变量是一个string类型，然后第二个spaces变量是数字类型。因此shadowing使我们不需使用不同的变量名，如space_str 和 space_num；然而，如果我们尝试使用mut，如下，我们会得到一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误说我们不被允许转变变量的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:<span class="comment">///projects/variables)</span></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">14</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;<span class="type">str</span>`, found `<span class="type">usize</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `variables` due to previous error</span><br></pre></td></tr></table></figure>

<p>现在，我们探索了变量是如何工作的，我们还有更多的数据类型等着你呢！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.02:无效的数组元素访问</title>
    <url>/2022/12/29/rust_docs/ch_03_02_data_types/</url>
    <content><![CDATA[<h6 id="无效的数组元素访问"><a href="#无效的数组元素访问" class="headerlink" title="无效的数组元素访问"></a>无效的数组元素访问</h6><p>让我们看看发生了什么，如果你尝试访问数组的一个元素，这个元素在数组的结尾之后呢。运行如下的代码，类似于第二章猜数字游戏，从用户输入那里获取数组索引：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The value of the element at index &#123;&#125; is: &#123;&#125;&quot;</span>,</span><br><span class="line">        index, element</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译成功。如果运行这段代码使用cargo run然后输入0，1，2，3，4，这个程序会打印出在数组内对应索引的值。如果你输入一个超出范围的数字，比如10，你会看到输出如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;index out of bounds: the len is 5 but the index is 10&#x27;</span>, src/main.rs:<span class="number">19</span>:<span class="number">19</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你使用这个无效的值索引的时候，程序的结果是在运行时间的错误。程序退出并返回错误信息，并且没有运行最后的println!语句。当你试图用一个索引访问一个元素，Rust会检查你指定的这个索引是否会超过数组的长度。如果索引与数组长度相同或者更大，Rust就会死给你看。这个检查在运行时间，特别在这个例子中，因为编译器在编译完之后就不可能知道用户会输入什么。</p>
<p>这是一个Rust的内存安全原则示例的表现。在很多底层代码语言中，当你提供一个错误的索引，这种类型的检查它们是不做的，无效内存就会被访问，会导致你不知道你到底访问到了别的什么奇奇怪怪的值。Rust项目中会立即退出，而不是允许你继续访问，从而保护你面授此类错误的影响。第九章将会讨论Rust的错误处理。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.03:函数(Functions)</title>
    <url>/2022/12/29/rust_docs/ch_03_03_how_functions_work/</url>
    <content><![CDATA[<h4 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h4><p>函数在Rust代码中是很普遍的。你已经看了在语言中最重要的函数之一：main函数，是很多程序的入口。你也看到了fn关键字，它允许你声明一个新的函数。</p>
<p>Rust代码中的函数和变量使用snake case的代码风格，所有的单词小写并用下划线隔开。这里有一个程序包含了一个函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let x = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，five函数没有参数并定义了返回值类型，不过函数体只有单单一个5，因为它是一个表达式，可以返回我们想要的值。</p>
<p>让我们看看另外一个例子：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码，会产生一个如下的错误：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling functions v0.<span class="number">1.0</span> (file:///projects/functions)</span><br><span class="line">error[<span class="type">E0308</span>]: mismatched types</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">7</span>:<span class="number">24</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">7</span> | fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">  |    <span class="literal">--------</span>            ^^^ expected `i32`, found `()`</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line"><span class="number">8</span> |     x + <span class="number">1</span>;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0308`.</span><br><span class="line">error: could not compile `functions` due to previous error</span><br></pre></td></tr></table></figure>

<p>主要的错误信息”mismatched types”揭示了这段代码的核心问题所在。定义函数plus_one，然后说要返回一个i32，但是语句不会计算得到一个值，使用单位类型()表示不返回值。因为不返回值与函数返回一个i32类型的值矛盾，从而出现一个错误。在输出中，Rust提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p>
<p>正确的代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.04:注释(Comments)</title>
    <url>/2022/12/29/rust_docs/ch_03_04_comments/</url>
    <content><![CDATA[<h4 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释(Comments)"></a>注释(Comments)</h4><p>所有的程序设计人员努力使他们的代码更容易理解，但是有时候额外的解释是有必要的。在这种情况下程序设计人员在源代码中留下注释(comments)，编译器会忽略这些注释，但是人阅读源码会发现它很有用。</p>
<p>这里有一个简单的注释例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// So we’re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">// explain what’s going on.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释可以放在代码行结尾：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>; <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是你经常看到更多是如下的格式，在代码的上方的单独一行注释：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 也有其他类型的注释，文档注释(documentation comments)，详细在第14章的”Publishing a Crate to Crates.io” 部分介绍。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.05:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_03_05_control_flow/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>你做到了！这是相当大的一章：你学习了关于variables, scalar and compound data type, functions, comments, if expressions, and loops! 讨论并练习这些概念。尝试构建如下的程序：</p>
<ul>
<li>相互转换摄氏与华氏温度(Convert temperatures between Fahrenheit and Celsius.)</li>
<li>生成n阶斐波那契数列(Generate th nth Fibonacci number.)</li>
<li>打印圣诞颂歌词，并利用歌词中的重复部分(编写循环)(Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” taking advantage of the repetition in the song.)</li>
</ul>
<p>当你准备好继续的时候，让我们讨论一个其他语言中不常见的概念：所有权(ownership)</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.01:返回值与作用域(Return Values and Scope)</title>
    <url>/2022/12/29/rust_docs/ch_04_01_what_id_ownership/</url>
    <content><![CDATA[<h4 id="返回值与作用域-Return-Values-and-Scope"><a href="#返回值与作用域-Return-Values-and-Scope" class="headerlink" title="返回值与作用域(Return Values and Scope)"></a>返回值与作用域(Return Values and Scope)</h4><p>返回值也可以转移所有权。Listing 4-4展示了一个示例，与Listing4-3一样带有类似的注释。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                        <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                        <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line">  <span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                             <span class="comment">// return value into the function</span></span><br><span class="line">                                             <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">                                             <span class="comment">// moves out to the calling</span></span><br><span class="line">                                             <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a String and returns one</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">                                                      <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-4: Transferring ownership of return values</p>
<p>变量的所有权总是遵循相同的模式：将赋值给另一个变量时移动它。当持有堆中数据的变量离开作用域时，其值将通过drop被清理，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都穿进去再返回来就有点烦人了，除此之外，我们可能想返回函数中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如Listing 4-5。</p>
<p>Filename：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-5: Returning ownership of parameters</p>
<p>但是，对于一个应该是普通的概念来说，这太多的仪式和大量的工作。幸运的是，Rust有一个特性，可以在不用转移所有权的情况下使用值，它叫做引用(references)。</p>
<p>接下来将讲”引用和借用(References and Borrowing)”</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.02:引用的规则(The Rules of References)</title>
    <url>/2022/12/29/rust_docs/ch_04_02_references_and_borrowing/</url>
    <content><![CDATA[<h4 id="引用的规则-The-Rules-of-References"><a href="#引用的规则-The-Rules-of-References" class="headerlink" title="引用的规则(The Rules of References)"></a>引用的规则(The Rules of References)</h4><p>让我们来重新概况一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.03:总结</title>
    <url>/2022/12/29/rust_docs/ch_04_03_slices/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所有权、借用和slice这些概念让Rust程序在编译时保证内存安全。Rust语言提供了跟其他系统编程语言相同的方式来控制你使用内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无需额外编写和调试相关的控制代码。</p>
<p>所有权系统影响了Rust中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书余下的内容。让我们开始第五章吧，来看看如何将多份数据组合进一个struct中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.00:Using Structs to Structure Related Data</title>
    <url>/2022/12/29/rust_docs/ch_05_00_structs/</url>
    <content><![CDATA[<h4 id="Using-Structs-to-Structure-Related-Data"><a href="#Using-Structs-to-Structure-Related-Data" class="headerlink" title="Using Structs to Structure Related Data"></a>Using Structs to Structure Related Data</h4><p>struct or structure 是一个自定义的数据类型，允许你包装和命名多个相关联的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，struct就像对象中的数据属性。在本章中，我们会对元组和结构体进行对比和对照。还将演示如何定义和实现实例化结构体，并讨论如何定义关联函数，特别是被称为方法的那种关联函数，以指定与结构体类型相关的行为。你可以在程序中基于结构体和枚举(enum)（在第六章中介绍）创建新类型，以充分利用Rust的编译时类型检查。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.00:Understanding Ownership</title>
    <url>/2022/12/29/rust_docs/ch_04_00_understanding_ownership/</url>
    <content><![CDATA[<h4 id="Understanding-Ownership"><a href="#Understanding-Ownership" class="headerlink" title="Understanding Ownership"></a>Understanding Ownership</h4><p>Ownership 是Rust最独特的特性，并且对剩下的部分有着深刻的意义。它能让Rust在不需要垃圾回收(garbage collection)就能保证内存安全，所以能够很好地理解owership是如何工作的是非常重要的。在本章，我们将讲和ownership关联的一些特性：borrowing, slice, 和Rust如何在内存中布局数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.01:结构体数据的所有权(Ownership of Struct Data)</title>
    <url>/2022/12/29/rust_docs/ch_05_01_defining_and_instantiating_structs/</url>
    <content><![CDATA[<h4 id="结构体数据的所有权-Ownership-of-Struct-Data"><a href="#结构体数据的所有权-Ownership-of-Struct-Data" class="headerlink" title="结构体数据的所有权(Ownership of Struct Data)"></a>结构体数据的所有权(Ownership of Struct Data)</h4><p>在Listing 5-1中的<code>User</code>结构体定义中，我们使用了自身拥有所有权的String类型而不是&amp;str字符串slice类型。这是一个有意为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话数据也是有效的。可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期(lifetimes)，这是一个第十章会讨论的Rust功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不是指定生命周期将是无效的，比如这样：</p>
<p>filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会控诉它需要生命周期标识符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling structs v0.<span class="number">1.0</span> (file:<span class="comment">///projects/structs)</span></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">15</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> ~     username: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">12</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     email: &amp;<span class="type">str</span>,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line"><span class="number">4</span> ~     email: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `structs` due to <span class="number">2</span> previous errors=</span><br></pre></td></tr></table></figure>

<p>第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们使用像String这类拥有所有权的类型来替代&amp;str这样的引用以修正这个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.02:An Example Program Using Structs</title>
    <url>/2022/12/29/rust_docs/ch_05_02_example_structs/</url>
    <content><![CDATA[<h4 id="An-Example-Program-Using-Structs"><a href="#An-Example-Program-Using-Structs" class="headerlink" title="An Example Program Using Structs"></a>An Example Program Using Structs</h4><p>为了理解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将通过使用单个变量开始，然后重构这个程序，直到用结构体替代它。</p>
<p>让我们用cargo创建一个新的项目叫做<code>rectangles</code>的二进制程序，它获取以像素为单位的矩形的宽度和高度，并计算出矩形的面积。Listing 5-8 展示一个简短的程序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把<code>dbg!</code>放在表达式放在<code>30 * scale</code>周围，以为你<code>dbg!</code>返回表达式的值的所有权，所以width字段将获得相同的值，就像我们在这里没有<code>dbg!</code>调用一样。我们不希望dbg!拥有rect1的所有权，所以我们在下一次调用dbg!时传递一个引用。下面是这个例子的输出结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.<span class="number">1.0</span> (file:<span class="comment">///projects/rectangles)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.61</span>s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">[src/main.rs:<span class="number">10</span>] <span class="number">30</span> * scale = <span class="number">60</span></span><br><span class="line">[src/main.rs:<span class="number">14</span>] &amp;rect1 = Rectangle &#123;</span><br><span class="line">    width: <span class="number">60</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到第一条输出来自src&#x2F;main.rs第10行，我们正在调用表达式<code>30 * scale</code>，其结果值是60(为整数实现的Debug格式化是只打印它们的值)。在src&#x2F;main.rs第14行的dbg!调用输出&amp;rect1的值，即<code>Rectangle</code>类型。<code>dbg!</code>宏确实很有用。</p>
<p>除了<code>Debug</code>trait，Rust还为我们提供了很多通过derive属性来使用的trait，它们可以为我们的自定义类型增加实用的行为。这些trait和行为被列举在附录C(Appendix C)。第十章会介绍如何通过自定义行为来实现这些trait，同时还有如何创建你自己的trait。除了derive之外，还有很多属性；更多信息见”Rust Reference”的Attribute部分。</p>
<p>我们的<code>area</code>函数是非常特殊的，它只计算长方形的面积。如果这个行为与<code>Rectangle</code>结构体再结合得更紧密一些就更好了，因为它不能用于其他类型。现在让我们看看如何继续重构这些代码，来将<code>area</code>函数协调进<code>Rectangle</code>类型定义的<code>area</code>方法中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.03:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_05_03_method_syntax/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>结构体让你创建自定义的类型在你的domain中。通过使用结构体，你可以将数据关联起来，使得它看起来更加清晰。在impl块内，你可以定义函数并关联你的类型，而且方法是一个很好的关联方式，它让你的结构体有了可以指定它特定行为的能力。</p>
<p>但是结构体不是唯一的方式来创建自定义类型：让我们转到Rust的枚举(enum)特性来，为你的工具箱再添加一个工具。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.00:Enums and Pattern Matching</title>
    <url>/2022/12/29/rust_docs/ch_06_00_enums_and_pattern_matching/</url>
    <content><![CDATA[<h4 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a>Enums and Pattern Matching</h4><p>本章中，我们讲述枚举(enumerations)，也称作enums。枚举允许你通过列举可能的成员(variants)来定义一个类型。首先，我们会定义并使用一个枚举来展示它是如何连同数据一起编码信息的。接下来，我们会探索一个特别有用的枚举，叫做<code>Option</code>，它代表一个值，要么是某个值要么是什么都不是。然后会讲到<code>match</code>表达式中使用模式匹配，针对不同的枚举值编写相应要执行的代码。然后会介绍<code>if let</code>，另一个简洁方便处理代码中枚举的结构。</p>
<p>枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust的枚举与F#，OCaml和Haskell这样的函数式编程语言中的代数数据类型(olgebraic data types)最为相似。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.02:通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</title>
    <url>/2022/12/29/rust_docs/ch_06_02_match/</url>
    <content><![CDATA[<h4 id="通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder"><a href="#通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder" class="headerlink" title="通用模式和_占位符(Catch-all Patterns and the _ Placeholder)"></a>通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</h4><p>使用枚举，我们希望对一些特定的值采取特殊操作，而对其他的值采用默认操作。想象我们正在玩一个游戏，如果你掷出一个骰子的值为3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了7，你的角色将会失去新奇的帽子。对于其他的数值，你的角色会在棋盘上移动想的格子。这是一个实现了上述逻辑的<code>match</code>。骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值3和7，最后一个分支则涵盖了所有其他可能性的值，模式使我们命名为<code>other</code>的一个变量。<code>other</code>分支的代码通过将其传递给<code>move_player</code>函数来使用这个变量。</p>
<p>即使我们没有列出<code>u8</code>所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了<code>match</code>必须穷尽的要求。请注意，我们必须将通过通配分支放在最后，因为模式是按顺序匹配的。如果哦我们在通配分支后添加其他分支，Rust将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust还提供了一个模式，当我们不想使用通配模式的值时，请使用<code>_</code>，这是一个特殊模式，可以匹配任意值而不用绑定到该值。这告诉Rust我们不会使用这个值，所以Rust也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是3或7的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用<code>_</code>来替代变量<code>other</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷举性要求，因为我们在最后一个分支中明确地忽略了其他的值。我们没有忘记任何东西。</p>
<p>最后，我们再次改动游戏规则，如果投掷出3或者7以外的值，你的回合将无事发生。我们可以使用单元值(unit value：就是空的tuple，在”The Tuple Type”部分有提及)作为<code>_</code>分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉Rust我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<p>更详细的模式匹配相关我们将会在Chapter 18进行讲解。目前，我们继续讨论<code>if let</code>语法，这在<code>match</code>表达式有点冗长的情况下比较有用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.01:The Option Enum and Its Advantages Over Null Values</title>
    <url>/2022/12/29/rust_docs/ch_06_01_defining_an_enum/</url>
    <content><![CDATA[<h3 id="The-Option-Enum-and-Its-Advantages-Over-Null-Values"><a href="#The-Option-Enum-and-Its-Advantages-Over-Null-Values" class="headerlink" title="The Option Enum and Its Advantages Over Null Values"></a>The Option Enum and Its Advantages Over Null Values</h3><p>这一部分探索学习<code>Option</code>，另外一个标准库的枚举定义。<code>Option</code>类型编码了非常常见的场景，其中可以是某个值，也可以都不是。</p>
<p>例如，如果请求一个包含项的列表的第一个值，会得到一个值，如果请求一个空的列表，就什么也不会得到。从类型系统的角度来表达这个概念意思就是编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他语言中非常常见的bug.</p>
<p>编程语言的设计通常考虑的是包含哪些特性，但是你排除的特性也很重要。Rust没有许多其他语言所具有的null特性。<code>Null</code>是一个值，表示什么也没有。在带有null特性的语言中，变量总是可以处于两种状态之一：null 或 not-null.</p>
<p>Null的发明者Tony Hoare在他2009年的报告”Null Reference: The Billon Dollar Mistake”中这样说：</p>
<blockquote>
<p>我称之为十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误，漏洞和系统崩溃，在之后的四十多年中造成了十亿美元的苦痛和伤害。</p>
</blockquote>
<p>空值的问题在于，如果你试图将空值用作非空值，会出现某种形式的错误。因为空和非空的属性到处都是，非常容易出现这类错误。</p>
<p>然而，null试图表达的概念仍然是有用的：null是当前由于某种原因无效或者不存在的值。</p>
<p>问题不在于概念，而在于具体的实现。因此，Rust没有空值，但它有一个枚举，可以编码值存在或者不存在的概念。这个枚举就是<code>Option&lt;T&gt;</code>，它由标准库定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code>枚举非常有用，以至于它被包含在relude中；你不需要将它显式地引入作用域。另外，它的成员也是如此（被包含在prelude中），可以不需要<code>Option::</code>前缀来使用<code>Some</code>和<code>None</code>。即便如此<code>Option&lt;T&gt;</code>也仍是常规的枚举，<code>Some&lt;T&gt;</code>和<code>None</code>仍是<code>Option&lt;T&gt;</code>的成员。</p>
<p><code>&lt;T&gt;</code>语法是我们还没讲到的Rust特性。它是一个泛型参数，在Chapter 10我们将会详细讲解。目前，你需要知道的就是<code>&lt;T&gt;</code>意味着<code>Option</code>枚举的<code>Some</code>成员可以包含任意类型的数据，同事每一个用于<code>T</code>位置的具体类型使得<code>Option&lt;T&gt;</code>整体作为不同的类型。这里是一些包含数字类型和字符串类型<code>Option</code>值的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code>的类型是<code>Option&lt;i32&gt;</code>。<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，是不同的类型。因为我们在<code>Some</code>成员中指定了值，Rust可以推断出其类型。对于<code>absent_number</code>，Rust需要我们指定<code>Option</code>整体的类型，因为编译器只通过<code>None</code>值无法推断出<code>Some</code>成员保存的值的类型。这里我们告诉Rust我们需要<code>absent_number</code>的类型是<code>Option&lt;i32&gt;</code>。</p>
<p>当我们有一个<code>Some</code>值，我们就知道存在一个值，这个值保存在<code>Some</code>中。当我们有一个值<code>None</code>，在某种意义上，它跟空值是有相同的意义：并没有一个有效的值。那么<code>Option&lt;T&gt;</code>为什么就比Null要好呢？</p>
<p>简单来说，因为<code>Option&lt;T&gt;</code>和<code>T</code>（<code>T</code>可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用<code>Option&lt;T&gt;</code>。例如：这段代码不能编译，因为它尝试将<code>Option&lt;i8&gt;</code>与<code>i8</code>相加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们运行这段代码，我们会得到一个错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"> --&gt; src/main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            &lt;&amp;&#x27;a f32 as Add&lt;f32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a f64 as Add&lt;f64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i128 as Add&lt;i128&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i16 as Add&lt;i16&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i32 as Add&lt;i32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i64 as Add&lt;i64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i8 as Add&lt;i8&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a isize as Add&lt;isize&gt;&gt;</span><br><span class="line">          and 48 others</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` due to previous error</span><br></pre></td></tr></table></figure>

<p>铛!铛!铛!事实上，这个错误意味着Rust不知道如何将<code>i8</code>和<code>Option&lt;i8&gt;</code>相加，因为它们是不同类型。在Rust中，当我们有一个值像<code>i8</code>，编译器将会确保我们总是有一个有效的值。我们可以自信地使用而无需做空检查。只有当使用<code>Option&lt;i8&gt;</code>(或者任何用到的类型)我们需要担心可能没有一个有效值，并且编译器将会确保我们在使用值之前处理了空的情况。</p>
<p>换句话说，你必须将<code>Option&lt;T&gt;</code>转换成<code>T</code>之后才能对<code>T</code>进行运算。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空，但实际上是空的情况。</p>
<p>消除错误地假设非空值的风险有助于你对代码更有信心。为了有一个可能为空的值，你必须显式地使用<code>Option&lt;T&gt;</code>。然后，在使用该值时，需要显式地处理值为空的情况。任何地方，一个值不是<code>Option&lt;T&gt;</code>类型，你都可以放心地假设他不是null。这是Rust有意为之的设计决定，目的就是限制null的滥用，以增加Rust代码的安全性。</p>
<p>所以，当你有一个类型为<code>Option&lt;T&gt;</code>的值时，你如何从<code>Some</code>变量中获得<code>T</code>的值呢？<code>Option&lt;T&gt;</code>枚举有大量很有用的方法适用于各种情况；你可以查看它的文档(<a href="https://doc.rust-lang.org/std/option/enum.Option.html)%E3%80%82%E7%86%9F%E6%82%89%60Option">https://doc.rust-lang.org/std/option/enum.Option.html)。熟悉`Option</a><T>&#96;上的方法将对你的Rust之旅很有用哦！</p>
<p>通常，为了使用<code>Option&lt;T&gt;</code>值，你需要有处理每个变量的代码。你希望一些代码只在具有<code>Some&lt;T&gt;</code>值时运行，并且允许这些代码使用内部的<code>T</code>。你希望如果有个<code>None</code>值时运行一些其他的代码，而且这些代码也没有一个<code>T</code>的有效值。<code>match</code>表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.03:总结</title>
    <url>/2023/05/16/rust_docs/ch_06_03_if_let/</url>
    <content><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们学习了如何使用枚举创建自定义类型。我们也展示了标准库的<code>Option&lt;T&gt;</code>类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据你需要处理多少种情况来选择使用<code>mathc</code>或者<code>if let</code>来提取或者使用这些值。</p>
<p>你的Rust程序现在能够使用结构体和枚举在你自己的作用域内表现其内容了。在你的API中使用定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。</p>
<p>为了提供一个有条理的API给你的用户，它使用起来很简单易懂，值暴露了你的用户需要的东西，现在我们准备开始学习Rust的模块。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.00:使用包、Crate和模块管理不断增长的项目</title>
    <url>/2023/05/18/rust_docs/ch_07_00_managing_growing_projects_with_packages_crates_and_modules/</url>
    <content><![CDATA[<h2 id="使用包、Crate和模块管理不断增长的项目"><a href="#使用包、Crate和模块管理不断增长的项目" class="headerlink" title="使用包、Crate和模块管理不断增长的项目"></a>使用包、Crate和模块管理不断增长的项目</h2><p>当你编写大型程序时，组织代码将变得越来越重要。通过相关功能进行分组，并将具有不同特性的代码分开，你将可以清楚地在哪里可以找到现实特定特性的代码，以及在哪里可以更改一个特性的工作方式。</p>
<p>到目前为止，我们编写的代码都只在一个文件中的一个模块中。 随着项目不断增长，你应该通过多个模块和多个文件来组织拆分你的代码。一个包可以包含多个二进制crates和一个可选的crate程序库。随着你的包的增长，你可以将部分提取到单独的crates使它变成外部依赖。本章涵盖了所有这些技巧。对于由一组相互关联的包组成的非常大的项目，Cargo提供了工作区(workspaces)，我们将在第14章”Cargo Workspaces”部分学习。</p>
<p>我们还将讨论封装实现的细节，这让你可以高水平重用代码：一旦你实现了一个操作，其他代码可以通过代码的公共接口调用，无需知道你的实现过程是如何运作。编写代码的方式定义了那些部分是其他代码使用的公共部分，那些代码是你保留更改权利的私有实现细节。这是另一种限制，减少你必须记住项目内容细节的数量的方法。</p>
<p>这里还一个相关的概念是作用域(scope)：代码所在的嵌套上下文有一组定义”in scope”的名称。当你阅读，编写和编译代码，程序设计师和编译器需要知道模块，常量或者其他有意义的项。你可以创建作用域并改变那些名称再作用域内还是在作用域外。同一个作用域不能拥有两个相同名称的项；可以使用一些工具来解决名称冲突。</p>
<p>Rust有许多特性允许你来管理你的代码组织结构，包括那些内容可以被公开，那些内容作为私有部分，以及程序每个作用域中的名字。这些功能。有时被称为”模块系统(the module system)”，包括：</p>
<ul>
<li>包(Packages)：Cargo的一个功能，它允许你构建，测试和分享crate。</li>
<li>Crates：一个模块的树形结构，它形成了库或者二进制项目。</li>
<li>模块(Modules)和Use：允许你控制组织结构的作用域和路径的私有性。</li>
<li>路径(path)：一个命名例如结构体，函数或模块等项的方式。</li>
</ul>
<p>在本章，我们将涵盖所有这些特性，讨论他们怎样相互作用，并解释如何使用他们管理作用域。最后，你应该对模块系统有一个坚实的理解，并能够像专业人士一样使用作用域！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.01:包和Crates</title>
    <url>/2023/05/18/rust_docs/ch_07_01_packages_and_crates/</url>
    <content><![CDATA[<h2 id="包和Crates"><a href="#包和Crates" class="headerlink" title="包和Crates"></a>包和Crates</h2><p>模块系统的第一部分我们将介绍包和crate。</p>
<p>crate是Rust编译时最小的代码单位。如果你用<code>rustc</code>而不是<code>cargo</code>来编译一个文件(第一章我们这么做)，编译器还是会将那个文件认作一个crate。crate可以包含模块，模块可以定义在其他文件，然后和crate一起编译，我们会在接下来的章节中遇到。</p>
<p>crate有两种形式：二进制项和库。二进制crate可以被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个<code>main</code>函数来定义当程序被执行的时候所需要做的事情。到目前为止，我们所创建的crate都是二进制crate。</p>
<p>库(Library crates) 没有<code>main</code>函数，而且它们不会编译成可执行文件。相反，它们定义了旨在与多个项目共享的功能。例如，我们在第二章用过的<code>rand</code>函数，用来生成随机数。大多数的Rust开发者说的crate指的都是库，这与其他变成语言中的library概念一致。</p>
<p>crate root是一个资源文件，Rust编译器以它为起始点，并组成crate的根模块(我们将在”Defining Modules to Control Scope and Privacy” 部分深度解析)。</p>
<p>包(package)是提供一系列功能的一个或者多个crate。一个包会包含Cargo.toml文件，阐述如何去创建这些crates。Cargo就是一个包含构建你代码的二进制项的包。Cargo也包含这些二进制项所依赖的库。其他项目也能用Cargo库来实现与Cargo命令行程序一样的逻辑。</p>
<p>包可以包含很多二进制(binary) crate，但是最多只能有一个库(library) crate。包无论是一个库(library crate)还是一个二进制库(binary crate)， 至少要包含一个library crate。</p>
<p>让我们来看看创建包的时候会发生什么。首先，我们输入命令<code>cargo new</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new my-project</span></span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project/src</span></span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>运行<code>cargo new</code>之后，我们使用<code>ls</code>查看Cargo创建了什么，在这个项目目录里，Cargo会给我们创建一个Cargo.toml文件，这就是一个包(package)。这里也有一个src目录包含main.rs文件。用编辑器打开Cargo.toml，并且文件内容里面没有提及src&#x2F;main.rs。因为Cargo遵循的一个约定：src&#x2F;main.rs就是一个与包同名的二进制crate的crate根。同样地，Cargo知道如果包目录中包含src&#x2F;lib.rs，则包带有与其同名的库(library) crate。crate根文件将由Cargo传递给<code>rustc</code>来构建库(library)或者二进制(binary)。</p>
<p>这里，我们有一个只包含src&#x2F;main.rs的包，意味着它只含有一个名为<code>my-project</code>的二进制crate。如果一个包同时含有src&#x2F;main.rs和src&#x2F;lib.rs，则它有两个crate：一个二进制(binary)的和一个库(library)，并且名字都与包相同。通过将文件放在src&#x2F;bin目录下，一个包可以拥有多个二进制crate：每个src&#x2F;bin下的文件都会被编译成一个独立的二进制crate。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.02:在模块中对相关代码进行分组(Grouping Related Code in Modules)</title>
    <url>/2023/05/18/rust_docs/ch_07_02_defining_modules_to_control_scope_and_privacy/</url>
    <content><![CDATA[<h4 id="在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules"><a href="#在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules" class="headerlink" title="在模块中对相关代码进行分组(Grouping Related Code in Modules)"></a>在模块中对相关代码进行分组(Grouping Related Code in Modules)</h4><p>模块让我们在crate中组织代码，以提高可读性和易于重用。模块还允许我们控制items的私有性，因为在module中的代码默认是私有的。Private items是内部实现的细节不对外使用。我们可以选择将模块以及其中的items设置为公共的，这样，外部代码就可以使用并依赖于它们。</p>
<p>例如，让我们编写一个提供餐厅服务功能的library crate。我们将会定义函数的签名，但是函数的主题留空，集中于代码的组织，而不是实现一个餐馆。</p>
<p>在餐厅业中，餐馆的某些部分被称为前台(front of house)，其他的部分称为后台(back of house)。前台是顾客所在的空间；这包括主座的顾客的位置，服务员接单和付款，以及调酒师调酒的地方。后台是主厨和厨师们在厨房，洗碗机清理，经历做行政工作。</p>
<p>这样构建我们的crate，我们可以将这些功能组织成嵌套的模块。创建一个新的库(library)命名为<code>restaurant</code>，通过命令<code>cargo new restaurant --lib</code>。输入如下Listing 7-1代码到src&#x2F;lib.rs来定义一些模块和函数签名。这里是前台部分：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-1: A <code>front_of_house</code>module containing other modules that then contain functions</p>
<p>我们用<code>mod</code>关键字定义一个模块(在上面的例子中定义了<code>front_of_house</code>模块)。并用花括号包围模块的主体。在模块内，我们还可以定义其他模块，就像本例子中的<code>hosting</code>和<code>serving</code>模块。模块还可以hold一些定义的其他items，例如structs, enums, constants, traits, 以及Listing 7-1中的函数。</p>
<p>通过使用模块，我们可以将相关的定义分组到一起，并指出他们为什么相关。程序设计者可以通过使用这段代码，更加容易找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序设计者向这段代码中添加一个新功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p>
<p>在前面我们提到了，<code>src/main.rs</code>和<code>src/lib.rs</code>叫做crate根。之所以这么叫它们是因为这两个文件中的任何一个内容都在crate模块结构的根组成了一个名为crate的模块，该结构被称为模块树(module tree)。</p>
<p>Listing 7-2 展示了示例Listing 7-1中的模块树(modules tree)的结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<p>Listing 7-2: The module tree for the code in Listing 7-1</p>
<p>这个模块树展示了一些模块内嵌到另一个模块；例如，<code>hosting</code>内嵌在<code>front_of_house</code>之中。这个树结构还展示了一些模块是互为兄弟(siblings)的，这意味着它们定义在同一模块中(<code>hosting</code>和<code>serving</code>被一起定义在<code>front_of_house</code>中)。继续沿用家庭关系的比喻，如果一个模块A被包含在模块B中，我们将模块A称为模块B的子模块，B模块为A的父模块。注意，整个模块树都植根于隐式模块名为<code>crate</code>之下。</p>
<p>模块树可能会让你想起计算机上的文件系统的目录树；这是一个非常恰当的比较！就像文件系统中的目录一样，你用模块来组织你的代码。就像文件目录中的文件，我们需要一个方式来找到我们的模块(modules)。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.03:创建公有的结构体和枚举(Making Structs and Enums Public)</title>
    <url>/2023/05/18/rust_docs/ch_07_03_paths_for_referring_to_an_item_the_the_module_tree/</url>
    <content><![CDATA[<h4 id="创建公有的结构体和枚举-Making-Structs-and-Enums-Public"><a href="#创建公有的结构体和枚举-Making-Structs-and-Enums-Public" class="headerlink" title="创建公有的结构体和枚举(Making Structs and Enums Public)"></a>创建公有的结构体和枚举(Making Structs and Enums Public)</h4><p>我们也可以使用<code>pub</code>来指定结构体和枚举为公有，但是这里有一些额外的使用详情需要注意。如果我们在使用<code>pub</code>定义一个结构体，我们使得这个结构体为公有，但是结构体的字段将仍是私有的。我们可以视情况而定让每一个字段成为公有或者私有。在Listing 7-9中，我们定义了一个公有的<code>back_of_house::Breakfast</code>结构体并且<code>toast</code>为公有字段，而<code>seasonal_fruit</code>为私有字段。该模型以餐厅为例，顾客可以选择随餐面包的类型，但是主厨会根据当季水果和库存来搭配什么水果。可选择的水果变化很快，所以顾客不能选择水果，甚至不能看到他们能得到的水果。</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next line won&#x27;t compile if we uncomment it; we&#x27;re not allowed</span></span><br><span class="line">    <span class="comment">// to see or modify the seasonal fruit that comes with the meal</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-9: A struct with some public fields and some private fields</p>
<p>因为<code>toast</code>字段在<code>back_of_house::Breakfast</code>结构体内是公有的，在<code>eat_at_restaurant</code>中我们可以编写并且读到<code>toast</code>字段使用点(.)号。注意，我们不能在<code>eat_at_restaurant</code>中使用<code>seasonal_fruit</code>字段，因为<code>seasonal_fruit</code>字段是私有的。尝试取消注释修改季节水果字段的值，看看会得到什么错误。</p>
<p>同样，注意因为<code>back_of_house::Breakfast</code>有一个私有字段，这个结构体需要提供一个公有的关联函数来构造一个<code>Breakfast</code>实例(这里是名为<code>summer</code>的函数)。如果<code>Breakfast</code>没有这样一个函数，我们就不能在<code>eat_at_restaurant</code>中创建<code>Breakfast</code>实例，因为我们不能在<code>eat_at_rest_aurant</code>中给<code>seasonal_fruit</code>私有字段设置值。</p>
<p>相反地，如果我们设置枚举为公有，它所有的字段都是公有的。我们只需要在<code>enum</code>关键字前面加上<code>pub</code>即可，如Listing 7-10所示：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-10: Designating an enum as public makes all its variants public</p>
<p>因为我们设置了<code>Appetizer</code>为公有枚举，我们可以在<code>eat_at_restaurant</code>中使用<code>Soup</code>和<code>Salad</code>成员变量。</p>
<p>除非设置枚举的变量为公开的，否则枚举就没什么用了；在每种情况下都必须使用<code>pub</code>来声明所有枚举变量，这将是很恼人的设计，所以默认情况下枚举的所有变量都是公有的。结构体在字段为私有的情况通常是有用的，所以结构体字段默认遵循所有内容为私有的普遍规则，除非使用<code>pub</code>声明公有。</p>
<p>这里还涉及<code>pub</code>另外一个情况我们没有讨论到，那就是我们最后要讲的模块功能：<code>use</code>关键字。我们将单独介绍<code>use</code>，然后展示如何结合<code>pub</code>和<code>use</code>起来使用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.04:全局操作符(The Glob Operator)</title>
    <url>/2023/05/18/rust_docs/ch_07_04_bringing_paths_into_scope_with_the_use_key_word/</url>
    <content><![CDATA[<h4 id="全局操作符-The-Glob-Operator"><a href="#全局操作符-The-Glob-Operator" class="headerlink" title="全局操作符(The Glob Operator)"></a>全局操作符(The Glob Operator)</h4><p>如果想将一个路径下所有公有项引入作用域，可以使用指定路径后跟<code>*</code>，glob操作符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<p>这个<code>use</code>语句会将<code>std::collections</code>中定义的所有的公有项引入到当前作用域。使用全局操作符时一定要多加小心！全局操作符会使得我们难以推导作用域中有什么名称和它们是定义在何处。</p>
<p>全局操作符经常用于测试模块<code>tests</code>中，这时会将所有内容引入作用域；我们将在第十一章”How to Write Tests”部分中讲解。全局操作符有时也用于preclude模式；查看”标准库文档”(<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes)%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%E3%80%82">https://doc.rust-lang.org/std/prelude/index.html#other-preludes)了解更多细节。</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.05:总结</title>
    <url>/2023/05/18/rust_docs/ch_07_05_separating_modules_into_different_files/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Rust提供了将包分成多个crate，将crate分成模块，以及通过指定绝对或者相对路径从一个模块引用另一个模块中定义的项的方式。你可以指定绝对路径或者相对路径。这个路径可以通过<code>use</code>声明引入到作用域，所以你可以在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加<code>pub</code>关键字使其定义为公有。</p>
<p>接下来，我们来看一些标准库提供的集合数据类型，你可以利用它们写出更漂亮整洁的代码。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.00:常见集合</title>
    <url>/2023/05/18/rust_docs/ch_08_00_common_collections/</url>
    <content><![CDATA[<h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>Rust标准库中包含一些非常有用的数据结构叫做结合(collections).大多数其他的数据类型代表一个特殊的值，但是集合可以包含多个值。不像内建的数组和元组类型，这些集合数据指向堆，意味着在编译时不需要知道数据量，并且可以随着程序运行而增加或减少。每一种集合有不同的性能和消耗，并且选择一个合适的集合，对你当前的情景是需要你慢慢学习的技巧。在本章，我们将会讨论三个集合，它们在Rust编程中很常用：</p>
<ul>
<li>vector 允许你一个挨着一个地存储一系列数量的可变的值</li>
<li>string 是一个字符类型的集合。我们之前已经提到过<code>String</code>类型，但是在本章，我们将更加深入地讨论它。</li>
<li>hash map 允许你用一个特定的key关联一个值(value)，它是成为映射的更通用数据结构的一种实现。</li>
</ul>
<p>要学习标准库提供的其他类型的集合，请查看文档<a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a></p>
<p>我们将要讨论如何创建和更新vectors, strings，和hash map，以及他们每个类型的独特之处。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.01:丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</title>
    <url>/2023/05/18/rust_docs/ch_08_01_vectors/</url>
    <content><![CDATA[<h4 id="丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements"><a href="#丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements" class="headerlink" title="丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)"></a>丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</h4><p>像其他数据结构一样，当一个vector离开了它的作用域，它就会被释放，如Listing 8-10所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 8-10: Showing where the vector and its elements are droped</p>
<p>当vector被删除时，它的所有内容也会被删除，这意味着它所持有的整数将被清除。借用检查器确保仅在vector本身有效时才使用对向量内容的任何引用。</p>
<p>接下来，我们将学习下一个集合类型：<code>String</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.02:字符串并不简单</title>
    <url>/2023/05/18/rust_docs/ch_08_02_strings/</url>
    <content><![CDATA[<h4 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a>字符串并不简单</h4><p>总之，字符串是很复杂的。不同的语言会有不同的选择如何将这种复杂性呈现给程序员。Rust选择将String数据的正确处理作为所有Rust程序的默认行为,这意味着程序员必须在处理UTF-8数据上花更多的心思。这个权衡在其他编程语言中暴露了更多字符串的复杂性,但它可以防止你在开发生命周期的后期处理涉及非ASCII字符的错误。<br>好消息是标准库基于String和&amp;str类型提供了许多功能来正确处理这些复杂的情况。确保查看文档中有用的方法,比如在字符串中搜索的contains和用另一个字符串替换字符串的一部分replace。<br>让我们切换到略微简单一点的内容:哈希映射!</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.03:总结</title>
    <url>/2023/05/18/rust_docs/ch_08_03_hash_maps/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vector、字符串和哈希 map 会在你的程序需要储存、访问和修改数据时帮助你。这里有一些你应该能够解决的练习问题:</p>
<ul>
<li>给定一系列数字，使用 vector 并返回这个列表的中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希 map 会很有帮助）。</li>
<li>将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加 “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码！</li>
<li>使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字典序排列的列表。</li>
</ul>
<p>标准库 API 文档中描述的这些类型的方法将有助于你进行这些练习！</p>
<p>我们已经开始接触可能会有失败操作的复杂程序了，这也意味着接下来是一个了解错误处理的绝佳时机！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.00:错误处理</title>
    <url>/2023/05/18/rust_docs/ch_09_00_error_handing/</url>
    <content><![CDATA[<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在软件中错误是很常见的事实。当有时候软件运行错误的时候，Rust有很多处理这些场景的特性。在很多情况下，Rust要求你确认每一个错误发生的可能，并在代码编译前就采取相应的行为。这个必要前提会让你的程序更加健壮：确保你会提前发现错误，并处理得当，在你将代码部署到生产环境之前。</p>
<p>Rust将错误分为两大类：<strong>可恢复的</strong>(<code>recoverable</code>)和<strong>不可恢复的</strong>(<code>unrecoverable</code>)。对于可恢复错误，比如文件未找打错误，我们很可能只是想向用户报告问题并重试操作。不可恢复错误总是系统性bugs，像尝试访问一个超过数组最尾端的位置，此时，我们就会想要程序立刻停止运行。</p>
<p>大多数编程语言无法区分这两种错误，并且都使用同样的方式，使用如exceptions机制。Rust没有exceptions。而是有一个<code>Result&lt;T, E&gt;</code>的类型来处理可恢复错误。另外，当程序发生一个不可恢复的错误，Rust用<code>panic!</code>宏来中止运行程序。</p>
<p>这一章，首次讨论<code>panic!宏</code>，然后讨论有关<code>Result&lt;T, E&gt;</code>返回的值。</p>
<p>另外，我们还要探索如何决定一个错误应该是恢复或者是停止运行。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.01:使用`panic!`的backtrace</title>
    <url>/2023/05/18/rust_docs/ch_09_01_unrecoverable_errors_with_panic/</url>
    <content><![CDATA[<h4 id="使用panic-的backtrace"><a href="#使用panic-的backtrace" class="headerlink" title="使用panic!的backtrace"></a>使用<code>panic!</code>的backtrace</h4><p>让我们来看看另外一个例子，当因为我们自己的代码有bug而导致库函数调用<code>panic!</code>是什么样的。如Listing 9-1所示的代码尝试访问超出范围的vector的索引。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 9-1: Attempting to access an element beyond the end of a vector, which will cause a call to <code>panic!</code></p>
<p>这里，我们尝试去访问第100个元素(索引99就是第100个元素，索引是从0开始的)，但是vector只有3个元素，肯定会报错。在这个场景中，Rust就会panic。使用<code>[]</code>就是企图返回一个元素，但是你传入一个无效的索引，又不会有这个元素，Rust就肯定不会返回正确的结果。</p>
<p>在C语言中，尝试读取数据结构之后的值是未定义行为(undefined behavior)。你可能会得到一个这个位置的对应的值，但是这个可能是任何的值，但就不是你想要访问的值，因为这个位置的值不属于你想要访问的数据结构范围的值。这个被叫做**缓冲区溢出(buffer overread)**，并且可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取存储在数据结构之后不被允许访问的数据。</p>
<p>为了防止这种漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下的错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (file:<span class="comment">///projects/panic)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.27</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>上面的错误信息指出错误发生在<code>src/main.rs</code>文件的第4行第5个字符，我们尝试访问索引为99的元素。接着一行的信息告诉我们可以设置<code>RUST_BACKTRACE</code>环境变量来获取backtrace查看发生了什么错误。一个backtrace是一个已经被调用直到当前这一个点的所有的函数列表。Backtrace在Rust的工作原理和其他语言一样：阅读backtrace的关键是从头开始读一直到发现你编写的代码；往下则是你调用的代码。这些行可能包含核心Rust代码，标准库代码或用到的crate代码。让我们设置<code>RUST_BACKTRACE</code>环境变量在Listing 9-2中看看都输出了些什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:<span class="number">584</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">142</span>:<span class="number">14</span></span><br><span class="line">   <span class="number">2</span>: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">84</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">3</span>: &lt;<span class="type">usize</span> <span class="keyword">as</span> core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">242</span>:<span class="number">10</span></span><br><span class="line">   <span class="number">4</span>: core::slice::index::&lt;<span class="keyword">impl</span> <span class="title class_">core</span>::ops::index::Index&lt;I&gt; <span class="keyword">for</span> [T]&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">18</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">5</span>: &lt;alloc::vec::<span class="type">Vec</span>&lt;T,A&gt; <span class="keyword">as</span> core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/<span class="keyword">mod</span>.rs:<span class="number">2591</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">6</span>: panic::main</span><br><span class="line">             at ./src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure>

<p>Listing 9-2: The backtrace generated by a <code>panic!</code>displayed when the environment variable <code>RUST_BACKTRACE</code>is set</p>
<p>真是输出了一大坨啊！操作系统不同，Rust版本不同，你看到的输出可能会有所不同。为了使用这些信息进行回溯，必须启用debug模式。默认就是debug模式，只要在<code>cargo build</code>或者<code>cargo run</code>之后不要加<code>--release</code>参数。</p>
<p>在Listing 9-2的第6行的backtrace指出了我们项目造成的问题：<code>src/main.rs</code>的第4行。如果我们不想我们的程序panic，我们就应该开始检查定位到第一行我们自己写的代码。在Listing 9-1中，我们故意写了造成panic的代码，修复这个panic就是不要去访问超出vector范围的索引。当你的代码在将来panic， 你需要弄清楚代码使用什么数据做了什么样的操作，以及正确情况下代码应该做什么。</p>
<p>本章后面的小节 <a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> Or not to <code>panic!</code>“</a> 部分讲回<code>panic!</code>，详细讲解应该或者不应该用<code>panic!</code>来处理错误情况。接下来一节我们来讲解如何使用<code>Result</code>恢复一个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.02:带有结果的可恢复错误</title>
    <url>/2023/10/18/rust_docs/ch_09_02_recoverable_errors_with_result/</url>
    <content><![CDATA[<h3 id="带有结果的可恢复错误"><a href="#带有结果的可恢复错误" class="headerlink" title="带有结果的可恢复错误"></a>带有结果的可恢复错误</h3><p>大多数错误并不严重到需要程序完全停止。有时，当一个函数失败时，其原因可以很容易地解释和响应。例如，如果您尝试打开一个文件，但由于该文件不存在而导致该操作失败，那么您可能希望创建该文件，而不是终止该进程。</p>
<p>回到第二章<code>Result</code>的枚举定义里，有两个成员，<code>Ok</code> 和<code>Err</code>,如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>和<code>E</code>是泛型参数：我们将在第十章详细讨论。目前你需要知道当成功时返回枚举成员<code>Ok</code>，当失败时返回枚举成员<code>Err</code>。由于<code>Result</code>具有这些泛型类型参数，因此我们可以在许多不同的情况下使用<code>Result</code>类型及其上定义的函数，其中我们希望返回的成功值和错误值可能不同。</p>
<p>我们来调用一个返回值类型为<code>Result</code>的函数，因为调用可能会失败。如Listing 9-3我们尝试打开一个文件。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">opend</span>(<span class="string">&quot;hello.txt);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Listing 9-3 Openging a file</p>
<p><code>File::open</code>的返回值是一个<code>Result&lt;T, E&gt;</code>。泛型参数<code>T</code>已经被<code>File::open</code>实现，并填入了成功的值，<code>std::fs::File</code>是一个文件句柄(file handle)。类型<code>E</code>的错误值是<code>std::io::Error</code>。<code>File::open</code>返回类型意思是如果成功就会返回一个文件句柄，并且可以进行读写。这个函数也有可能会调用失败：例如，文件不存在，或者没有权限访问。<code>File::open</code>函数需要有个方式告诉我们是成功或者失败，同时返回给我们文件句柄或者错误信息。这个信息正是Result枚举所传达的。</p>
<p>因此，当<code>File::open</code>调用成功，变量<code>greeting_file_result</code>的值将会是成员<code>Ok</code>并包含一个文件句柄。如果失败，<code>greeting_file_result</code>就是一个<code>Err</code>的实例并包含更多错误信息来展示到底发生了什么错误。</p>
<p>我们需要在Listing9-3中根据<code>File::open</code>的返回值来添加额外的代码。如Listing9-4中所示，这是一个基本的<code>Result</code>的处理工具，就是使用<code>match</code>表达式（我们已经在第六章中讲过了）。<br>Filename:src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-4: Using a match expression to handle the <code>Result</code> variants that might be returned</p>
<p>请注意，与Option enum一样，<code>Result</code>枚举及其成员也通过prelude进入了作用域，因此我们不需要在匹配分支中的Ok和Err成员之前指定<code>Result::</code>。</p>
<p>当结果为<code>Ok</code>时，这段代码将返回<code>Ok</code>中的<code>file</code>，然后我们将该文件句柄值赋给变量<code>greeting_file</code>。在<code>match</code>之后，我们可以使用文件句柄进行读写了。<br><code>match</code>的另外一个分支就会从<code>File::open</code>中得到一个<code>Err</code>的值。在这个示例中，我们现在调用<code>panic!</code>宏(macro)。如果没有一个叫<code>hello.txt</code>的文件在当前文件夹，并且运行了这段代码，我们就会看到如下来自<code>panic!</code>宏的错误输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/error-handling`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;Problem opening the file: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:8:23</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>像往常一样，这个输出告诉我们哪里出了问题。</p>
<h4 id="匹配不同的错误-Matching-on-Different-Errors"><a href="#匹配不同的错误-Matching-on-Different-Errors" class="headerlink" title="匹配不同的错误(Matching on Different Errors)"></a>匹配不同的错误(Matching on Different Errors)</h4><p>Listing9-4无论<code>File::open</code>因为什么失败都会报<code>pannic!</code>错误。然而，我们希望针对不同的失败原因采取不同的行动：如果<code>File::open</code>失败是因为文件不存在，我们想创建一个文件并返回新文件的句柄。如果<code>File::open</code>失败是因为其他原因–比如，因为我们没有打开文件的权限–我们仍然和Listing9-4一样<code>panic!</code>。为此，我们在<code>match</code>内添加一个内部表达式，如Listing 9-5所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-5: Handling different kinds of errors in different ways</p>
<p><code>File::open</code>内部返回的<code>Err</code>的值<code>io::Error</code>，它是标准库提供的数据结构。这个数据结构有一个<code>kind</code>方法可以得到一个<code>io::ErrorKind</code>的值。枚举<code>io::ErrorKind</code>是标准库提供的，并且有不同类型的错误都对应着相应的io操作。我们使用的<code>ErrorKing::NotFound</code>枚举成员表明我们尝试打开一个不存在的文件。所以我们在<code>greeting_file_result</code>上匹配，但我们也在error.kind()上进行内部匹配。</p>
<p>我们希望在内部匹配中检查的条件是<code>error.kind()</code>返回的值是否为<code>ErrorKind</code>枚举的<code>NotFound</code>成员。如果是我，我们将尝试通过<code>File::create</code>创建文件，然而我们创建文件也有可能失败，在<code>match</code>内部我们需要第二个分支来处理。当文件不能创建，一个不同的错误就会被打印。<code>match</code>外部保持不变。因此，除文件不存在的情况之外都会报错。</p>
<h4 id="失败时-panic-的简写-unwrap-和-expect"><a href="#失败时-panic-的简写-unwrap-和-expect" class="headerlink" title="失败时 panic 的简写: unwrap 和 expect"></a>失败时 panic 的简写: unwrap 和 expect</h4><p><code>match</code> 已经很好用了，不过它可能有点冗长并且不总是能很好的表明其意图。<code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <code>unwrap</code>，它的实现就类似于Listing 9-4 中的 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们运行这段代码，并且<code>hello.txt</code>文件不存在，我们就会看到一个错误信息来自<code>unwrap</code>方法调用了<code>panic!</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:4:49</span><br></pre></td></tr></table></figure>
<p>同样，<code>expect</code>方法也可以自定义<code>panic!</code>的错误信息。使用<code>expect</code>而不是<code>unwrap</code>并提供友好的错误信息可以传达您的意图，并使跟踪<code>panic!</code>的来源更容易。<code>expect</code>的语法如下所示：<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;hello.txt should be included int this project&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以和使用<code>unwrap</code>一样使用<code>expect</code>来返回一个文件句柄或者调用<code>panic!</code>。错误信息通过<code>expect</code>调用<code>panic!</code>时传递，而不是<code>panic!</code>默认的错误信息，展示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;hello.txt should be included in this project: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:5:10</span><br></pre></td></tr></table></figure>
<h4 id="传递错误-Propagating-Errors"><a href="#传递错误-Propagating-Errors" class="headerlink" title="传递错误(Propagating Errors)"></a>传递错误(Propagating Errors)</h4><p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。<br>例如：Listing 9-6所示，一个函数读一个文件。如果文件不存在或者不能读，函数就会返回一些错误。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">usename_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">usename_file</span> = <span class="keyword">match</span> username_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> user_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-6: A function that returns errors to the calling code using <code>match</code></p>
<p>这个函数可以用更短的方式编写，但我们将从手动做很多事情开始，以探索错误处理;最后，我们将展示较短的方法。我们先看一下函数的返回类型：<code> Result&lt;String, io::Error&gt;</code> 。这意味着该函数返回一个类型的 <code>Result&lt;T, E&gt;</code> 值，其中泛型参数 <code>T</code> 已用具体类型填充，泛型类型已用具体类型 <code>String</code>填充，<code>E</code>用<code>io::Error</code>填充。</p>
<p>如果此函数成功且没有任何问题，则调用此函数的代码将收到一个<code>Ok</code>值，该值包含<code>String</code>此函数从文件中读取的username。如果此函数遇到任何问题，调用代码将收到一个 <code>Err</code> 值，该值包含包含有关问题所在的详细信息的实例 <code>io::Error</code> 。我们选择 <code>io::Error</code> 此函数的返回类型，因为这恰好是我们在此函数主体中调用的两个操作返回的错误值的类型： <code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数的主体从调用 <code>File::open</code> 函数开始。然后我们用类似于Listing 9-4 <code>match</code> 中的值来处理 <code>match</code> 该 <code>Result</code> 值。如果成功，模式 <code>File::open</code> 变量中的文件句柄将成为可变变量 <code>username_file</code> 中的值，函数将继续。在这种情况下 <code>Err</code> ，我们不是调用，而是使用 <code>return</code> 关键字提前完全返回函数，并从<code>File::open</code>返回的错误传递出去，模式匹配中的<code>e</code>作为该函数的错误值传递回调用 panic! 代码。</p>
<p>因此，如果我们在<code>username_file</code>中有一个文件句柄，那么该函数将在变量<code>username</code>中创建一个新的<code>String</code>，并调用<code>username_file</code>中文件句柄上的<code>read_to_string</code>方法来将文件的内容读入<code>username</code>。<code>read_to_string</code>方法也返回<code>Result</code>，因为它可能失败，即使<code>File::open</code>打开文件成功，读文件也有可能失败。所以我们需要另一个匹配来处理这个<code>Result</code>:如果<code>read_to_string</code>成功，那么我们的函数就成功了，我们从文件中返回username，这个username现在被<code>Ok</code>封装在<code>username</code>中。如果<code>read_to_string</code>操作失败，返回错误值的方式与处理<code>File::open</code>返回值的匹配中返回错误值的方式相同。然而，我们不需要显式<code>return</code>，因为这是函数中的最后一个表达式。</p>
<p>然后，调用该代码的代码将处理获取包含<code>username</code>的<code>Ok</code>值或包含<code>io::Error</code>的<code>Err</code>值。由调用代码决定如何处理这些值。如果调用代码得到一个<code>Err</code>值，它可能会调用<code>panic!</code>并使程序崩溃，使用默认username，或者从文件以外的其他地方查找username。我们没有足够的信息来了解调用代码实际尝试做什么，所以我们向上传播所有成功或错误信息，以便它正确处理。</p>
<p>这种传播错误的模式在Rust中非常常见，因此Rust为了方便起见提供了问号操作符<code>?</code>。</p>
<h4 id="传播错误的快捷方式-操作符"><a href="#传播错误的快捷方式-操作符" class="headerlink" title="传播错误的快捷方式:?操作符"></a>传播错误的快捷方式:<code>?</code>操作符</h4><p>如Listing9-7所示，实现了一个和Listing9-6相同的<code>read_username_from_file</code>的函数，但是使用了<code>?</code>操作来实现。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-7: A function that returns errors to the calling code using the &#96;?&#96;&#96; operator</p>
<p><code>?</code>操作符放置在<code>Result</code>值之后，其工作方式与Listing 9-6中为处理<code>Result</code>值而定义的匹配表达式几乎相同。如果<code>Result</code>的值为<code>Ok</code>，则该表达式将返回<code>Ok</code>中的值，程序将继续执行。如果该值为<code>Err</code>，则整个函数将返回<code>Err</code>，就像我们使用了<code>return</code>关键字一样，因此错误值将传播到调用代码。</p>
<p>Listing 9-6中的匹配表达式的作用与<code>?</code>操作符所做的事情:错误值有<code>?</code>在标准库中的<code>From</code>trait中定义了from函数，该函数用于将值从一种类型转换为另一种类型。什么时候<code>?</code>操作符调用<code>from</code>函数，接收到的错误类型被转换为当前函数返回类型中定义的错误类型。当函数返回一种错误类型来表示函数可能失败的所有方式时，即使部分可能因许多不同的方式而失败，这也是有用的。</p>
<p>例如，我们可以修改Listing 9-7中的<code>read_username_from_file</code>函数，使其返回一个自定义的错误类型<code>OurError</code>。如果我们还为<code>OurError</code>定义<code>impl From&lt;io::Error&gt;</code>，从<code>io::Error</code>构造<code>OurError</code>的实例，那么<code>?</code>操作符会在<code>read_username_from_file</code>函数体中将调用<code>from</code>并转换错误类型，而无需向函数中添加任何代码。</p>
<p>在Listing 9-7的上下文中，<code>?</code>在<code>File::open</code>调用的末尾将把<code>Ok</code>中的值返回给变量<code>username_file</code>。如果发生错误，<code>?</code>操作符将提前返回，并向调用代码提供任何<code>Err</code>值。同样的道理也适用于<code>?</code>在<code>read_to_string</code>调用结束时。</p>
<p><code>?</code>操作符消除了大量的模板代码，使这个函数的实现更简单。我们甚至可以通过在<code>?</code>之后立即连接方法调用来进一步缩短代码，如Listing 9-8所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-8: Chaining method calls after the <code>?</code> operator</p>
<p>我们将<code>username</code>中<code>String</code>的创建移到了函数的开头;这一点没有改变。我们没有创建一个可变的用户名文件，而是将<code>read_to_string</code>调用直接连接到<code>file::open(&quot;hello.txt&quot;)</code>的结果上。我们还有<code>?</code>当<code>File::open</code>和<code>read_to_string</code>都成功时，我们仍然返回一个包含<code>username</code>的<code>Ok</code>值，而不是返回错误。功能与Listing 9-6和Listing 9-7相同;这是一种不同的，更符合工程学的写法。</p>
<p>Listing 9-9 所示使用了<code>fs::read_to_string</code>将使代码更加简短。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-9: Using <code>fs::read_to_string</code> instead of opening and then reading the file</p>
<p>将文件读入字符串是一种相当常见的操作，因此标准库提供了方便的<code>fs::read_to_string</code>函数，该函数打开文件，创建一个新的<code>String</code>，读取文件的内容，将内容放入该<code>String</code>，并返回它。当然，使用<code>fs::read_to_string</code>并不能让我们有机会解释所有的错误处理，所以我们先用更长的方法来解释。</p>
<h4 id="哪里可以使用-操作"><a href="#哪里可以使用-操作" class="headerlink" title="哪里可以使用?操作"></a>哪里可以使用<code>?</code>操作</h4><p><code>?</code>操作符只能用于返回类型与<code>?</code>操作符兼容的函数中。这是因为<code>?</code>操作符的定义是执行从函数中提前返回一个值，方式与Listing 9-6中定义的<code>match</code>表达式相同。在Listing 9-6中，匹配使用一个<code>Result</code>值，而提前返回臂返回一个<code>Err(e)</code>值。函数的返回类型必须是<code>Result</code>，以便与此返回兼容。</p>
<p>在Listing 9-10中，让我们看看如果使用<code>?</code>返回类型与我们使用的值的类型不兼容的主函数中的操作符<code>?</code>:<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-10: Attempting to use the <code>?</code> in the <code>main</code> function that returns &#96;()&#96;&#96; won’t compile</p>
<p>这段代码打开一个文件，可能会失败。<code>?</code>操作符在<code>File::open</code>返回的<code>Result</code>值之后，但是这个主函数的返回类型是<code>()</code>，而不是<code>Result</code>。当我们编译这段代码时，会得到以下错误消息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:48</span></span><br><span class="line">  |</span><br><span class="line">3 | fn main() &#123;</span><br><span class="line">  | --------- this function should return `Result` or `Option` to accept `?`</span><br><span class="line">4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">  |                                                ^ cannot use the `?` operator in a function that returns `()`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `error-handling` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个错误指出我们只允许使用<code>?</code>返回<code>Result</code>、<code>Option</code>或其他实现<code>FromResidual</code>的类型的函数中的操作符。</p>
<p>要修复这个错误，您有两种选择。一种选择是更改函数的返回类型，使其与使用的值兼容。只要没有限制，就继续操作。另一种技术是使用<code>match</code>或<code>Result&lt;T, E&gt;</code>方法之一，以任何合适的方式处理<code>Result&lt;T, E&gt;</code>。</p>
<p>错误信息中还提到<code>?</code>也可以与<code>Option&lt;T&gt;</code>值一起使用。就像使用<code>?</code>在<code>Result</code>中，您只能使用<code>?</code>在返回一个<code>Option</code>的函数中使用<code>Option</code>。<code>?</code>操作符在<code>Option&lt;T&gt;</code>上调用时的行为与在<code>Result&lt;T, E&gt;</code>上调用时的行为相似:如果值为<code>None</code>，则在该点将提前从函数返回<code>None</code>。如果值是<code>Some</code>，则<code>Some</code>中的值是表达式的结果值，函数继续执行。Listing 9-11给出了一个函数示例，该函数查找给定格式中第一行的最后一个字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;Hello, world\nHow are you today?&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;\nhi&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-11: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code> value</p>
<p>这个函数返回<code>Option&lt;char&gt;</code>，因为有可能有字符，但也有可能没有。这段代码接受<code>text</code>字符串切片参数并对其调用<code>lines</code>方法，该方法返回一个遍历字符串中的行的迭代器。因为这个函数想要检查第一行，所以它在迭代器上调用<code>next</code>以从迭代器中获取第一个值。如果<code>text</code>是空字符串，对<code>next</code>的调用将返回<code>None</code>，在这种情况下我们使用<code>?</code>停止并从第一行的最后一个字符返回<code>None</code>。如果<code>text</code>不是空字符串，<code>next</code>将返回一个<code>Some</code>值, 其中包含<code>text</code>中第一行的字符串切片。</p>
<p><code>?</code>操作符提取字符串切片，然后调用该字符串切片上的<code>chars</code>来获取其字符的迭代器。我们对第一行的最后一个字符感兴趣，因此调用<code>last</code>来返回迭代器中的最后一项。这是一个选项，因为第一行可能是空字符串，例如，如果文本以空行开头，但在其他行上有字符，如<code>“\nhi”</code>。但是，如果第一行有最后一个字符，它将在<code>Some</code>变体中返回。<code>?</code>运算符在中间给了我们一种简洁的方式来表达这个逻辑，允许我们实现</p>
<p>注意，您可以使用<code>?</code>操作符对返回<code>Result</code>的函数中的<code>Result</code>进行操作，您可以使用?操作符在返回<code>Option</code>的函数中对<code>Option</code>进行操作，但不能混合匹配。<code>?</code>操作符不会自动将<code>Result</code>转换为<code>Option</code>，反之亦然;在这些情况下，您可以使用诸如<code>Result</code>上的<code>ok</code>方法或<code>Option</code>上的<code>ok_or</code>方法来显式地进行转换。</p>
<p>到目前为止，我们使用的所有主要函数都是<code>return()</code>。<code>main</code>函数的特殊之处在于它是可执行程序的入口和出口点，它的返回类型是有限制的，这样程序才能按照预期的方式运行。</p>
<p>幸运的是，<code>main</code>也可以返回<code>Result&lt;()， E&gt;</code>。Listing 9-12拥有Listing 9-10的代码，但我们将<code>main</code>的返回类型更改为<code>Result&lt;()</code>， <code>Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加返回值<code>Ok(())</code>。这段代码现在可以编译了:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-12: Changing main to return <code>Result&lt;(), E&gt;</code> allows the use of the <code>?</code> operator on <code>Result</code> values</p>
<p><code>Box&lt;dyn Error&gt;</code>类型是一个<code>trait</code>对象，我们将在第17章使用允许不同类型值的<code>trait</code>对象一节中讨论它。现在，您可以读取<code>Box&lt;dyn Error&gt;</code>来表示任何类型的错误。使用<code>?</code>允许在错误类型为<code>Box&lt;dyn error &gt;</code>的主函数中返回<code>Result</code>值，因为它允许提前返回任何<code>Err</code>值。即使这个主函数的主体只会返回<code>std::io::Error</code>类型的错误，通过指定<code>Box&lt;dyn Error&gt;</code>，即使将返回其他错误的更多代码添加到main的主体中，该签名仍然是正确的。</p>
<p>当<code>main</code>函数返回<code>Result&lt;()， E&gt;</code>时，如果<code>main</code>函数返回<code>Ok(())</code>，可执行程序将以<code>0</code>的值退出;如果<code>main</code>函数返回<code>Err</code>值，可执行程序将以非<code>0</code>的值退出。用C编写的可执行程序在退出时返回整数:成功退出的程序返回整数<code>0</code>，出错的程序返回非0的整数。Rust还从可执行文件返回整数，以与此约定兼容。</p>
<p>main函数可以返回任何实现<code>std::process::Termination</code> trait的类型，它包含一个可以返回<code>ExitCode</code>的函数<code>report</code>。有关为您自己的类型实现<code>Termination</code>特性的更多信息，请参阅标准库文档。</p>
<p>到现在，我们已经详细讨论了调用<code>panic!</code>或者返回<code>Result</code>。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么看到别人过得好，我就心里好难受呢？</title>
    <url>/2023/08/18/rust_docs/why/</url>
    <content><![CDATA[<h3 id="为什么看到别人过得好，我就心里好难受呢？"><a href="#为什么看到别人过得好，我就心里好难受呢？" class="headerlink" title="为什么看到别人过得好，我就心里好难受呢？"></a>为什么看到别人过得好，我就心里好难受呢？</h3><p>早上刚来到公司，一个深圳有房，长得高又帅，身价已然超过95%深圳人的同事发出这样的灵魂拷问：为什么看到别人过得好，我就心里好难受呢？</p>
<h4 id="来看看AI如何看待："><a href="#来看看AI如何看待：" class="headerlink" title="来看看AI如何看待："></a>来看看AI如何看待：</h4><blockquote>
<p>根据你的描述,你已经达到了生活物质上很高的满足度,拥有自己的房产,生活质量远超过大多数人。但即便如此,看见别人过得很好,你还是会感到心理难受。这主要还是出于以下几个原因:</p>
<ol>
<li>心理比较并不会随着物质生活的提高而消失。人们的社会比较心理往往与生活状态相关不大,更加源自内在的不安全感。所以即便生活质量很高,这种比较心理仍然存在。</li>
<li>你可能理想化别人拥有的东西。比如羡慕别人拥有的人际关系,职业成就,生活状态等,而忽视了自己已经拥有的很多东西。这也会带来难受的感觉。</li>
<li>你期望得到的不仅是物质生活。人的内心渴望往往不仅限于物质层面,也包括精神层面,如获得认同,建立亲密关系,实现自我价值等。如果这些方面没有得到满足,也会感到心理上的难受。</li>
<li>你可能在某些方面感到不满意。尽管生活总体质量很高,但在情感生活,人际交往,事业发展等某一具体方面,你可能还是感到不如意或不足,这也是产生难受心理的原因之一。<br>所以,要解决这个问题,重点不在于提高生活质量,而是要在心理和精神层面获得安定。学会理性看待他人,不必过度羡慕别人所拥有的一切。关注自己的内心真实需求,努力在各个方面获得满足和进步。培养自己独立稳定的心态,增强自我价值感。这些可以有效地帮助你摆脱这种由社会比较所带来的难受情绪。</li>
</ol>
</blockquote>
<p>根据我党的判断，我们现在仍处于社会主义初级阶段，现阶段中国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。也是涵盖了上述矛盾心理内涵的。近些年，特别是改革开放之后，中国高速发展，让一部分人抓住了高速发展的红利，以不匹配自己能力增长的速度拥有了超速增长的财富和资产。即身心发展和财富发展并不平衡，导致了内心不够充盈，格局尚未完全打开，自我定位错乱。矛盾逐渐凸显扭曲就会发生这样莫名奇怪的心理。</p>
<p>实际上，在深圳这种高度发达，贫富差距巨大的快节奏生活的城市，大部分年轻人都特别焦虑，焦虑的本质就是日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。大部分年轻人都是来自外地十八线小城市或者小县城，或者农村。回不去，留不下随着时间的推移，越来越焦虑。这部分人特别像小资产阶级的表现：</p>
<blockquote>
<p>作为劳动者，在思想上倾向于无产阶级，作为私有者，又倾向于资产阶级，极易受资产阶级思想的影响。因此，在反对封建主义的斗争中既具有革命性，同时也存在政治上的动摇性、斗争中的软弱性和革命的不彻底性。</p>
</blockquote>
<p>让我想起了抓猴子的故事里伸手进树洞紧紧抓住坚果，即使猎人来了也舍不得放手。这个猴子是我们每个人。</p>
<p>对于这种外因短时间无法改变的问题，我们只能改变内因了。看看AI又会给出什么样的建议呢？</p>
<blockquote>
<p>这里有些简单实用的建议可以帮助你摆脱由社会比较带来的难受心理:</p>
<ol>
<li>转移注意力。当你开始羡慕别人或感到自卑时,立即转移注意力,不要过多聚焦在别人身上。可以换个环境,做点运动,转而关注自己喜欢的事物。这可以有效地改变心情。</li>
<li>记录自己的收获。时常记录自己生活中已经实现的小成就和收获,提醒自己生活的美好之处。这可以建立信心,也让你意识到自己已经拥有很多。</li>
<li>限制社交媒体使用。社交媒体上人们主要分享生活的美好时刻,这会助长羡慕心理。适当限制使用社交媒体,关注生活中真实的一面。</li>
<li>珍惜你所拥有的。时常想想你已经拥有但当作理所当然的东西,会让你觉得很满足和幸运。这可以避免过度关注别人拥有的。</li>
<li>关注自己的需求。理解自己真正想要什么,并努力实现,这可以让你没有时间和精力过度关注别人,也会让你感到人生有目标和意义。</li>
<li>施比受更有福。当你羡慕别人时,想想你能为别人带来什么好处。关注别人的需求,提供帮助,这可以让你转移注意力,也会带来成就感。</li>
<li>培养内在安定。通过冥想,听音乐,上瑜伽课等方式,培养安定的心态。当内心足够安定,外界的比较就不会那么轻易影响你。<br>这些实用的方法,帮助调节心态,关注自我,减少对他人生活的过度比较,可以有效地让你摆脱社会比较带来的难受情绪。需要时间去实践,但效果会非常显著。</li>
</ol>
</blockquote>
<p>这些方法对我都很有启发，对与解决自身的焦虑也很受用。生活在快节奏的深圳，周围人都是狠角色，焦虑对每个人来说是常态。人生的各个阶段也会有不同的焦虑，只有学会面对焦虑，利用焦虑，焦虑也可以是人类进步的助推器。加油吧，少年郎！</p>
]]></content>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>Growth and Government</title>
    <url>/2023/11/24/sam_altman/growth-and-government/</url>
    <content><![CDATA[<p>这是一篇11年前于2013年3月5日,山姆 奥特曼写的一篇探讨了经济增长和政府的关系。他认为，政府可以在某些情况下促进经济增长，但在其他情况下，政府的干预可能会阻碍经济增长。</p>
<p>作者提到，政府可以通过提供教育和基础设施来促进经济增长，这些投资可以帮助提高人们的技能和生产力，并促进创新。此外，政府还可以通过减少管制和税收来鼓励企业家精神和创新。</p>
<p>然而，作者也指出了政府过度干预可能会对经济产生负面影响。他认为，政府应该避免过度管制和税收，并确保市场能够有效地运作。如果政府过度干预市场，可能会导致资源的浪费和低效率。</p>
<p>总之，作者认为政府可以在某些情况下促进经济增长，但需要谨慎地权衡利弊，并确保市场能够自由运作。</p>
<h1 id="Growth-and-Government-增长与政府"><a href="#Growth-and-Government-增长与政府" class="headerlink" title="Growth and Government 增长与政府"></a>Growth and Government 增长与政府</h1><p>TL;DR Without economic growth, democracy doesn’t work because voters occupy a zero-sum system.<br>TL;DR：没有经济增长，民主就无法运作，因为选民占据的是零和博弈体系。</p>
<p>The first piece of startup wisdom I heard was “increasing your sales will fix all problems”.   This turns out to be another way of phrasing Paul Graham’s point that growth is critical, which is true for all sorts of reasons—for example, justifying high valuations to raise large amounts of capital in the early days, attracting the best people and paying them with equity, providing a buffer to allow for some mistakes, and smoothing over internal tensions.<br>我听到的第一条创业智慧是“增加销售额将解决所有问题”。  事实证明，这是保罗·格雷厄姆（Paul Graham）的观点的另一种表达方式，即增长至关重要，出于各种原因，这都是正确的——例如，在早期证明高估值以筹集大量资金是合理的，吸引最优秀的人才并以股权支付他们，提供缓冲以允许一些错误， 并抚平内部紧张局势。</p>
<p>I believe that growth is not only critical for startups, but for most systems.   Either you’re growing, or you’re slowly dying.  Perfect equilibrium is rare.<br>我相信增长不仅对初创公司至关重要，而且对大多数系统也至关重要。  要么你在成长，要么你在慢慢死去。 完美的平衡是罕见的。</p>
<p>One system that seems to be in early death throes is the United States government.  There’s a lot of political rancor, which is particularly puzzling when one considers that in the 2012 presidential election, Obama and Romney said roughly the same thing.  Dysfunction is high—the sequester, which was supposed to be so unpalatable it would never take effect, actually (and likely temporarily) happened last Friday because the parties couldn’t agree on an alternative. There’s a lot of arguing over insignificant issues—enough, in fact, to distract us from the fact that no one has new ideas on the big issues.  We have trillion dollar deficits and no plan to reduce them, and yet the media focus on the sideshows.<br>一个似乎处于早期死亡阵痛中的系统是美国政府。 有很多政治仇恨，当人们考虑到在2012年总统大选中，奥巴马和罗姆尼说了大致相同的话时，这尤其令人费解。 功能失调很严重——本来应该非常难吃以至于永远不会生效的隔离，实际上（而且可能是暂时的）发生在上周五，因为双方无法就替代方案达成一致。关于无关紧要的问题有很多争论——事实上，这足以分散我们的注意力，让我们忽视这样一个事实，即没有人对重大问题有新的想法。 我们有数万亿美元的赤字，但没有减少赤字的计划，但媒体却把注意力集中在杂耍上。</p>
<p>A good metric for government dysfunction is inability to pass a budget, either leading to a government shutdown or a continuing resolution, which lets agencies continue to operate on the previous budget, for a theoretically short time period until we can agree on a new one.  Passing a budget is a fundamental job of Congress and the President.<br>衡量政府功能失调的一个很好的指标是无法通过预算，要么导致政府关闭，要么导致持续决议，这让各机构在理论上很短的时间内继续按照以前的预算运作，直到我们能够就新的预算达成一致。 通过预算是国会和总统的一项基本工作。</p>
<p>As far as I can tell, the US government managed to make it about 200 years without any shutdowns.  We had one in 1976, and then a bunch more in the 70s and 80s, plus 3 in the 90s, including one that lasted 21 days.  Shutdowns have fallen out of fashion, and now we just operate with continuing resolutions, and lots of them—for example, 21 for the 2001 budget alone.  The real issue with shutdowns and continuing resolutions is the same—inability to agree on a federal budget.<br>据我所知，美国政府设法做到了大约 200 年而没有任何停工。 我们在 1976 年有一个，然后在 70 年代和 80 年代又有一堆，再加上 90 年代的 3 个，包括一个持续了 21 天。 停摆已经过时了，现在我们只是在持续的决议下运作，而且很多决议——例如，仅2001年预算就有21项决议。 关门和持续决议的真正问题是一样的——无法就联邦预算达成一致。</p>
<p>Every few months, there’s brief discussion of some sort of grand bargain, but it always ends in deferral—even the deferrals get deferred!  Everyone feels screwed, and almost no one feels like the government is doing a great job.   We can’t agree on anything, and anyone that proposes doing something radically different doesn’t get elected.<br>每隔几个月，就会有关于某种大交易的简短讨论，但它总是以推迟而告终——即使是推迟也会被推迟！ 每个人都觉得自己搞砸了，几乎没有人觉得政府做得很好。  我们无法就任何事情达成一致，任何提议做一些完全不同的事情的人都不会当选。</p>
<p>But democracy (I’m using democracy to include republics and other forms of government where the people get an effectively direct say in who the leaders are) worked in the US for a long time—we were able to make real progress, pass budgets, be the world superpower, evolve as a country, etc.  Something has changed.<br>但是民主（我用民主来包括共和国和其他形式的政府，人民对谁是领导人有有效的直接发言权）在美国工作了很长时间——我们能够取得真正的进步，通过预算，成为世界超级大国，作为一个国家发展，等等。 有些事情发生了变化。</p>
<p>The US has been blessed with economic growth for a very long time, first due to natural resources and massive amounts of land in which to expand, and then due to a period of technological progress rarely matched in human history that lasted approximately until we realized just how dangerous nuclear bombs really were and got scared of new technology.  But the frontier is long over, and although technological innovation has continued at a blistering rate for computers and the Internet, it seems to have slowed down in most other industries.<br>很长一段时间以来，美国一直享有经济增长的福气，首先是由于自然资源和大量可供扩张的土地，然后是由于人类历史上罕见的技术进步时期，这种进步大约持续到我们意识到核弹到底有多危险并害怕新技术。 但这个前沿早已结束，尽管计算机和互联网的技术创新继续以极快的速度发展，但在大多数其他行业似乎已经放缓。</p>
<p>Growth may be the root cause of American exceptionalism—things consistently got better every decade largely because we were growing.  People from other countries wanted to live here, we led the world in technological innovation, social mobility was high because everyone was getting richer, and we had the resources to get involved around the world.  This is still at least partially true.<br>增长可能是美国例外论的根本原因——情况每十年就会变得更好，这主要是因为我们在成长。 来自其他国家的人们想住在这里，我们在技术创新方面引领世界，社会流动性很高，因为每个人都越来越富有，我们有资源参与世界各地的活动。 这至少部分是正确的。</p>
<p>But growth has slowed quite a bit.  Here is a graph of real GDP percentage growth in the United States from 1950 until now, with a trendline.  The trendline goes from just under 5% to just under 2%.  This is a much more significant drop than it appears, because it compounds exponentially.<br>但增长已经放缓了不少。 这是一张从1950年至今美国实际GDP增长百分比的图表，并带有趋势线。 趋势线从略低于 5% 到略低于 2%。 这是一个比看起来要大得多的下降，因为它呈指数级复合。</p>
<div align="center"> <img src="/images/samaltman-medium_Ycc26Om.png"/></div>

<p>A shocking data point about how things are going is that the median real net worth for households headed by someone under 35 dropped 68% from 1984 to 2009, to $3,662.  For those over 65, it increased 42% to $170,494 (largely due to a gain in property values).  This disparity is good evidence of a lack of real growth (and also a very unstable situation where an older generation benefits at the expense of a younger).<br>关于事情进展的一个令人震惊的数据点是，从1984年到2009年，以35岁以下的人为户主的家庭的实际净资产中位数下降了68%，至3,662美元。对于65岁以上的人，它增加了42%，达到170,494美元（主要是由于房产价值的增加）。这种差距很好地证明了缺乏实际增长（也是一种非常不稳定的情况，即老一代人以牺牲年轻人为代价而受益）。</p>
<p>Here are two more graphs, the first showing the US unemployment rate (the real numbers are perhaps worse, as people drop out of the work force) and the second showing the US interest rate, both of which make a case for slowing growth:<br>这里还有两张图表，第一张显示美国失业率（实际数字可能更糟，因为人们退出劳动力市场），第二张显示美国利率，两者都表明经济增长放缓：</p>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_pa0IzIq.png"/></div>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_tXYg4oM.png.png"/></div>
All of that said, in absolute sense I’d much rather live in the world of today than 1950—it’s tough for me to imagine living in a world without the Internet.  However, in the same way that one can feel acceleration but not velocity, people seem more sensitive to the annual rate of improvement than the absolute quality of life.  So even though people should be happier in an absolutely better world, no one wants to stand still on the hedonic treadmill.
综上所述，从绝对意义上讲，我宁愿生活在今天的世界，而不是1950年——我很难想象生活在一个没有互联网的世界里。 然而，就像人们可以感觉到加速度但不能感觉到速度一样，人们似乎对每年的改善速度比绝对的生活质量更敏感。 因此，尽管人们应该在一个绝对更好的世界中更快乐，但没有人愿意在享乐的跑步机上停滞不前。

<p>Most of us want our lives to get better every year—the hedonic treadmill is a pain that way.  In a democracy, we theoretically vote for what we believe will improve our lives the most.  In a system with economic growth, things can improve for everyone.  In a system without growth, or even one with very little growth, that’s not the case—if things improve for me, it has to come at the expense of things getting worse for you.  Without growth, we’re voting against someone else’s interest as much as we’re voting for our own.  This ends with lots of fighting and everyone feeling screwed, broken into factions, and unmotivated.  Democracy does not work well in a zero-sum world.  Autocratic political systems probably work better with growth too, but the effect of a lack of growth is likely less pronounced right up until the revolution.<br>我们大多数人都希望我们的生活每年都变得更好——享乐跑步机就是这样一种痛苦。在民主国家，从理论上讲，我们会投票选出我们认为最能改善我们生活的东西。在一个经济增长的体系中，每个人都可以改善情况。在一个没有增长的系统中，甚至在一个几乎没有增长的系统中，情况并非如此——如果事情对我来说有所改善，那一定是以你变得更糟为代价的。没有增长，我们就是在投票反对别人的利益，就像我们投票支持自己的利益一样。这以大量的战斗结束，每个人都感到被搞砸了，分裂成派系，没有动力。民主在零和博弈的世界里运作不通。专制政治制度在增长方面可能也更有效，但缺乏增长的影响可能直到革命之前才那么明显。</p>
<p>So we need to get growth back, unless we want to see this grand experiment end.  Our politicians don’t seem to have any good ideas about how to do this.  Saying “I believe in America” and hoping that proof by vigorous assertion starts working is not a strategy.<br>因此，我们需要恢复增长，除非我们想看到这个伟大的实验结束。 我们的政客们似乎对如何做到这一点没有任何好主意。 说“我相信美国”，并希望通过有力的断言来证明开始起作用，这不是一种策略。</p>
<p>I believe democracy only works in a non-zero-sum world.  We are losing jobs that we will never get back, we are borrowing money and spending it on anything but real investment, and it feels like we are managing a slow decline.  Without growth, we will head towards a special case of Malthusian dystopia where we have plenty of junk food but not enough of anything else.<br>我相信民主只有在非零和博弈的世界中才能发挥作用。 我们正在失去永远无法挽回的工作，我们正在借钱并将其花在除实际投资之外的任何事情上，感觉我们正在缓慢下降。 没有增长，我们将走向马尔萨斯反乌托邦的一个特例，在那里我们有很多垃圾食品，但其他任何东西都不够。</p>
<p>Growth is what we should be focusing on.  Growth is great—it lets us run deficits, it means the country is not zero-sum, it lets us invest in innovation and continual improvement in infrastructure, it provides a buffer for a little mismanagement, and it means tomorrow will be better than today.  Contrary to what one might expect, growth provides long-term stability.<br>增长是我们应该关注的。 增长是伟大的——它让我们能够实现赤字，这意味着国家不是零和博弈，它让我们投资于创新和基础设施的持续改善，它为一点管理不善提供了缓冲，这意味着明天会比今天更好。 与人们的预期相反，增长提供了长期的稳定性。</p>
<p>We must return to real growth, growth where we do more with less.  Borrowing money to get ninety growth cents on the dollar does not count, although that may work for a while.  We have to figure out how to fix the real problems with technological innovation—cheaper and cleaner energy, better healthcare (15.2% of GDP in 2008 and 18.2% of GDP in 2011), better transportation, food production, and defense.  GDP growth is probably the only way to fix our national debt and entitlement problems, and it’d be better to have real growth than inflationary growth.<br>我们必须回归真正的增长，即我们用更少的资源做更多的增长。 借钱以获得90美分的美元增长不算数，尽管这可能会在一段时间内奏效。 我们必须弄清楚如何通过技术创新来解决真正的问题——更便宜、更清洁的能源、更好的医疗保健（2008年占GDP的15.2%，2011年占GDP的18.2%）、更好的交通、粮食生产和国防。 GDP增长可能是解决我们国家债务和福利问题的唯一途径，实际增长比通货膨胀增长要好。</p>
<p>How to best drive economic growth is a difficult question.  It’s easy to say we should just invest in science and technology, and although that’s probably right it’s easier said than done.  The government is historically bad at picking winners to invest in, but our leaders can perhaps help reverse the cultural shift from pro-science to anti-science.  Our current culture has shifted to be anti-science; the fear of things like genetically modified food and robots is obviously in the way of growth.<br>如何最好地推动经济增长是一个难题。 说我们应该投资科学技术很容易，虽然这可能是对的，但说起来容易做起来难。 从历史上看，政府不善于挑选赢家进行投资，但我们的领导人或许可以帮助扭转从亲科学到反科学的文化转变。 我们目前的文化已经转变为反科学;对转基因食品和机器人等事物的恐惧显然阻碍了增长。</p>
<p>We should strive to make jobs in science and technology more appealing than jobs in finance (incidentally, it should be a big red flag for growth when the brightest young people start going into finance, since they aren’t actually creating any more wealth, just redistributing it).  Startups are probably the best way to do this—startups let people that develop a new technology get rich, instead of just making GE slightly richer.  So we should encourage startups in whatever way we can.<br>我们应该努力使科学和技术领域的工作比金融领域的工作更具吸引力（顺便说一句，当最聪明的年轻人开始进入金融领域时，这应该是增长的一大危险信号，因为他们实际上并没有创造更多的财富，只是重新分配财富）。 创业公司可能是做到这一点的最好方式——创业公司让开发新技术的人致富，而不仅仅是让通用电气稍微富裕一点。 因此，我们应该尽我们所能鼓励创业公司。</p>
<p>Another issue is the structure of our national budget.  We have, in startup parlance, a high burn, and most of it can’t be considered ‘investment’ but is instead ‘expense’.  Spending money on things like infrastructure improvement or new technology that are likely to generate more money in the future helps growth; spending money on the so-called entitlement programs, and parts of the military, does not.  Of course medical care and defense are important, and we have to have them—this is a tough balancing act.  In some cases, the competitive nature of the private sector may provide a better path.  Sooner or later, we are going to have an ugly conversation about our national budget—we can delay it for a long time but not forever.  The government, when it needs to spend money at all, should aim to invest.  Considering what will drive growth is a useful framework for thinking about the best use of resources.<br>另一个问题是我国国家预算的结构。 用创业公司的话来说，我们有很高的消耗，其中大部分不能被视为“投资”，而是“费用”。 把钱花在基础设施改善或新技术等可能在未来产生更多资金的事情上有助于增长;把钱花在所谓的福利计划和部分军队上，则不会。 当然，医疗和防御很重要，我们必须拥有它们——这是一个艰难的平衡行为。 在某些情况下，私营部门的竞争性质可能提供更好的途径。 迟早，我们将就我们的国家预算进行一场丑陋的对话——我们可以推迟很长时间，但不会永远拖延。 当政府需要花钱时，它应该以投资为目标。 考虑什么将推动增长是思考资源最佳利用的有用框架。</p>
<p>We should not fear innovation or globalization.  Robots are going to replace human workers in lots of factories; jobs that do require human labor are going to continue to move to the lowest-cost place.  But that’s ok, and these sorts of jobs are not what will generate economic growth for us anyway.  We should strive to be a net exporter of ideas and technologies.  For example, the US makes the best software in the world today.  It’d be disastrous for us if that stopped happening.  We should also design the best supersonic jet engines, the best nuclear power plants, and the best agricultural technology.<br>我们不应该害怕创新或全球化。 机器人将取代许多工厂的人类工人;确实需要人力的工作将继续转移到成本最低的地方。 但这没关系，无论如何，这些工作都不会为我们带来经济增长。 我们应该努力成为思想和技术的净输出国。 例如，美国制造了当今世界上最好的软件。 如果这种情况停止发生，对我们来说将是灾难性的。 我们还应该设计最好的超音速喷气发动机、最好的核电站和最好的农业技术。</p>
<p>We should understand that as a consequence of technology and an economy of ideas, the gap between the rich and the poor will likely increase from its already high-seeming levels.  There is good and bad to this, but we should be careful not to legislate against it, which will hurt growth.   Technology magnifies differences in innate ability; startups provide a framework to get compensated for it.  But GDP growth ought to improve the quality of life for everyone, and no growth will reduce quality of life for everyone except the very rich.  A safety net for legitimately poor people is a good thing, and probably becomes more necessary in a world with this sort of divergence.  Quality of life should improve for everyone; the bigger issue will likely be that people are very sensitive to relative fairness.<br>我们应该明白，由于技术和思想经济，贫富差距可能会从已经很高的水平扩大。 这有好有坏，但我们应该小心，不要立法反对它，这会损害增长。  技术放大了先天能力的差异;初创公司提供了一个框架来获得补偿。 但GDP增长应该改善每个人的生活质量，除了富人之外，任何增长都不会降低每个人的生活质量。 为合法的穷人提供安全网是一件好事，在一个存在这种分歧的世界里，它可能变得更加必要。 每个人的生活质量都应该得到改善;更大的问题可能是人们对相对公平非常敏感。</p>
<p>Pro-growth tax and legal changes are a good idea.  As a consequence of a high burn rate, we have to have high taxes.  But other countries don’t have this structural challenge, and so some other countries have lower tax rates than we do.  That makes them an appealing place to start a business or live.  By reducing our burn rate, we can reduce taxes. We don’t need to go crazy here—there are a lot of other factors that make the US a very attractive place to start a new company.  But it would certainly help.  And tax policy should reward activity that drives growth.<br>促进增长的税收和法律变化是个好主意。 由于高烧钱率，我们必须征收高税。 但其他国家没有这种结构性挑战，因此其他一些国家的税率比我们低。 这使它们成为创业或居住的有吸引力的地方。 通过降低我们的燃烧率，我们可以减少税收。我们不需要在这里发疯——还有很多其他因素使美国成为创办新公司的非常有吸引力的地方。 但这肯定会有所帮助。 税收政策应该奖励推动增长的活动。</p>
<p>There are some easy legal changes we can make to increase growth.  Immigration for entrepreneurs and skilled technology workers is an obvious one; we should want the best people creating value here, not elsewhere in the world.  Tort reform is another—legal protection is of course important, but it’s gotten so silly that it discourages innovation.<br>我们可以做出一些简单的法律改变来促进增长。 企业家和熟练技术工人的移民是显而易见的;我们应该希望最优秀的人才在这里创造价值，而不是在世界其他地方。 侵权法改革是另一回事——法律保护当然很重要，但它变得如此愚蠢，以至于阻碍了创新。</p>
<p>There is a lot more we can do.  Most of it is difficult, but growth it is the critical issue.<br>我们可以做的还有很多。 其中大部分是困难的，但增长是关键问题。</p>
<p>As a closing thought, the Airbnb founders used to draw a forward-looking growth graph that they wanted to hit.  It was their number one priority; they put it up on their desks, on their refrigerator, and on the mirror in their bathroom.  You build what you measure, and they built growth.  That seemed to work pretty well for them.<br>最后，Airbnb的创始人曾经画出他们想要达到的前瞻性增长图。 这是他们的首要任务;他们把它放在桌子上、冰箱上和浴室的镜子上。 你建立你所衡量的东西，他们建立增长。 这对他们来说似乎很有效。</p>
<p>It’s not as easy if you’re the US government.  But probably not impossible, either, and it would at least point us in the right direction.<br>如果你是美国政府，那就没那么容易了。 但可能也不是不可能，它至少会为我们指明正确的方向。</p>
]]></content>
      <categories>
        <category>sam_altman</category>
      </categories>
      <tags>
        <tag>sam altman</tag>
      </tags>
  </entry>
  <entry>
    <title>Creational Design Patterns</title>
    <url>/2023/11/26/design-pattern/Creational-Design-Patterns/</url>
    <content><![CDATA[<h1 id="Creational-Design-Patterns-创建设计模式"><a href="#Creational-Design-Patterns-创建设计模式" class="headerlink" title="Creational Design Patterns 创建设计模式"></a>Creational Design Patterns 创建设计模式</h1><p>Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.<br>创建设计模式提供了各种对象创建机制，这些机制提高了灵活性和现有代码的重用性。</p>
<h2 id="Factory-Method-工厂方法"><a href="#Factory-Method-工厂方法" class="headerlink" title="Factory Method 工厂方法"></a>Factory Method 工厂方法</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/87KZ5eDmwjmWiKFEoA02lw">
    <img src="/images/factory-method-logo.png"/>
    Factory Method 工厂方法
    <a/>
</div>

<hr>
<h2 id="Abstract-Factory-抽象工厂模式"><a href="#Abstract-Factory-抽象工厂模式" class="headerlink" title="Abstract Factory 抽象工厂模式"></a>Abstract Factory 抽象工厂模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/ArraO8MpfdiSG7JiqJwZsQ">
    <img src="/images/abstract-factory-logo.png"/>
    Abstract Factory 抽象工厂模式
    <a/>
</div>

<hr>
<h2 id="Builder-建造者模式"><a href="#Builder-建造者模式" class="headerlink" title="Builder 建造者模式"></a>Builder 建造者模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/av15yLamVtV8D1bjLBxk4Q">
    <img src="/images/builder-logo.png"/>
    Builder 建造者模式
    <a/>
</div>

<hr>
<h2 id="Protopype-原型模式"><a href="#Protopype-原型模式" class="headerlink" title="Protopype 原型模式"></a>Protopype 原型模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/IG55Nn98d_PU382-VOGNhQ">
    <img src="/images/prototype-logo.png"/>
    Protopype 原型模式
    <a/>
</div>

<hr>
<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/Mpp-i9mm2KZsi4DPxZWLmg">
    <img src="/images/singleton-logo.png"/>
    Singleton 单例模式
    <a/>
</div>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者</title>
    <url>/2023/11/28/Remembering-Charlie-Munger/</url>
    <content><![CDATA[<h1 id="伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者"><a href="#伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者" class="headerlink" title="伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者"></a>伯克希尔·哈撒韦公司悼念查理·芒格：致敬一位伟大的领导者</h1><p><a href="https://www.berkshirehathaway.com/news/nov2823.pdf">November 28, 2023 News Release</a><br>伯克希尔·哈撒韦公司新闻发布</p>
<h1 id="NEWS-RELEASE-新闻发布"><a href="#NEWS-RELEASE-新闻发布" class="headerlink" title="NEWS RELEASE  新闻发布"></a>NEWS RELEASE  新闻发布</h1><h2 id="FOR-IMMEDIATE-RELEASE-立即发布-November-28-2023-2023年11月28日"><a href="#FOR-IMMEDIATE-RELEASE-立即发布-November-28-2023-2023年11月28日" class="headerlink" title="FOR IMMEDIATE RELEASE  立即发布       November 28, 2023  2023年11月28日"></a>FOR IMMEDIATE RELEASE  立即发布       November 28, 2023  2023年11月28日</h2><p>Omaha, NE (BRK.A; BRK.B) –  内布拉斯加州奥马哈（BRK.A; BRK.B）-</p>
<p>Berkshire Hathaway a few minutes ago was advised by members of Charlie Munger’s family<br>伯克希尔·哈撒韦公司几分钟前得到了查理·芒格家人的通知</p>
<p>that he peacefully died this morning at a California hospital.<br>他于今天早上在加利福尼亚的一家医院平静离世。</p>
<p>Warren Buffett, CEO of Berkshire Hathaway, wishes to say: “Berkshire Hathaway could not have been built to its present status without Charlie’s inspiration, wisdom and participation.”<br>伯克希尔·哈撒韦公司的首席执行官沃伦·巴菲特希望说：“没有查理的灵感、智慧和参与，伯克希尔·哈撒韦公司不可能建立到现在的地位。”</p>
<p>The family will handle all affairs pursuant to Charlie’s instructions.<br>芒格的家人将根据他的指示处理所有事务。</p>
<h1 id="About-Berkshire-关于伯克希尔"><a href="#About-Berkshire-关于伯克希尔" class="headerlink" title="About Berkshire  关于伯克希尔"></a>About Berkshire  关于伯克希尔</h1><p>Berkshire Hathaway and its subsidiaries engage in diverse business activities including insurance and reinsurance, utilities and energy, freight rail transportation, manufacturing, retailing and services.<br>伯克希尔·哈撒韦及其子公司从事多种业务活动，包括保险和再保险、公用事业和能源、货运铁路运输、制造、零售和服务。</p>
<p>Common stock of the company is listed on the New York Stock Exchange, trading symbols BRK.A and BRK.B.<br>该公司的普通股在纽约证券交易所上市，交易符号为BRK.A和BRK.B。</p>
<p>— END —  - 结束 -</p>
<p>Contact  联系人</p>
<p>Marc D. Hamburg  马克·汉堡</p>
<p>402-346-1400</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>财富创造机制目录</title>
    <url>/2023/12/01/a-catalog-of-wealth-creation-mmechanisms-translate/</url>
    <content><![CDATA[<h1 id="A-catalog-of-wealth-creation-mechanisms-财富创造机制目录"><a href="#A-catalog-of-wealth-creation-mechanisms-财富创造机制目录" class="headerlink" title="A catalog of wealth-creation mechanisms 财富创造机制目录"></a>A catalog of wealth-creation mechanisms 财富创造机制目录</h1><p>One of the guest lecturers aboard the ship [1] (Donald Gibbs, of Pearl-Harbor conspiracy-theory infamy) gave a very interesting talk a few days ago about some of China’s semi-recent history. He opened with a little pop-quiz, which I thought set the stage particularly well, so I’ll co-opt it here to make a different point:<br>船上的一位客座讲师（唐纳德·吉布斯，珍珠港阴谋论的臭名昭著）几天前做了一个非常有趣的演讲，关于中国半近代的一些历史。他以一个小测验开场，我认为这个小测验很好地搭建了舞台，所以我在这里选择它来说明一个不同的观点：</p>
<ol>
<li><p>Why was the Panama Canal built?<br>1.巴拿马运河为什么要建？</p>
</li>
<li><p>Why was the Lewis-and-Clark expedition funded?<br>2.为什么刘易斯和克拉克探险队得到资助？</p>
</li>
<li><p>Why was the transcontinental railroad built?<br>3.为什么要修建横贯大陆的铁路？</p>
</li>
</ol>
<p>The popular answer to these questions, taught to schoolchildren throughout the U.S., is: to link the east and west coasts of the United States. But that answer is wrong, as can be shown by examining historical records of the time. The real reason for all three of these mammoth endeavors was to link the east coast of the United States with China. And the reason for linking the east coast of the United States with China was that a ship full of goods from China (including, for example, high quality china with a lower-case ‘c’, which at the time was produced nowhere else) could be sold in the east-coast cities of the U.S. at about a 300% profit. The wealth created by this trade ultimately financed the industrialization of the U.S., so this is no mere historical trifle. (Bonus question: what did the U.S. give to China in exchange for its china?)<br>这些问题的普遍答案，教给美国各地的学童，就是：连接美国东西海岸。但是，这个答案是错误的，这可以通过检查当时的历史记录来证明。这三项猛犸工程的真实的原因是为了把美国东海岸与中国连接起来。连接美国东海岸和中国的原因是，一艘满载中国货物的船只（包括，例如，带有小写字母“c”的高质量瓷器，当时其他地方都没有生产）可以在美国东海岸城市出售，利润约为300%。这种贸易创造的财富最终为美国的工业化提供了资金，所以这不是历史的小事。（附加问题：美国给予什么来换取中国？）</p>
<p>But the point I want to draw attention to is that at the root of all wealth creation are a very few, very simple and easy-to-understand core mechanisms. It’s easy to lose sight of this in today’s complex technological world, so I thought I’d draw up a catalog of them.<br>但我想提请注意的一点是，所有财富创造的根源是一个非常简单和易于理解的核心机制。在当今复杂的技术世界中，很容易忽视这一点，所以我想我应该起草一份目录。</p>
<p>It’s important to keep in mind that there is a distinction between wealth and money. Wealth is a measure of how much stuff people have that they actually value for its own sake. Food, housing, clothing, shelter, and artwork, are all examples of wealth. Money, by way of contrast, is merely an accounting mechanism that humans have invented in order to facilitate trade. Money and wealth often go together, but they are completely different things. You can transform money into wealth, and vice versa (which is the whole point of having money), but you can have money without wealth and vice versa. And you can make (or earn) money without creating wealth, and vice versa. But historically, the most reliable and the most socially beneficial way of making money is to create wealth. So to help encourage that, here’s a more or less comprehensive list of fundamental mechanisms of creating wealth.<br>重要的是要记住，财富和金钱是有区别的。财富是衡量人们拥有多少东西，他们实际上是为了自己的价值。食物、住房、衣服、住所和艺术品都是财富的例子。相比之下，货币仅仅是人类为了促进贸易而发明的一种会计机制。金钱和财富经常相伴而行，但它们是完全不同的东西。你可以把钱变成财富，反之亦然（这就是有钱的全部意义），但你可以没有财富就有钱，反之亦然。你可以不创造财富而赚钱，反之亦然。但从历史上看，最可靠、对社会最有益的赚钱方式是创造财富。所以为了鼓励这一点，这里有一个或多或少全面的清单，列出了创造财富的基本机制。</p>
<ol>
<li><p>Move things from one place to another. Most things have value only when they are in a particular place. Food, clothing, and shelter only have value for you if they are close to where you happen to be. So you can create wealth simply by moving something from somewhere that it isn’t useful to somewhere that it is. It sounds simple, but this is the basis for the shipping industry, which is what more or less what financed the industrialization of the United States of America.<br>1.把东西从一个地方搬到另一个地方。大多数东西只有在特定的地方才有价值。食物、衣服和住所只有在你碰巧在的地方附近才对你有价值。所以你可以通过简单地把一些无用的东西从某个地方移到有用的地方来创造财富。这听起来很简单，但这是航运业的基础，这或多或少是美利坚合众国工业化的资金来源。</p>
</li>
<li><p>Store things. Just as the values of things are often bound to their location, value is also often bound to a particular time. A winter coat, for example, is more useful in winter than summer. Keeping things in serviceable condition until they become useful is often a non-trivial exercise (consider the problem of keeping fruits and vegetables available when they are out of season). So you can create value simply by holding on to something and maintaining it in working order until it becomes useful to someone. Just as moving things around is the basis for the shipping industry, storing things is the basis for the retail industry. Stores are called stores because they used to be places where things were stored, not necessarily places where things were sold.<br>2.储存东西。正如事物的价值往往与其所在的位置相联系，价值也往往与特定的时间相联系。例如，冬天的外套在冬天比夏天更有用。保持物品处于可用状态直到它们变得有用通常是一个不平凡的练习（考虑一下在水果和蔬菜过季时保持可用的问题）。因此，你可以通过简单地持有某样东西并保持它的工作状态，直到它对某人有用，来创造价值。就像运输是航运业的基础一样，存储是零售业的基础。商店之所以被称为商店，是因为它们过去是存放东西的地方，而不一定是出售东西的地方。</p>
</li>
<li><p>Transform things, either chemically or mechanically. This is the basis of the manufacturing industry. I don’t think I need to say any more about that. [Update: actually, it turns out I do need to say more about it. This is indeed the basis of manufacturing, but it’s also the basis of a lot of other things, including service industries like automobile repair, plumbing, cooking, hairdressing, painting and sculpture, carpentry, etc.]<br>3.以化学或机械的方式改变事物。这是制造业的基础。我想我不需要再多说了。【更新：其实我还得多说，这确实是制造业的基础，但也是很多其他东西的基础，包括汽车修理、管道、烹饪、美发、绘画雕塑、木工等服务业。</p>
</li>
<li><p>Farm. Technically, farming could be considered a subset of #3, since you’re transforming water, carbon dioxide and fertilizer or animal feed into other, more useful things like crops and livestock. But I put this in a separate category because it relies so much on natural processes. Some day we may be able to engineer entirely artificial crops, but until then I think it’s useful to think of farming as an endeavor separate from manufacturing.<br>4.农场从技术上讲，农业可以被认为是#3的一个子集，因为你正在将水，二氧化碳和肥料或动物饲料转化为其他更有用的东西，如农作物和牲畜。但我把它放在一个单独的类别中，因为它非常依赖于自然过程。也许有一天我们能够设计出完全人造的农作物，但在那之前，我认为把农业看作是与制造业分开的一项奋进是有用的。</p>
</li>
<li><p>Build buildings. This could also be considered a subset of #3, but I put it in a separate category because buildings are not easily moved from one place to another, so they have to be manufactured in situ. This fact makes real estate development significantly different enough from manufacturing that it deserves its own category.<br>5.盖房子这也可以被认为是#3的一个子集，但我把它放在一个单独的类别中，因为建筑物不容易从一个地方移动到另一个地方，所以它们必须在原地制造。这一事实使得真实的房地产开发与制造业有着显著的不同，因此有必要将其单独归类。</p>
</li>
<li><p>Extract natural resources from the earth or space. This category includes things like mining, oil drilling, and fishing. It used to include hunting (the answer to the question I posed above about what the U.S. traded to China in the 19th century is “fur”) but no longer.<br>6.从地球或太空中提取自然资源。这一类别包括采矿、石油钻探和渔业。它曾经包括狩猎（我上面提出的关于美国在19世纪世纪与中国进行贸易的问题的答案是“毛皮”），但现在不再包括了。</p>
</li>
<li><p>Cure disease, or at least ameliorate the symptoms. This is medicine.<br>7.治愈疾病，或者至少减轻症状。这是药</p>
</li>
<li><p>Find entirely new ways of doing any of the above more efficiently or effectively. This is “research” or “invention.” (Note that this is decidedly not the same thing as “having a brilliant idea”.)<br>8.找到全新的方法来更有效地完成上述任何一项工作。这是“研究”或“发明”。（请注意，这与“有一个绝妙的想法”绝对不是一回事。）</p>
</li>
</ol>
<p>And finally, the granddaddy of them all for the 21st century:<br>最后，21世纪最伟大的发明：</p>
<ol start="9">
<li>Provide people with useful information.<br>9.为人们提供有用的信息。</li>
</ol>
<p>This one can be broken up into a number of major sub-areas:<br>这一领域可分为若干主要的次级领域：</p>
<p>9a. Help match supply and demand. The world is so complex and diverse that you can create wealth simply by identifying sources of supply and demand and matching them up. This is the basis of modern markets. I say “modern” to distinguish them from “old-fashioned” markets where merchants display their wares directly. In this case, the information about what is available is tightly bound to the physical goods themselves. Of course, “old-fashioned” markets of this sort are still common. All brick-and-mortar stores are “old-fashioned” markets. But modern commerce decouples information about goods from the physical goods themselves. It is not uncommon nowadays to buy something without ever laying eyes on it. Amazon, EBay, ECNs and Google are all examples of “modern” markets.<br>9a.帮助供需匹配。世界是如此复杂和多样化，你可以创造财富，只要确定供应和需求的来源，并将它们匹配起来。这是现代市场的基础。我说“现代”是为了区别于商人直接展示商品的“老式”市场。在这种情况下，关于什么是可用的信息与实物商品本身紧密相连。当然，这种“老式”市场仍然很常见。所有的实体店都是“老式”市场。但现代商业将商品的信息从实物商品本身中分离出来。如今，买东西时根本不看一眼并不罕见，亚马逊、易趣、ECN和谷歌都是“现代”市场的例子。</p>
<p>A sub-category of 9a is entrepreneurialism. A company is nothing more than a bunch of people providing goods and services for each other with the matching of supply and demand being coordinated by a central planner (management) rather than by a market.<br>9a的一个子类别是物质主义。一个公司只不过是一群人相互提供商品和服务，供应和需求的匹配由中央计划者（管理层）而不是市场来协调。</p>
<p>9b. Help people figure out the rules. Modern economies operate by an often byzantine set of laws, regulations, customs and conventions. Lawyers and management consultants fall into this category.<br>9b.帮助人们理解规则。现代经济的运作往往是由一套拜占庭式的法律、法规、习俗和惯例。律师和管理顾问属于这一类。</p>
<p>9c. Provide information that is useful in and of itself. This includes journalism and creative writing. Most blogs are an example of 9c.<br>9c.提供本身有用的信息。这包括新闻和创意写作。大多数博客都是9c的一个例子。</p>
<p>This last category is of particular note because so many people seem to focus on it. Every scholar, blogger, reporter, novelist, screenwriter, composer and choreographer is working on 9c. A lot of wealth gets created this way, but of all the ways to make money it is arguably the least effective. It is very hard to transform information directly into money. Once upon a time, information was strongly bound to physical objects like books or vinyl records, and you could make money by producing these things because they were instances of #3. But with modern computer technology you can reproduce information essentially for free without doing any physical transformation. The result has been an unprecedented, almost overwhelming creation of wealth, but very little of it gets translated into money because the marginal cost of production is so close to zero. There’s a reason Google doesn’t charge for its search services. Google makes money via 9a, not 9c.<br>最后一类特别值得注意，因为似乎有太多人关注它，每个学者、博客作者、记者、小说家、编剧、作曲家和编舞家都在为9c而努力。很多财富都是通过这种方式创造的，但在所有赚钱的方式中，它可以说是最不有效的。很难将信息直接转化为金钱。曾几何时，信息与书籍或黑胶唱片等实物紧密相连，你可以通过生产这些东西来赚钱，因为它们是第三条的实例。但是有了现代计算机技术，你可以免费复制信息，而不需要做任何物理转换。其结果是前所未有的，几乎压倒性的财富创造，但很少转化为货币，因为生产的边际成本非常接近于零。谷歌不对搜索服务收费是有原因的。谷歌通过9a赚钱，而不是9c。</p>
<p>There is one sub-category of 9c where it is possible to make money, and that is providing information that is difficult to obtain and useful to a narrow vertical market segment. The Y-Combinator company Octopart is an example of this.<br>9 c中有一个子类别是可以赚钱的，那就是提供难以获得的信息，并且对狭窄的垂直细分市场有用。Y-Combinator公司的ESPART就是一个例子。</p>
<p>I’m pretty sure this is a comprehensive list. Can anyone think of anything I’ve left out?<br>我敢肯定这是一个完整的列表。有谁能想到我遗漏了什么吗？</p>
]]></content>
  </entry>
  <entry>
    <title>Adapter</title>
    <url>/2023/12/03/design-pattern/adapter/</url>
    <content><![CDATA[<h1 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Adapter</strong> is a structural design pattern that allows objects with incompatible interfaces to collaborate.<br>适配器是一种结构设计模式，它允许具有不兼容接口的对象进行协作。</p>
<div align="center"> <img src="/images/adapter-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a stock market monitoring app. The app downloads the stock data from multiple sources in XML format and then displays nice-looking charts and diagrams for the user.<br>想象一下，您正在创建一个股票市场监控应用程序。该应用程序以XML格式从多个来源下载股票数据，然后为用户显示漂亮的图表和图表。</p>
<p>At some point, you decide to improve the app by integrating a smart 3rd-party analytics library. But there’s a catch: the analytics library only works with data in JSON format.<br>在某些时候，您决定通过集成智能第三方分析库来改进应用程序。但有一个问题：分析库仅适用于 JSON 格式的数据。</p>
<div align="center"> <img src="/images/adapter-problem-en.png"/>You can’t use the analytics library “as is” because it expects the data in a format that’s incompatible with your app.</br>您不能“按原样”使用分析库，因为它需要的数据格式与您的应用不兼容。</div>
You could change the library to work with XML. However, this might break some existing code that relies on the library. And worse, you might not have access to the library’s source code in the first place, making this approach impossible.
您可以更改库以使用 XML。但是，这可能会破坏一些依赖于该库的现有代码。更糟糕的是，您可能一开始就无法访问库的源代码，从而无法使用此方法。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>You can create an adapter. This is a special object that converts the interface of one object so that another object can understand it.<br>您可以创建适配器。这是一个特殊的对象，它转换一个对象的接口，以便另一个对象可以理解它。</p>
<p>An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn’t even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.<br>适配器包装其中一个对象，以隐藏在后台发生的转换的复杂性。包装的对象甚至不知道适配器。例如，您可以使用适配器包装以米和公里为单位运行的对象，该适配器将所有数据转换为英制单位（如英尺和英里）。</p>
<p>Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here’s how it works:<br>适配器不仅可以将数据转换为各种格式，还可以帮助具有不同接口的对象进行协作。其工作原理如下：</p>
<ol>
<li>The adapter gets an interface, compatible with one of the existing objects.<br>适配器获取一个接口，该接口与现有对象之一兼容。</li>
<li>Using this interface, the existing object can safely call the adapter’s methods.<br>使用此接口，现有对象可以安全地调用适配器的方法。</li>
<li>Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.<br>收到调用后，适配器将请求传递给第二个对象，但采用第二个对象期望的格式和顺序。</li>
</ol>
<p>Sometimes it’s even possible to create a two-way adapter that can convert the calls in both directions.<br>有时甚至可以创建一个双向适配器，可以在两个方向上转换呼叫。</p>
<div align="center"> <img src="/images/adapter-solution.png"/></div>
Let’s get back to our stock market app. To solve the dilemma of incompatible formats, you can create XML-to-JSON adapters for every class of the analytics library that your code works with directly. Then you adjust your code to communicate with the library only via these adapters. When an adapter receives a call, it translates the incoming XML data into a JSON structure and passes the call to the appropriate methods of a wrapped analytics object.

<p>让我们回到我们的股票市场应用程序。为了解决格式不兼容的难题，您可以为代码直接使用的分析库的每个类创建 XML 到 JSON 适配器。然后，将代码调整为仅通过这些适配器与库通信。当适配器收到调用时，它会将传入的 XML 数据转换为 JSON 结构，并将调用传递给包装的分析对象的相应方法。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/adapter-comic-1.png"/>A suitcase before and after a trip abroad.</br>出国旅行前后的行李箱。</div>
When you travel from the US to Europe for the first time, you may get a surprise when trying to charge your laptop. The power plug and sockets standards are different in different countries. That’s why your US plug won’t fit a German socket. The problem can be solved by using a power plug adapter that has the American-style socket and the European-style plug.
当您第一次从美国到欧洲旅行时，当您尝试为笔记本电脑充电时，您可能会感到惊讶。不同国家的电源插头和插座标准不同。这就是为什么您的美国插头不适合德国插座的原因。这个问题可以通过使用具有美式插座和欧式插头的电源插头适配器来解决。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h3 id="Object-adapter-对象适配器"><a href="#Object-adapter-对象适配器" class="headerlink" title="Object adapter 对象适配器"></a>Object adapter 对象适配器</h3><p>This implementation uses the object composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.<br>此实现使用对象组合原则：适配器实现一个对象的接口并包装另一个对象。它可以用所有流行的编程语言实现。</p>
<div align="center"> <img src="/images/adapter-structure-object-adapter.png"/></div>

<ol>
<li><p>The Client is a class that contains the existing business logic of the program.<br>Client 是一个包含程序现有业务逻辑的类。</p>
</li>
<li><p>The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.<br>客户端接口描述了其他类必须遵循的协议，以便能够与客户端代码进行协作。</p>
</li>
<li><p>The Service is some useful class (usually 3rd-party or legacy). The client can’t use this class directly because it has an incompatible interface.<br>服务是一些有用的类（通常是第三方或旧版）。客户端不能直接使用此类，因为它具有不兼容的接口。</p>
</li>
<li><p>The <strong>Adapter</strong> is a class that’s able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the client interface and translates them into calls to the wrapped service object in a format it can understand.<br>Adapter 是一个能够同时使用客户端和服务的类：它实现客户端接口，同时包装服务对象。适配器通过客户端接口接收来自客户端的调用，并以它可以理解的格式将其转换为对包装的服务对象的调用。</p>
</li>
<li><p>The client code doesn’t get coupled to the concrete adapter class as long as it works with the adapter via the client interface. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.<br>只要客户端代码通过客户端接口与适配器一起使用，它就不会耦合到具体的适配器类。因此，您可以在不破坏现有客户端代码的情况下将新类型的适配器引入程序。当服务类的接口被更改或替换时，这可能很有用：您可以只创建一个新的适配器类，而无需更改客户端代码。</p>
</li>
</ol>
<h3 id="Class-adapter-类适配器"><a href="#Class-adapter-类适配器" class="headerlink" title="Class adapter 类适配器"></a>Class adapter 类适配器</h3><p>This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.<br>此实现使用继承：适配器同时从两个对象继承接口。请注意，此方法只能在支持多重继承的编程语言（如 C++）中实现。</p>
<div align="center"> <img src="/images/adapter-structure-class-adapter.png"/></div>

<ol>
<li>The Class Adapter doesn’t need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.<br>类适配器不需要包装任何对象，因为它从客户端和服务继承行为。适应发生在被覆盖的方法中。生成的适配器可用于代替现有的客户端类。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example of the <strong>Adapter</strong> pattern is based on the classic conflict between square pegs and round holes.<br>此适配器模式示例基于方形钉子和圆孔之间的经典冲突。</p>
<div align="center"> <img src="/images/adapter-example.png"/>Adapting square pegs to round holes.</br>使方钉适应圆孔。</div>
The Adapter pretends to be a round peg, with a radius equal to a half of the square’s diameter (in other words, the radius of the smallest circle that can accommodate the square peg).
适配器假装是一个圆钉，其半径等于正方形直径的一半（换句话说，可以容纳方形钉的最小圆的半径）。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Say you have two classes with compatible interfaces:</span></span><br><span class="line"><span class="comment">// RoundHole and RoundPeg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundHole</span> is</span><br><span class="line">    constructor <span class="title function_">RoundHole</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the radius of the hole.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">fits</span><span class="params">(peg: RoundPeg)</span> is</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getRadius() &gt;= peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">    constructor <span class="title function_">RoundPeg</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the radius of the peg.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// But there&#x27;s an incompatible class: SquarePeg.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquarePeg</span> is</span><br><span class="line">    constructor <span class="title function_">SquarePeg</span><span class="params">(width)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getWidth</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Return the square peg width.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// An adapter class lets you fit square pegs into round holes.</span></span><br><span class="line"><span class="comment">// It extends the RoundPeg class to let the adapter objects act</span></span><br><span class="line"><span class="comment">// as round pegs.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquarePegAdapter</span> <span class="keyword">extends</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">    <span class="comment">// In reality, the adapter contains an instance of the</span></span><br><span class="line">    <span class="comment">// SquarePeg class.</span></span><br><span class="line">    <span class="keyword">private</span> field peg: SquarePeg</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">SquarePegAdapter</span><span class="params">(peg: SquarePeg)</span> is</span><br><span class="line">        <span class="built_in">this</span>.peg = peg</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// The adapter pretends that it&#x27;s a round peg with a</span></span><br><span class="line">        <span class="comment">// radius that could fit the square peg that the adapter</span></span><br><span class="line">        <span class="comment">// actually wraps.</span></span><br><span class="line">        <span class="keyword">return</span> peg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code.</span></span><br><span class="line">hole = <span class="keyword">new</span> <span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">rpeg = <span class="keyword">new</span> <span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">hole.fits(rpeg) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">small_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">large_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">hole.fits(small_sqpeg) <span class="comment">// this won&#x27;t compile (incompatible types)</span></span><br><span class="line"></span><br><span class="line">small_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">hole.fits(small_sqpeg_adapter) <span class="comment">// true</span></span><br><span class="line">hole.fits(large_sqpeg_adapter) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.<br>如果要使用某些现有类，但其接口与代码的其余部分不兼容，请使用 Adapter 类。</strong></p>
</li>
<li><p>The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.<br>适配器模式允许您创建一个中间层类，该类充当代码与旧类、第三方类或任何其他具有奇怪接口的类之间的转换器。</p>
</li>
<li><p><strong>Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.<br>如果要重用多个现有的子类，这些子类缺少一些无法添加到超类的通用功能，请使用该模式。</strong></p>
</li>
<li><p>You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.<br>您可以扩展每个子类，并将缺少的功能放入新的子类中。但是，您需要在所有这些新类中复制代码，这闻起来非常难闻。</p>
</li>
</ul>
<p>The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.<br>更优雅的解决方案是将缺少的功能放入适配器类中。然后，将缺少特征的对象包装在适配器内，动态获得所需的特征。为此，目标类必须具有通用接口，并且适配器的字段应遵循该接口。此方法看起来与 Decorator 模式非常相似。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that you have at least two classes with incompatible interfaces:确保至少有两个接口不兼容的类：</p>
<ul>
<li>A useful service class, which you can’t change (often 3rd-party, legacy or with lots of existing dependencies).<br>一个有用的服务类，您无法更改（通常是第三方、旧版或具有大量现有依赖项）。</li>
<li>One or several client classes that would benefit from using the service class.<br>一个或多个客户端类，这些类将从使用服务类中受益。</li>
</ul>
</li>
<li><p>Declare the client interface and describe how clients communicate with the service.<br>声明客户端接口并描述客户端如何与服务通信。</p>
</li>
<li><p>Create the adapter class and make it follow the client interface. Leave all the methods empty for now.<br>创建适配器类，并使其遵循客户端接口。暂时将所有方法留空。</p>
</li>
<li><p>Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it’s more convenient to pass it to the adapter when calling its methods.<br>向适配器类添加一个字段，以存储对服务对象的引用。通常的做法是通过构造函数初始化此字段，但有时在调用适配器的方法时将其传递给适配器会更方便。</p>
</li>
<li><p>One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.<br>在适配器类中逐个实现客户端接口的所有方法。适配器应将大部分实际工作委托给服务对象，仅处理接口或数据格式转换。</p>
</li>
<li><p>Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.<br>客户端应通过客户端接口使用适配器。这将允许您更改或扩展适配器，而不会影响客户端代码。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program. 单一责任原则。您可以将接口或数据转换代码与程序的主要业务逻辑分开。</td>
<td>The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code. 代码的整体复杂性增加，因为您需要引入一组新的接口和类。有时，只需更改服务类以使其与代码的其余部分匹配即可更简单。</td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface. 开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下将新类型的适配器引入程序，只要它们通过客户端接口与适配器一起使用即可。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Bridge is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, Adapter is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.<br>Bridge 通常是预先设计的，允许您彼此独立地开发应用程序的各个部分。另一方面，Adapter 通常与现有应用程序一起使用，以使一些不兼容的类很好地协同工作。</p>
</li>
<li><p>Adapter provides a completely different interface for accessing an existing object. On the other hand, with the Decorator pattern the interface either stays the same or gets extended. In addition, Decorator supports recursive composition, which isn’t possible when you use Adapter.<br>适配器提供了一个完全不同的接口来访问现有对象。另一方面，使用 Decorator 模式，界面要么保持不变，要么得到扩展。此外，Decorator 支持递归组合，这在使用 Adapter 时是不可能的。</p>
</li>
<li><p>With Adapter you access an existing object via different interface. With Proxy, the interface stays the same. With Decorator you access the object via an enhanced interface.<br>使用 Adapter，您可以通过不同的接口访问现有对象。使用 Proxy，界面保持不变。使用 Decorator，您可以通过增强的界面访问对象。</p>
</li>
<li><p>Facade defines a new interface for existing objects, whereas Adapter tries to make the existing interface usable. Adapter usually wraps just one object, while Facade works with an entire subsystem of objects.<br>Facade 为现有对象定义了一个新的接口，而 Adapter 则试图使现有接口可用。Adapter 通常只包装一个对象，而 Facade 则处理对象的整个子系统。</p>
</li>
<li><p>Bridge, State, Strategy (and to some degree Adapter) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.<br>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-via-inheritance-概念示例（通过继承）"><a href="#Python-Conceptual-Example-via-inheritance-概念示例（通过继承）" class="headerlink" title="Python: Conceptual Example (via inheritance) 概念示例（通过继承）"></a>Python: Conceptual Example (via inheritance) 概念示例（通过继承）</h3><p>This example illustrates the structure of the Adapter design pattern. It focuses on answering these questions:<br>此示例阐释了适配器设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h3 id="main-py：概念示例"><a href="#main-py：概念示例" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Target defines the domain-specific interface used by the client code.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Target: The default target&#x27;s behavior.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adaptee contains some useful behavior, but its interface is incompatible</span></span><br><span class="line"><span class="string">    with the existing client code. The Adaptee needs some adaptation before the</span></span><br><span class="line"><span class="string">    client code can use it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specific_request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>(Target, Adaptee):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span></span><br><span class="line"><span class="string">    interface via multiple inheritance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Adapter: (TRANSLATED) <span class="subst">&#123;self.specific_request()[::-<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">target: <span class="string">&quot;Target&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code supports all classes that follow the Target interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(target.request(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I can work just fine with the Target objects:&quot;</span>)</span><br><span class="line">    target = Target()</span><br><span class="line">    client_code(target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    adaptee = Adaptee()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: The Adaptee class has a weird interface. &quot;</span></span><br><span class="line">          <span class="string">&quot;See, I don&#x27;t understand it:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Adaptee: <span class="subst">&#123;adaptee.specific_request()&#125;</span>&quot;</span>, end=<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: But I can work with it via the Adapter:&quot;</span>)</span><br><span class="line">    adapter = Adapter()</span><br><span class="line">    client_code(adapter)</span><br></pre></td></tr></table></figure>
<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I can work just fine with the Target objects:</span><br><span class="line">Target: The default target&#x27;s behavior.</span><br><span class="line"></span><br><span class="line">Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:</span><br><span class="line">Adaptee: .eetpadA eht fo roivaheb laicepS</span><br><span class="line"></span><br><span class="line">Client: But I can work with it via the Adapter:</span><br><span class="line">Adapter: (TRANSLATED) Special behavior of the Adaptee.</span><br></pre></td></tr></table></figure>

<h3 id="Python-Conceptual-Example-via-object-composition-概念示例（通过对象组合）"><a href="#Python-Conceptual-Example-via-object-composition-概念示例（通过对象组合）" class="headerlink" title="Python: Conceptual Example (via object composition) 概念示例（通过对象组合）"></a>Python: Conceptual Example (via object composition) 概念示例（通过对象组合）</h3><p>This example illustrates the structure of the Adapter design pattern. It focuses on answering these questions:<br>此示例阐释了适配器设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h3 id="main-py：概念示例-1"><a href="#main-py：概念示例-1" class="headerlink" title="main.py：概念示例"></a>main.py：概念示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Target defines the domain-specific interface used by the client code.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Target: The default target&#x27;s behavior.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adaptee contains some useful behavior, but its interface is incompatible</span></span><br><span class="line"><span class="string">    with the existing client code. The Adaptee needs some adaptation before the</span></span><br><span class="line"><span class="string">    client code can use it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specific_request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>(<span class="title class_ inherited__">Target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span></span><br><span class="line"><span class="string">    interface via composition.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, adaptee: Adaptee</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.adaptee = adaptee</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Adapter: (TRANSLATED) <span class="subst">&#123;self.adaptee.specific_request()[::-<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">target: Target</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code supports all classes that follow the Target interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(target.request(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I can work just fine with the Target objects:&quot;</span>)</span><br><span class="line">    target = Target()</span><br><span class="line">    client_code(target)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    adaptee = Adaptee()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: The Adaptee class has a weird interface. &quot;</span></span><br><span class="line">          <span class="string">&quot;See, I don&#x27;t understand it:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Adaptee: <span class="subst">&#123;adaptee.specific_request()&#125;</span>&quot;</span>, end=<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: But I can work with it via the Adapter:&quot;</span>)</span><br><span class="line">    adapter = Adapter(adaptee)</span><br><span class="line">    client_code(adapter)</span><br></pre></td></tr></table></figure>
<h3 id="Output-txt-Execution-result-1"><a href="#Output-txt-Execution-result-1" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I can work just fine with the Target objects:</span><br><span class="line">Target: The default target&#x27;s behavior.</span><br><span class="line"></span><br><span class="line">Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:</span><br><span class="line">Adaptee: .eetpadA eht fo roivaheb laicepS</span><br><span class="line"></span><br><span class="line">Client: But I can work with it via the Adapter:</span><br><span class="line">Adapter: (TRANSLATED) Special behavior of the Adaptee.</span><br></pre></td></tr></table></figure>

<h3 id="Adapter-in-Rust-Rust-中的适配器"><a href="#Adapter-in-Rust-Rust-中的适配器" class="headerlink" title="Adapter in Rust Rust 中的适配器"></a>Adapter in Rust Rust 中的适配器</h3><p>In this example, the <code>trait SpecificTarget</code> is incompatible with a <code>call</code> function which accepts <code>trait Target</code> only.<br>在此示例中，与 <code>trait SpecificTarget</code> 仅接受 <code>call</code> <code>trait Target</code> 的函数不兼容。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(target: <span class="keyword">impl</span> <span class="title class_">Target</span>);</span><br></pre></td></tr></table></figure>
<p>The adapter helps to pass the incompatible interface to the <code>call</code> function.<br>适配器有助于将不兼容的接口传递给 <code>call</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">target</span> = TargetAdapter::<span class="title function_ invoke__">new</span>(specific_target);</span><br><span class="line"><span class="title function_ invoke__">call</span>(target);</span><br></pre></td></tr></table></figure>

<h4 id="adapter-rs"><a href="#adapter-rs" class="headerlink" title="adapter.rs"></a>adapter.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;adaptee::SpecificTarget, Target&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Converts adaptee&#x27;s specific interface to a compatible `Target` output.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    adaptee: SpecificTarget,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(adaptee: SpecificTarget) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; adaptee &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Target</span> <span class="keyword">for</span> <span class="title class_">TargetAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Here&#x27;s the &quot;adaptation&quot; of a specific output to a compatible output.</span></span><br><span class="line">        <span class="keyword">self</span>.adaptee.<span class="title function_ invoke__">specific_request</span>().<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="adaptee-rs"><a href="#adaptee-rs" class="headerlink" title="adaptee.rs"></a>adaptee.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpecificTarget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpecificTarget</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">specific_request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;.tseuqer cificepS&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="target-rs"><a href="#target-rs" class="headerlink" title="target.rs"></a>target.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">OrdinaryTarget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Target</span> <span class="keyword">for</span> <span class="title class_">OrdinaryTarget</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;Ordinary request.&quot;</span>.<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> adaptee;</span><br><span class="line"><span class="keyword">mod</span> adapter;</span><br><span class="line"><span class="keyword">mod</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> adaptee::SpecificTarget;</span><br><span class="line"><span class="keyword">use</span> adapter::TargetAdapter;</span><br><span class="line"><span class="keyword">use</span> target::&#123;OrdinaryTarget, Target&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Calls any object of a `Target` trait.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// To understand the Adapter pattern better, imagine that this is</span></span><br><span class="line"><span class="comment">/// a client code, which can operate over a specific interface only</span></span><br><span class="line"><span class="comment">/// (`Target` trait only). It means that an incompatible interface cannot be</span></span><br><span class="line"><span class="comment">/// passed here without an adapter.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(target: <span class="keyword">impl</span> <span class="title class_">Target</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27;&quot;</span>, target.<span class="title function_ invoke__">request</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = OrdinaryTarget;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;A compatible target can be directly called: &quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">call</span>(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">adaptee</span> = SpecificTarget;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Adaptee is incompatible with client: &#x27;&#123;&#125;&#x27;&quot;</span>,</span><br><span class="line">        adaptee.<span class="title function_ invoke__">specific_request</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">adapter</span> = TargetAdapter::<span class="title function_ invoke__">new</span>(adaptee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;But with adapter client can call its method: &quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">call</span>(adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A compatible target can be directly called: &#x27;Ordinary request.&#x27;</span><br><span class="line">Adaptee is incompatible with client: &#x27;.tseuqer cificepS&#x27;</span><br><span class="line">But with adapter client can call its method: &#x27;Specific request.&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Henry A.Kissinger 1923 – 2023</title>
    <url>/2023/11/29/kissinger-1923-2023/</url>
    <content><![CDATA[<h1 id="Henry-A-Kissinger-1923-–-2023"><a href="#Henry-A-Kissinger-1923-–-2023" class="headerlink" title="Henry A.Kissinger 1923 – 2023"></a>Henry A.Kissinger 1923 – 2023</h1><div align="center"> <img src="/images/kissinger-header.png"/></div>
Henry A. Kissinger was the 56th Secretary of State, a respected American scholar and Nobel Peace Prize Laureate who helped create the post-World War II world order and led the U.S. through some of its most complicated foreign policy challenges.
亨利·基辛格（Henry A. Kissinger）是第56任国务卿，是一位受人尊敬的美国学者和诺贝尔和平奖获得者，他帮助建立了二战后的世界秩序，并领导美国克服了一些最复杂的外交政策挑战。

<p>With his distinct German accent, sharp wit, voluminous writings and belief in the peacemaking power of realpolitik, Dr. Kissinger was one of the most influential foreign policy and national security practitioners of the post-World War II era and remained active in national security for more than 70 years. From the age of 20, when he joined the U.S. Army, to nearly his death, Dr. Kissinger continued to travel to Washington to offer testimony on U.S. national security strategy.<br>基辛格博士有着鲜明的德国口音、敏锐的机智、大量的著作以及对现实政治缔造和平力量的信念，是二战后最有影响力的外交政策和国家安全实践者之一，并在国家安全领域活跃了70多年。从20岁加入美国陆军到几近去世，基辛格博士继续前往华盛顿，为美国的国家安全战略提供证词。</p>
<p>As National Security Advisor and then Secretary of State during the Nixon and Ford Administrations, Dr. Kissinger was the author of some of those administrations’ most important, and sometimes controversial, policies.<br>作为尼克松和福特政府的国家安全顾问和国务卿，基辛格博士是这些政府中一些最重要、有时也是有争议的政策的作者。<br>He was instrumental to opening China to the Western world and was the primary voice of détente with the Soviet Union that lowered tensions during the Cold War, a reflection of his belief in the balance of power as a tenet of global order.<br>他在向西方世界开放中国方面发挥了重要作用，并且是冷战期间与苏联缓和关系的主要声音，缓解了紧张局势，这反映了他对力量平衡作为全球秩序原则的信念。</p>
<p>Before his government service, Dr. Kissinger served on the faculty at Harvard University, where he ran the International Seminar from 1952 to 1969.<br>在担任政府职务之前，基辛格博士曾在哈佛大学任教，并于 1952 年至 1969 年主持国际研讨会。</p>
<p>Dr. Kissinger is the recipient of a number of awards and recognitions. In 1945, he was awarded a Bronze Star from the U.S. Army for meritorious service. He received the Nobel Peace Prize in 1973, the same year a Gallup Poll of Americans listed him as the most admired person in the world. He was also awarded the nation’s highest civilian honor, the Presidential Medal of Freedom, in 1977 and the Medal of Liberty, given one time to ten foreign-born American leaders, in 1986.<br>基辛格博士是许多奖项和认可的获得者。1945年，他因功勋被美国陆军授予铜星勋章。他于1973年获得诺贝尔和平奖，同年，盖洛普美国人民意调查将他列为世界上最受尊敬的人。他还于1977年被授予美国最高平民荣誉总统自由勋章，并于1986年被授予自由勋章，该勋章曾授予十位外国出生的美国领导人。</p>
<p>As the architect of a lasting era of peace, stability, prosperity and global order, he made a substantial impact on generations of citizens, from the U.S. to Europe and China.<br>作为和平、稳定、繁荣和全球秩序的持久时代的缔造者，他对从美国到欧洲和中国的几代公民产生了重大影响。</p>
<p>“After 30 years he’s still public policy’s equivalent of a rock star.”<br>“30年后，他仍然是公共政策中的摇滚明星。</p>
<p>Norman Ornstein, 2002, Political Scholar<br>诺曼·奥恩斯坦（Norman Ornstein），2002年，政治学者<br>“I salute Henry Kissinger for his many efforts at peace and security.”<br>“我向亨利·基辛格致敬，感谢他为和平与安全所做的许多努力。</p>
<p>George Shultz, 2015, former Secretary of State<br>乔治·舒尔茨，2015年，前国务卿<br>“Dr. Kissinger is one of our Nation’s most accomplished and respected public servants.”<br>“基辛格博士是我们国家最有成就和最受尊敬的公务员之一。</p>
<p>President George W. Bush, 2002<br>乔治·W·布什总统，2002年<br>“Most secretaries of state reach their peak fame as they leave office. I venture to say that Henry Kissinger is perhaps more widely known in the world today than he was when he left… He is a synonym of global diplomacy.”<br>“大多数国务卿在卸任时都会达到顶峰。我冒昧地说，亨利·基辛格在当今世界上的知名度可能比他离开时更广为人知……他是全球外交的代名词。</p>
<p>Brent Scowcroft, 2012, former National Security Adviser<br>布伦特·斯考克罗夫特（Brent Scowcroft），2012年，前国家安全顾问<br>“While his contributions are far from complete, we are now beginning to appreciate what his service has provided our country, how it has changed the way we think about strategy and how he has helped provide greater security for our citizens and people around the world.”<br>“虽然他的贡献远未完成，但我们现在开始欣赏他的服务为我们的国家提供了什么，它如何改变了我们对战略的思考方式，以及他如何帮助我们的公民和世界各地的人民提供更大的安全。</p>
<p>Ashton Carter, 2016, former Secretary of Defense<br>阿什顿·卡特，2016年，前国防部长<br>“The United States, the world is greatly indebted to this superior person… He is, so far as this American is concerned, the greatest secretary of state in the history of our Republic. His superb record of achievement is unsurpassed in the annals of American history.”<br>“美国，全世界都非常感谢这位上等人……就这位美国人而言，他是我们共和国历史上最伟大的国务卿。他的卓越成就记录在美国历史上是无与伦比的。</p>
<p>President Gerald Ford, 1977<br>杰拉尔德·福特总统，1977年<br>“Henry Kissinger has played a central role in some of the most consequential U.S. foreign policy matters of the past half-century. He continues to be a highly influential figure in thinking about global affairs.”<br>“亨利·基辛格在过去半个世纪中一些最重要的美国外交政策事务中发挥了核心作用。在思考全球事务方面，他仍然是一个极具影响力的人物。</p>
<p>Harvard University President Drew Faust, 2012<br>哈佛大学校长德鲁·浮士德，2012年<br>“Dr. Kissinger wrote in his book, World Order, and I quote, that ‘each generation will be judged by whether the greatest, most consequential issues of the human condition have been faced…’ Let us work together to bring about an even better future for China-US relations.”<br>“基辛格博士在他的《世界秩序》一书中写道，’每一代人都将根据人类状况中是否面临过最重大、最重要的问题来评判……’让我们共同努力，开创中美关系更加美好的未来。</p>
<p>President Xi Jinping of China, 2015<br>中国国家主席习近平，2015年<br>“Dear Henry - It’s hard to believe that it has been more than forty-one years since you left office (I’m not far behind, with thirty-seven). There can be no doubt that our national Ship of State has often missed your hand at the tiller, though its steerpersons (sic) and captains have frequently sought your advice. Let’s hope that you, and indeed the Ship, will be around for a long time.”<br>“亲爱的亨利——很难相信你离任已经超过四十一年了（我也不甘落后，三十七年）。毫无疑问，我们的国家之船经常错过舵柄的手，尽管它的舵手（原文如此）和船长经常征求您的建议。让我们希望你，甚至这艘船，能存在很长一段时间。</p>
<p>Harold Brown, 2018, former Secretary of Defense and CSIS Counselor and Trustee<br>哈罗德·布朗（Harold Brown），2018年，前国防部长兼CSIS顾问和受托人<br>“Congratulations, Dr. Kissinger, on your 95th birthday! The Friedrich Wilhelms University Bonn established a permanent Henry Kissinger Chair to honor you for your outstanding strategic foresight and diplomatic contributions to world order and diplomacy. This German generation knows Immanuel Kant’s wisdom that peace is not a given, it does not come from itself. Germany has accepted greater international responsibility and draws on your understanding that success as a statesman rests on the study of history to understand why nations succeed and why they failed.”<br>“恭喜基辛格博士，你95岁生日！波恩弗里德里希·威廉大学设立了亨利·基辛格常设教席，以表彰您杰出的战略远见和对世界秩序和外交的外交贡献。这一代人知道伊曼纽尔·康德（Immanuel Kant）的智慧，即和平不是给定的，它不是来自自身。德国已经承担了更大的国际责任，并借鉴了你们的理解，即作为政治家的成功取决于对历史的研究，以了解国家为什么成功，为什么失败。</p>
<p>Professor James Bindenagel, Henry Kissinger Professor, Bonn, 2018<br>詹姆斯·宾德纳格尔教授，亨利·基辛格教授，波恩，2018</p>
<h2 id="Early-Life-早年生活"><a href="#Early-Life-早年生活" class="headerlink" title="Early Life 早年生活"></a>Early Life 早年生活</h2><p>Henry A. Kissinger was born to a schoolteacher and a homemaker in Furth, Germany, in 1923, just as nationalism was beginning to sweep Germany. As Jews, the Kissinger family found many activities were off-limits, including attending public soccer matches, a sport that Dr. Kissinger loved, even if he did not excel in it. What he may have lacked in athletic talent, however, he made up for in academics. As a child, he was bookish and introverted, yet also competitive.<br>亨利·基辛格（Henry A. Kissinger）于1923年出生于德国富尔特（Furth）的一名教师和家庭主妇，当时民族主义刚刚开始席卷德国。作为犹太人，基辛格一家发现许多活动都是禁止的，包括参加公共足球比赛，这是基辛格博士喜欢的运动，即使他并不擅长这项运动。然而，他可能在运动天赋方面有所欠缺，但他在学业上弥补了这一点。小时候，他书卷气十足，性格内向，但也很争强好胜。</p>
<div align="center"> <img src="/images/Early_life_1-658x1024.jpg"/></div>

<p>In 1935, the Nuremburg Laws were enacted, and Dr. Kissinger’s father, Louis, became a casualty of the rules, losing his job as a schoolteacher. Dr. Kissinger’s mother recognized that leaving Germany was the family’s best hope for their future and in 1938, three months before Kristallnacht, Dr. Kissinger, his younger brother Walter and their parents fled Nazi Germany and settled in New York City.<br>1935年，《纽伦堡法》颁布，基辛格博士的父亲路易斯成为该法的牺牲品，失去了教师的工作。基辛格的母亲认识到，离开德国是这个家庭未来的最大希望，1938年，在水晶之夜前三个月，基辛格博士、他的弟弟沃尔特和他们的父母逃离纳粹德国，定居在纽约市。</p>
<p>Many of his extended family were not able to escape, and 13 of them perished in the Holocaust. Well into his 80s, Dr. Kissinger remarked that people managed to survive the Holocaust through “singleness of purpose,” a trait that defined him throughout his career.<br>他的许多大家庭都无法逃脱，其中13人在大屠杀中丧生。基辛格博士在80多岁时表示，人们通过“单一目标”在大屠杀中幸存下来，这是他整个职业生涯的特征。</p>
<h2 id="New-Beginnings-in-America-美国的新起点"><a href="#New-Beginnings-in-America-美国的新起点" class="headerlink" title="New Beginnings in America 美国的新起点"></a>New Beginnings in America 美国的新起点</h2><p>Dr. Kissinger’s experience of fleeing a country where he once had to cross the street to avoid being beaten by non-Jewish boys, and coming to a country where such persecution did not exist for him, was a transformative one. Upon arriving in America, he was keen to be considered an American. As he later reflected in his farewell speech as Secretary of State, “When I came here in 1938, I was asked to write an essay at George Washington High School about what it meant to be an American. I wrote that…this was a country where one could walk across the street with one’s head erect.”<br>基辛格博士逃离了一个他曾经不得不过马路以避免被非犹太男孩殴打的国家，来到一个对他来说不存在这种迫害的国家，这是一次变革性的经历。抵达美国后，他渴望被视为美国人。正如他后来在作为国务卿的告别演说中所说，“当我1938年来到这里时，我被要求在乔治华盛顿高中写一篇关于作为一个美国人意味着什么的文章。我写道……这是一个可以昂首挺胸走过马路的国家。</p>
<p>In America, Dr. Kissinger plunged into his studies at George Washington High. He eventually transitioned to night school so that he could maintain a job at a shaving brush company by day. Good grades coupled with a steady work ethic made it easy for Dr. Kissinger to get into City College of New York, where he enjoyed a free education. His goal was to become an accountant, but time in the Army would set his life on a different path.<br>在美国，基辛格博士在乔治华盛顿高中投入研究。他最终转入夜校，这样他就可以在白天在剃须刷公司工作。良好的成绩加上稳定的职业道德，使基辛格博士很容易进入纽约市立学院，在那里他享受了免费教育。他的目标是成为一名会计师，但在军队中度过的时光使他的生活走上了不同的道路。</p>
<h2 id="A-lifetime-of-service-终身服务。"><a href="#A-lifetime-of-service-终身服务。" class="headerlink" title="A lifetime of service. 终身服务。"></a>A lifetime of service. 终身服务。</h2><p><a href="https://www.henryakissinger.com/timeline/">See the timeline →</a><br><a href="https://www.henryakissinger.com/timeline/">查看时间线→</a></p>
<h2 id="Service-to-Country-服务国家"><a href="#Service-to-Country-服务国家" class="headerlink" title="Service to Country 服务国家"></a>Service to Country 服务国家</h2><p>In 1943, the year he became a U.S. citizen, Dr. Kissinger was drafted into the U.S. Army, where his intellect and fluency in German would make him a perfect candidate for military intelligence. His intellectual abilities earned him a placement in the Army Specialized Training Program, an opportunity that sent him from combat training to college instead. Dr. Kissinger was sent to Lafayette College in Pennsylvania, where he studied engineering, read books on history in his spare time, and tutored other students.<br>1943年，基辛格博士成为美国公民，被征召入伍，他的智慧和流利的德语使他成为军事情报部门的完美人选。他的智力为他赢得了陆军专业训练计划的安置，这个机会使他从战斗训练进入了大学。基辛格博士被送到宾夕法尼亚州的拉斐特学院，在那里他学习工程学，在业余时间阅读历史书籍，并辅导其他学生。</p>
<p>In 1944, however, the Army canceled the program, and Dr. Kissinger was returned to Camp Claiborne in Louisiana. From Camp Claiborne, Dr. Kissinger was assigned to the 84th Infantry Division, which set sail from New York to Europe in September 1944 as part of the pursuit phase of the war. When he arrived back in his homeland of Germany, Dr. Kissinger was quickly selected to become a German translator for General Alexander Bolling. Later, in the Battle of the Bulge, when most of the division was forced to withdraw, Dr. Kissinger volunteered to stay behind to be part of hazardous counter-intelligence duties, making good use of his German.<br>然而，在1944年，陆军取消了该计划，基辛格博士被送回路易斯安那州的克莱伯恩营。从克莱伯恩营出发，基辛格博士被分配到第 84 步兵师，该师于 1944 年 9 月从纽约启航前往欧洲，作为战争追击阶段的一部分。回到家乡德国后，基辛格博士很快被选为亚历山大·博林将军的德语翻译。后来，在突出部战役中，当该师的大部分部队被迫撤退时，基辛格博士自愿留下来，成为危险的反情报职责的一部分，充分利用了他的德语。</p>
<p>When the 84th Division later captured the German town of Krefeld on the Rhine River, Dr. Kissinger became the town’s administrator — relying on his language skills and his understanding of the German culture to command authority. He succeeded in restoring order and building a civilian government in the town in little more than a week, a success that enabled him to transfer to the Counter-Intelligence Corps (CIC). The mission was to identify Nazis and members of the Gestapo in areas that the Allies had captured. His work there would earn him a Bronze Star.<br>当第84师后来占领了莱茵河畔的德国小镇克雷费尔德时，基辛格博士成为该镇的行政长官——依靠他的语言技能和对德国文化的理解来指挥权威。他在短短一周多的时间里成功地恢复了秩序，并在镇上建立了一个文职政府，这一成功使他能够转移到反情报部队（CIC）。任务是在盟军占领的地区识别纳粹分子和盖世太保成员。他在那里的工作为他赢得了铜星勋章。</p>
<p>Dr. Kissinger’s work in the CIC would continue even after the war had ended, as he was called upon to provide order and detect Nazis in Hesse. He kept any feelings of anger or resentment toward the Germans — who had forced his family to flee less than a decade earlier — beneath the surface. Dr. Kissinger operated with remarkable restraint.<br>即使在战争结束后，基辛格博士在中央情报局的工作仍在继续，因为他被要求在黑森州提供秩序并侦查纳粹分子。他对德国人的任何愤怒或怨恨都隐藏在表面之下——德国人在不到十年前迫使他的家人逃离。基辛格博士非常克制。</p>
<p>In 1946, he was discharged from the Army, having obtained the rank of sergeant. As he would later reflect, his military service would become for him the highlight of his career, and also one that affirmed his American identity and gave him confidence.<br>1946年，他从陆军退伍，获得了中士军衔。正如他后来所反映的那样，服兵役将成为他职业生涯的亮点，也是肯定他的美国身份并给予他信心的亮点。</p>
<h2 id="Academia-学术界"><a href="#Academia-学术界" class="headerlink" title="Academia 学术界"></a>Academia 学术界</h2><p>Following his service in the Army, and a brief stint teaching military officers in Germany, Dr. Kissinger returned to academics, earning his B.A., M.A. and Ph.D. from Harvard University. Legend has it that his doctoral dissertation was, and remains, the longest dissertation ever submitted at Harvard University.<br>在军队服役并在德国短暂教授军官后，基辛格博士重返学术界，在哈佛大学获得学士、硕士和博士学位。传说他的博士论文是，现在仍然是哈佛大学有史以来最长的论文。</p>
<p>As the son of an educator, Dr. Kissinger wavered early on between a life in academia and a life on the front lines of shaping foreign policy. Before entering government, he held a variety of academic and think-tank posts: at Harvard University, his alma mater, where he was a professor of government; at the Rockefeller Brothers Fund; at the Council on Foreign Relations; and many others.<br>作为教育家的儿子，基辛格博士很早就在学术界的生活和制定外交政策的前线生活之间摇摆不定。在进入政府部门之前，他担任过各种学术和智囊团职位：在他的母校哈佛大学担任政府学教授;洛克菲勒兄弟基金会;在外交关系委员会;还有很多其他的。</p>
<p>At Harvard, perhaps his most passionate pursuit, and a formative precursor to his career as an international diplomat, was the International Seminar that he founded in 1952 and ran until 1969. The seminar brought together about 40 foreign dignitaries each summer for classes, lectures and, most importantly, networking sessions. Through the seminar, Dr. Kissinger built a wide base of foreign contacts with whom he could conduct direct diplomacy, including contacts in China, Europe and Latin America.<br>在哈佛，也许是他最热情的追求，也是他作为国际外交官职业生涯的形成性先驱，是他于1952年创立并一直持续到1969年的国际研讨会。每年夏天，该研讨会都会聚集约40位外国政要参加课程、讲座，最重要的是，参加社交会议。通过这次研讨会，基辛格博士建立了广泛的对外联系基础，他可以与他们进行直接外交，包括在中国、欧洲和拉丁美洲的联系。</p>
<p>It was also during his time in academia that Dr. Kissinger refined his belief in the balance of power, linkage and triangular diplomacy. This would become the driving philosophy of his time as Secretary of State. His dissertation, Peace, Legitimacy, and the Equilibrium: A Study of the Statesmanship of Castlereagh and Metternich, argued that peace and stability do not come from the pursuit of peace per se. Rather, he looked at the diplomatic successes of Klemens von Metternich and Congress of Europe and concluded that peace comes from “an international agreement about the nature of workable arrangements and the permissible aims and methods of foreign policy. It implies the acceptance of the framework of international order by all major powers.” While Dr. Kissinger’s approach to peace through rules, power and stability was controversial, it also led to his greatest accomplishments.<br>也是在学术界期间，基辛格博士完善了他对权力平衡、联系和三角外交的信念。这将成为他担任国务卿期间的驱动哲学。他的论文《和平、合法性和均衡：卡斯尔雷和梅特涅政治家风度研究》认为，和平与稳定并非来自对和平本身的追求。相反，他研究了克莱门斯·冯·梅特涅（Klemens von Metternich）和欧洲会议（Congress of Europe）的外交成功，并得出结论，和平来自“关于可行安排的性质以及外交政策的允许目标和方法的国际协议。它意味着所有大国都接受国际秩序的框架。虽然基辛格博士通过规则、权力和稳定实现和平的方法存在争议，但它也导致了他最伟大的成就。</p>
<div align="center"> <img src="/images/Academia_1.png"/></div>

<h2 id="Global-Statesman-全球政治家"><a href="#Global-Statesman-全球政治家" class="headerlink" title="Global Statesman 全球政治家"></a>Global Statesman 全球政治家</h2><p>Though successful in academia, Dr. Kissinger longed to have a direct impact on policy. He entered the political arena in 1960, serving as a senior foreign policy advisor to Gov. Nelson Rockefeller’s presidential campaigns in 1960, 1964 and 1968. When Rockefeller lost the Republican nomination in 1968, Dr. Kissinger, reluctantly at first, joined the campaign of the party nominee, Richard Nixon.<br>虽然在学术界取得了成功，但基辛格博士渴望对政策产生直接影响。他于 1960 年进入政坛，在 1960 年、1964 年和 1968 年担任纳尔逊·洛克菲勒州长总统竞选活动的高级外交政策顾问。1968年，洛克菲勒在共和党提名中落败，基辛格起初不情愿地加入了该党提名人理查德·尼克松（Richard Nixon）的竞选活动。</p>
<p>Following Nixon’s victory, Dr. Kissinger was named Assistant to the President for National Security Affairs and then National Security Advisor. In this capacity, and eventually as Secretary of State, Dr. Kissinger deftly guided the U.S. through many of the most difficult national security issues the nation would face.<br>尼克松获胜后，基辛格博士被任命为总统国家安全事务助理，然后被任命为国家安全顾问。在这个职位上，并最终作为国务卿，基辛格博士巧妙地指导美国解决了美国将面临的许多最困难的国家安全问题。</p>
<div align="center"> <img src="/images/Influence_5.png"/></div>

<p>He led the Administration’s historic efforts to open relations with China — ultimately opening the door to greater stability between the nations, greater prosperity for the citizens within, and normalized relations between the two countries for the first time in decades. Specifically, in 1971 Dr. Kissinger made two secret trips to China, laying the groundwork for Nixon’s visit to the Republic the following year.<br>他领导了本届政府开放与中国关系的历史性努力，最终为两国之间的更大稳定、国内公民的更大繁荣以及两国关系几十年来首次正常化打开了大门。具体来说，1971年，基辛格博士两次秘密访华，为尼克松次年访华奠定了基础。</p>
<div align="center"> <img src="/images/statesman_2.png"/></div>

<p>Dr. Kissinger believed in the power of triangulation as a tool for diplomacy, and this can be seen in his near-concurrent negotiations with China and the Soviet Union, as well — connecting the world’s three superpowers at the time. Dr. Kissinger later reflected that the triangular relationship was “in itself a form of pressure on each of them, and we carefully maneuvered so we would try to be closer to each than they were to each other.”<br>基辛格博士相信三角测量作为外交工具的力量，这可以从他与中国和苏联几乎同时进行的谈判中看出——当时连接了世界上三个超级大国。基辛格博士后来反映说，三角关系“本身就是对他们每个人施加压力的一种形式，我们小心翼翼地操纵着，所以我们会努力更接近彼此，而不是彼此之间。</p>
<p>“The triangular relationship between the U.S., Soviet Union and China was ‘in itself a form of pressure on each of them, and we carefully maneuvered so we would try to be closer to each than they were to each other.”<br>“美国、苏联和中国之间的三角关系’本身就是对彼此施加压力的一种形式，我们小心翼翼地操纵着，所以我们会努力更接近彼此，而不是彼此之间。<br>Ultimately, Dr. Kissinger was influential in achieving the historic détente between the United States and the Soviet Union through the 1972 Strategic Arms Limitation Treaty (SALT I) and the Anti-Ballistic Missile Treaty. In doing so, he helped to ease tensions between the world’s two superpowers amidst the tension of the Cold War era, achieving a vision for a global order that would preserve peace.<br>最终，基辛格博士通过1972年《限制战略武器条约》（SALT I）和《反弹道导弹条约》实现了美苏之间的历史性缓和，发挥了重要作用。在此过程中，他帮助缓解了冷战时期紧张局势中的世界两个超级大国之间的紧张关系，实现了维护和平的全球秩序的愿景。</p>
<div align="center"> <img src="/images/Statesman_3-1024x623.jpg"/></div>

<div align="center"> <img src="/images/Statesman_4.png"/></div>
Dr. Kissinger also worked to end America’s involvement in the Vietnam War through the Paris Peace Accords. Dr. Kissinger recognized that the conflict could not be won in conventional military terms, so he set about trying to secure peace through active diplomacy. Soon after the Nixon Administration took office in 1969, Dr. Kissinger began painstaking negotiations that lasted nearly four years. In 1973, Dr. Kissinger and the North Vietnamese negotiator struck a deal for a ceasefire that ended American involvement in the war. That same year, he received plaudits for limiting the damage of, and outside influence in, the Yom Kippur War between America’s ally Israel, and the Soviet Union’s ally Egypt — ultimately preventing the regional conflict from spiraling into a global conflict. It was this experience that helped coin the term “shuttle diplomacy,” for the number of short trips Dr. Kissinger took between Middle Eastern capitals, as he worked to contain the military activities and to address the fallout of the war.
基辛格博士还致力于通过《巴黎和平协定》结束美国对越南战争的参与。基辛格博士认识到，以常规军事手段无法赢得这场冲突，因此他开始试图通过积极的外交手段确保和平。1969年尼克松政府上台后不久，基辛格博士就开始了历时近四年的艰苦谈判。1973年，基辛格博士和北越谈判代表达成了停火协议，结束了美国对战争的介入。同年，他因限制美国盟友以色列和苏联盟友埃及之间的赎罪日战争的损害和外部影响而受到赞誉，最终阻止了地区冲突升级为全球冲突。正是这段经历帮助创造了“穿梭外交”一词，基辛格博士在中东各国首都之间进行了多次短途旅行，因为他努力遏制军事活动并解决战争的后果。

<p>In January 1974, over the course of 8 days, Dr. Kissinger worked to negotiate the first Egyptian-Israeli disengagement agreement, and later that spring he arranged a Syrian-Israeli disengagement. The following year, his shuttle diplomacy helped to arrange one final negotiation through a second Egyptian-Israeli disengagement agreement.<br>1974 年 1 月，在 8 天的时间里，基辛格博士致力于谈判第一份埃及-以色列脱离接触协议，并于当年春天晚些时候安排了叙利亚-以色列脱离接触。次年，他的穿梭外交通过第二份埃及-以色列脱离接触协议帮助安排了最后一次谈判。</p>
<p>A force for international stability, Dr. Kissinger was also a steady hand at home when the Nixon Administration was caught in twin scandals that overwhelmed all other matters. As President Nixon was under siege from the Watergate investigation and Vice President Spiro Agnew was about to resign due to corruption allegations, Dr. Kissinger was critical to keeping the Administration afloat. Serving as a credible face for foreign leaders when many other major players in the Nixon Administration were tainted by the Watergate scandal, Dr. Kissinger held the country together on the international stage.<br>基辛格博士是国际稳定的力量，当尼克松政府陷入压倒所有其他事务的双重丑闻时，基辛格博士在国内也是一个稳定的手。当尼克松总统受到水门事件调查的围攻，副总统斯皮罗·阿格纽（Spiro Agnew）因腐败指控而即将辞职时，基辛格博士对维持政府的运转至关重要。当尼克松政府的许多其他主要人物受到水门事件丑闻的玷污时，基辛格博士是外国领导人的可信面孔，他在国际舞台上将国家团结在一起。</p>
<p>While his choices were not without controversy, and his behavior — as he operated with single-minded intent to realize his vision — was sometimes maddening to colleagues, Dr. Kissinger was aware of who he was, and owned it. In his own words, “Accept everything about yourself — I mean everything. You are you and that is the beginning and the end — no apologies, no regrets.”<br>虽然他的选择并非没有争议，而且他的行为——他一心一意地实现自己的愿景——有时会让同事们抓狂，但基辛格博士知道自己是谁，并拥有它。用他自己的话说，“接受关于你自己的一切——我的意思是一切。你就是你，这就是开始和结束——没有道歉，没有遗憾。</p>
<h2 id="Enduring-Influence-持久的影响"><a href="#Enduring-Influence-持久的影响" class="headerlink" title="Enduring Influence 持久的影响"></a>Enduring Influence 持久的影响</h2><p>After Dr. Kissinger stepped down as Secretary of State, he remained an advisor and voice on matters of foreign policy. At the bequest of President Ronald Reagan, Dr. Kissinger chaired the National Bipartisan Commission on Central America, and would later serve on the President’s Foreign Intelligence Advisory Board under Presidents Reagan and George H.W. Bush.<br>基辛格博士卸任国务卿后，他仍然是外交政策事务的顾问和代言人。在罗纳德·里根总统的遗赠下，基辛格博士担任了中美洲国家两党委员会主席，后来在里根总统和乔治·H·W·布什总统的领导下担任总统外国情报顾问委员会的成员。</p>
<div align="center"> <img src="/images/Influence_1.png"/></div>
<div align="center"> <img src="/images/Influence_2.png"/></div>
<div align="center"> <img src="/images/Influence_3.png"/></div>
<div align="center"> <img src="/images/Influence_4.png"/></div>
<div align="center"> <img src="/images/Influence_5.png"/></div>

<p>After leaving government, Dr. Kissinger remained a frequent commentator on national security issues, as well as a prolific writer and founder of the consulting firm Kissinger Associates. As such, he remained an informal, but frequent, advisor to U.S. presidents, and he welcomed and met with countless heads of state and dignitaries from nearly every country in the world.<br>离开政府后，基辛格博士仍然经常就国家安全问题发表评论，也是一位多产的作家和咨询公司基辛格协会的创始人。因此，他仍然是美国总统的非正式顾问，但经常担任顾问，他欢迎并会见了来自世界上几乎每个国家的无数国家元首和政要。</p>
<p>He published 21 books, including 2014’s World Order, 1994’s Diplomacy which has become essential reading for those who study international affairs and U.S. diplomacy, and 2011’s On China, as well as memoirs covering his time in the White House and as Secretary of State.<br>他出版了21本书，包括2014年的《世界秩序》、1994年的《外交》，该书已成为研究国际事务和美国外交的人的必读书目，以及2011年的《论中国》，以及涵盖他在白宫和担任国务卿期间的回忆录。</p>
<p>With his sharp wit and encyclopedic knowledge of philosophy, history and current events, Dr. Kissinger was known as one of the most quotable men in Washington. His most famous witticisms include his observations that “nobody will ever win the battle of the sexes. There’s too much fraternizing with the enemy,” and that “there can’t be a crisis this week. My schedule is already full.”<br>凭借其敏锐的机智和对哲学、历史和时事的百科全书式知识，基辛格博士被称为华盛顿最容易被引用的人之一。他最著名的诙谐包括他的观察：“没有人会赢得两性之战。与敌人有太多的兄弟情谊“，并且”本周不会有危机。我的日程安排已经排得满满的。</p>
<p>He was also aware of his own reputation for having a healthy ego. As he once said during a speech, “I want to thank you for stopping the applause. It’s impossible for me to look humble for any period of time.”<br>他也意识到自己拥有健康的自我的声誉。正如他曾经在一次演讲中所说，“我要感谢你停止了掌声。我不可能在任何一段时间内显得谦虚。</p>
<p>And yet, it was an ego that was earned. International stateman, lifelong scholar, skilled negotiator and architect of a lasting era of peace, stability, prosperity and global order — Dr. Kissinger’s impact on generations of citizens, from the U.S. to China, cannot be minimized.<br>然而，这是一个挣来的自我。基辛格博士是一位国际政治家、终身学者、熟练的谈判者，也是和平、稳定、繁荣和全球秩序的持久时代的缔造者——基辛格博士对从美国到中国的几代公民的影响不容小觑。</p>
<p>Dr. Kissinger is survived by his wife Nancy, his two grown children and five grandchildren.<br>基辛格博士幸存下来的是他的妻子南希、他的两个成年子女和五个孙子孙女。</p>
<p>In lieu of flowers the family suggests considering donations to:<br>为了代替鲜花，家人建议考虑捐赠给：</p>
<p>Animal Medical Center 动物医疗中心</p>
<p>Development Office 发展办公室</p>
<p>510 East 62nd Street<br>东62街510号</p>
<p>New York, NY 10065<br>纽约， NY 10065</p>
<p>Henry A. Kissinger Center for Global Affairs<br>亨利·基辛格全球事务中心</p>
<p>Johns Hopkins University School of Advanced International Studies<br>约翰霍普金斯大学高级国际研究学院</p>
<p>1717 Massachusetts Avenue, NW<br>1717马萨诸塞大道，西北</p>
<p>Washington, DC 20036 华盛顿特区 20036</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>历史事件</tag>
      </tags>
  </entry>
  <entry>
    <title>财富创造机制清单</title>
    <url>/2023/12/01/a-catalog-of-wealth-creation-mmechanisms/</url>
    <content><![CDATA[<p>今天读到一篇关于<a href="https://blog.rongarret.info/2009/10/catalog-of-wealth-creation-mechanisms.html">财富创造机制</a>一些模式的讨论，讨论带来了一些启发，做了一下简单的总结。<br>这篇文章主要讨论了财富创造的基本机制。作者指出，财富与金钱是不同的概念，财富是人们真正看重的物质财产，而金钱只是人类为了促进交易而创造的一种会计机制。在财富创造的核心机制中，作者列举了以下几个要点：</p>
<ul>
<li>将物品从一个地方运送到另一个地方，这是航运业的基础，也是美国工业化的资金来源之一。</li>
<li>存储物品，保持其在可用状态直到有需求，这是零售业的基础。</li>
<li>对物品进行化学或机械转化，这是制造业的基础。</li>
<li>农业，通过将水、二氧化碳和肥料转化为作物和牲畜来创造价值。</li>
<li>建筑建设，由于建筑物无法轻易从一个地方搬到另一个地方，因此需要在现场制造。</li>
<li>从地球或太空中提取自然资源，包括采矿、石油钻探和捕鱼等。</li>
<li>治疗疾病或减轻症状，即医学。</li>
<li>寻找更高效或更有效的做法，即研究或发明。</li>
<li>为人们提供有用的信息，包括帮助供需匹配、解释规则和提供有用信息本身。</li>
</ul>
<p>文章最后提到，尽管许多人关注提供有用信息的领域，但直接将信息转化为金钱并不容易。现代计算机技术使得信息可以几乎免费复制，导致财富创造的同时很少被转化为金钱。然而，对于提供难以获取且对特定市场细分有用的信息，仍然可以通过这种方式赚钱。</p>
]]></content>
  </entry>
  <entry>
    <title>山姆 奥特曼的野心</title>
    <url>/2023/11/27/sam_altman/Successful-people/</url>
    <content><![CDATA[<h1 id="Successful-people-成功人士"><a href="#Successful-people-成功人士" class="headerlink" title="Successful people 成功人士"></a>Successful people 成功人士</h1><p>“Successful people create companies.  More successful people create countries.  The most successful people create religions.”<br>“成功的人创造了公司。 更成功的人创造了国家。 最成功的人创造了宗教。</p>
<p>I heard this from Qi Lu; I’m not sure what the source is.  It got me thinking, though–the most successful founders do not set out to create companies.  They are on a mission to create something closer to a religion, and at some point it turns out that forming a company is the easiest way to do so.<br>我是从齐璐那里听说的;我不确定来源是什么。 不过，这让我开始思考，最成功的创始人不会着手创建公司。 他们的使命是创造更接近宗教的东西，在某些时候，事实证明，成立一家公司是最简单的方法。</p>
<p>In general, the big companies don’t come from pivots, and I think this is most of the reason why.<br>一般来说，大公司不是转型而来，我认为这是大部分原因。</p>
]]></content>
      <categories>
        <category>sam_altman</category>
      </categories>
  </entry>
  <entry>
    <title>Bridge</title>
    <url>/2023/12/06/design-pattern/bridge/</url>
    <content><![CDATA[<h1 id="Bridge-桥接模式"><a href="#Bridge-桥接模式" class="headerlink" title="Bridge 桥接模式"></a>Bridge 桥接模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Bridge</strong> is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.<br><strong>Bridge</strong>是一种结构设计模式，它允许您将一个大型类或一组密切相关的类拆分为两个单独的层次结构（抽象和实现），这两个层次结构可以相互独立开发。</p>
<div align="center"> <img src="/images/bridge-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Abstraction? Implementation? Sound scary? Stay calm and let’s consider a simple example.<br>抽象化？实现？听起来很吓人？保持冷静，让我们考虑一个简单的例子。</p>
<p>Say you have a geometric <code>Shape</code> class with a pair of subclasses: <code>Circle</code> and <code>Square</code>. You want to extend this class hierarchy to incorporate colors, so you plan to create <code>Red</code> and <code>Blue</code> shape subclasses. However, since you already have two subclasses, you’ll need to create four class combinations such as <code>BlueCircle</code> and <code>RedSquare</code>.<br>假设您有一个几何类，其中包含一对子 <code>Shape</code> 类： <code>Circle</code> 和 <code>Square</code> 。您希望扩展此类层次结构以合并颜色，因此您计划创建 <code>Red</code> 和 <code>Blue</code> 调整子类。但是，由于您已经有两个子类，因此需要创建四个类组合，例如 <code>BlueCircle</code> 和 <code>RedSquare</code> 。</p>
<div align="center"> <img src="/images/bridge-problem-en.png"/>Number of class combinations grows in geometric progression.</br>类组合的数量以几何级数增长。</div>
Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you’d need to introduce two subclasses, one for each color. And after that, adding a new color would require creating three subclasses, one for each shape type. The further we go, the worse it becomes.
向层次结构添加新的形状类型和颜色将使其呈指数级增长。例如，要添加三角形形状，您需要引入两个子类，每个子类对应一种颜色。之后，添加新颜色将需要创建三个子类，每个子类对应一个形状类型。我们走得越远，情况就越糟。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>This problem occurs because we’re trying to extend the shape classes in two independent dimensions: by form and by color. That’s a very common issue with class inheritance.<br>出现此问题的原因是，我们尝试在两个独立的维度中扩展形状类：按形状和按颜色。这是类继承的一个非常常见的问题。</p>
<p>The Bridge pattern attempts to solve this problem by switching from inheritance to the object composition. What this means is that you extract one of the dimensions into a separate class hierarchy, so that the original classes will reference an object of the new hierarchy, instead of having all of its state and behaviors within one class.<br>Bridge 模式试图通过从继承切换到对象组合来解决此问题。这意味着将其中一个维度提取到单独的类层次结构中，以便原始类将引用新层次结构的对象，而不是将其所有状态和行为都放在一个类中。</p>
<div align="center"> <img src="/images/bridge-solution-en.png"/>You can prevent the explosion of a class hierarchy by transforming it into several related hierarchies.</br>可以通过将类层次结构转换为多个相关的层次结构来防止类层次结构的爆炸式增长。</div>
Following this approach, we can extract the color-related code into its own class with two subclasses: `Red` and `Blue`. The `Shape` class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the `Shape` and `Color` classes. From now on, adding new colors won’t require changing the shape hierarchy, and vice versa.
按照这种方法，我们可以将与颜色相关的代码提取到它自己的类中，其中包含两个子类： `Red` 和 `Blue` .然后，该 `Shape` 类获取指向其中一个颜色对象的引用字段。现在，形状可以将任何与颜色相关的工作委托给链接的颜色对象。该引用将充当 `Shape` 和 `Color` 类之间的桥梁。从现在开始，添加新颜色将不需要更改形状层次结构，反之亦然。

<h3 id="Abstraction-and-Implementation-抽象和实现"><a href="#Abstraction-and-Implementation-抽象和实现" class="headerlink" title="Abstraction and Implementation 抽象和实现"></a>Abstraction and Implementation 抽象和实现</h3><p>The <a href="https://refactoring.guru/gof-book" title="“Gang of Four” is a nickname given to the four authors of the original book about design patterns: Design Patterns: Elements of Reusable Object-Oriented Software 设计模式：可重用面向对象软件的元素">GoF book</a>  introduces the terms Abstraction and Implementation as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let’s decipher the meaning behind the GoF book’s scary words.<br>GoF一书引入了术语“抽象”和“实现”，作为桥接定义的一部分。在我看来，这些术语听起来太学术化了，使模式看起来比实际情况更复杂。在阅读了带有形状和颜色的简单示例之后，让我们破译 GoF 书的可怕单词背后的含义。</p>
<p>Abstraction (also called interface) is a high-level control layer for some entity. This layer isn’t supposed to do any real work on its own. It should delegate the work to the implementation layer (also called platform).<br>抽象（也称为接口）是某些实体的高级控制层。这个层不应该自己做任何真正的工作。它应该将工作委托给实现层（也称为平台）。</p>
<p>Note that we’re not talking about interfaces or abstract classes from your programming language. These aren’t the same things.<br>请注意，我们不是在谈论编程语言中的接口或抽象类。这些不是一回事。</p>
<p>When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions.<br>在谈论实际应用程序时，抽象可以由图形用户界面 （GUI） 表示，实现可以是 GUI 层为响应用户交互而调用的底层操作系统代码 （API）。</p>
<p>Generally speaking, you can extend such an app in two independent directions:<br>一般来说，您可以在两个独立的方向上扩展此类应用程序：</p>
<ul>
<li>Have several different GUIs (for instance, tailored for regular customers or admins).<br>有几个不同的 GUI（例如，为普通客户或管理员量身定制）。</li>
<li>Support several different APIs (for example, to be able to launch the app under Harmony, Windows, Linux, and macOS).<br>支持多个不同的 API（例如，能够在 Harmony, Windows、Linux 和 macOS 下启动应用程序）。</li>
</ul>
<p>In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code.<br>在最坏的情况下，这个应用程序可能看起来像一个巨大的意大利面碗，其中数百个条件将不同类型的 GUI 与代码中的各种 API 连接起来。</p>
<div align="center"> <img src="/images/bridge-bridge-3-en.png"/>Making even a simple change to a monolithic codebase is pretty hard because you must understand the entire thing very well. Making changes to smaller, well-defined modules is much easier.</br>即使是对单体代码库进行简单的更改也非常困难，因为您必须很好地理解整个事情。对更小、定义明确的模块进行更改要容易得多。</div>
You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you’ll discover that there are lots of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes.
您可以通过将与特定接口平台组合相关的代码提取到单独的类中来恢复这种混乱。但是，很快您就会发现有很多这样的课程。类层次结构将呈指数级增长，因为添加新的 GUI 或支持不同的 API 需要创建越来越多的类。

<p>Let’s try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies:<br>让我们尝试使用 Bridge 模式来解决这个问题。它建议我们将类分为两个层次结构：</p>
<ul>
<li>Abstraction: the GUI layer of the app.<br>抽象：应用的 GUI 层。</li>
<li>Implementation: the operating systems’ APIs.<br>实现：操作系统的 API。<div align="center"> <img src="/images/bridge-bridge-2-en.png"/>One of the ways to structure a cross-platform application.</br>构建跨平台应用程序的方法之一。</div>
The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Harmony, Windows and Linux.
抽象对象控制应用的外观，将实际工作委托给链接的实现对象。不同的实现是可以互换的，只要它们遵循一个通用的接口，使相同的 GUI 能够在Harmony, Windows 和 Linux 下工作。</li>
</ul>
<p>As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.<br>因此，您可以在不接触 API 相关类的情况下更改 GUI 类。此外，添加对另一个操作系统的支持只需要在实现层次结构中创建一个子类。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/bridge-structure-en.png"/></div>

<ol>
<li><p>The <strong>Abstraction</strong> provides high-level control logic. It relies on the implementation object to do the actual low-level work.<br>抽象提供高级控制逻辑。它依赖于实现对象来执行实际的低级工作。</p>
</li>
<li><p>The <strong>Implementation</strong> declares the interface that’s common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here.<br>实现声明了所有具体实现通用的接口。抽象只能通过此处声明的方法与实现对象进行通信。</p>
</li>
<li><p><strong>Concrete Implementations</strong> contain platform-specific code.<br>具体实现包含特定于平台的代码。</p>
</li>
<li><p><strong>Refined Abstractions</strong> provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.<br>精炼的抽象提供了控制逻辑的变体。与它们的父级一样，它们通过通用实现接口使用不同的实现。</p>
</li>
<li><p>Usually, the <strong>Client</strong> is only interested in working with the abstraction. However, it’s the client’s job to link the abstraction object with one of the implementation objects.<br>通常，客户端只对处理抽象感兴趣。但是，客户端的工作是将抽象对象与其中一个实现对象链接起来。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the <strong>Bridge</strong> pattern can help divide the monolithic code of an app that manages devices and their remote controls. The <code>Device</code> classes act as the implementation, whereas the <code>Remote</code>s act as the abstraction.<br>此示例演示了 Bridge 模式如何帮助划分管理设备及其遥控器的应用的整体代码。 <code>Device</code> 类充当实现，而 <code>Remote</code>s 充当抽象。</p>
<div align="center"> <img src="/images/bridge-example-en.png"/>The original class hierarchy is divided into two parts: devices and remote controls.</br>原始的类层次结构分为两部分：设备和遥控器。</div>
The base remote control class declares a reference field that links it with a device object. All remotes work with the devices via the general device interface, which lets the same remote support multiple device types.
基远程控制类声明一个引用字段，该字段将其与设备对象链接。所有遥控器都通过通用设备接口与设备配合使用，这使得同一个遥控器支持多种设备类型。

<p>You can develop the remote control classes independently from the device classes. All that’s needed is to create a new remote subclass. For example, a basic remote control might only have two buttons, but you could extend it with additional features, such as an extra battery or a touchscreen.<br>您可以独立于设备类开发远程控制类。所需要的只是创建一个新的远程子类。例如，一个基本的遥控器可能只有两个按钮，但您可以使用其他功能（例如额外的电池或触摸屏）对其进行扩展。</p>
<p>The client code links the desired type of remote control with a specific device object via the remote’s constructor.<br>客户端代码通过遥控器的构造函数将所需类型的遥控器与特定设备对象链接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The &quot;abstraction&quot; defines the interface for the &quot;control&quot;</span></span><br><span class="line"><span class="comment">// part of the two class hierarchies. It maintains a reference</span></span><br><span class="line"><span class="comment">// to an object of the &quot;implementation&quot; hierarchy and delegates</span></span><br><span class="line"><span class="comment">// all of the real work to this object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">    <span class="keyword">protected</span> field device: Device</span><br><span class="line">    constructor <span class="title function_">RemoteControl</span><span class="params">(device: Device)</span> is</span><br><span class="line">        <span class="built_in">this</span>.device = device</span><br><span class="line">    method <span class="title function_">togglePower</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(device.isEnabled()</span>) then</span><br><span class="line">            device.disable()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            device.enable()</span><br><span class="line">    method <span class="title function_">volumeDown</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(device.getVolume() - <span class="number">10</span>)</span><br><span class="line">    method <span class="title function_">volumeUp</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(device.getVolume() + <span class="number">10</span>)</span><br><span class="line">    method <span class="title function_">channelDown</span><span class="params">()</span> is</span><br><span class="line">        device.setChannel(device.getChannel() - <span class="number">1</span>)</span><br><span class="line">    method <span class="title function_">channelUp</span><span class="params">()</span> is</span><br><span class="line">        device.setChannel(device.getChannel() + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can extend classes from the abstraction hierarchy</span></span><br><span class="line"><span class="comment">// independently from device classes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedRemoteControl</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">    method <span class="title function_">mute</span><span class="params">()</span> is</span><br><span class="line">        device.setVolume(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The &quot;implementation&quot; interface declares methods common to all</span></span><br><span class="line"><span class="comment">// concrete implementation classes. It doesn&#x27;t have to match the</span></span><br><span class="line"><span class="comment">// abstraction&#x27;s interface. In fact, the two interfaces can be</span></span><br><span class="line"><span class="comment">// entirely different. Typically the implementation interface</span></span><br><span class="line"><span class="comment">// provides only primitive operations, while the abstraction</span></span><br><span class="line"><span class="comment">// defines higher-level operations based on those primitives.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Device</span> is</span><br><span class="line">    method <span class="title function_">isEnabled</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">enable</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">disable</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">getVolume</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setVolume</span><span class="params">(percent)</span></span><br><span class="line">    method <span class="title function_">getChannel</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setChannel</span><span class="params">(channel)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// All devices follow the same interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code.</span></span><br><span class="line">tv = <span class="keyword">new</span> <span class="title class_">Tv</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> <span class="title class_">Radio</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">AdvancedRemoteControl</span>(radio)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Bridge pattern when you want to divide and organize a monolithic class that has several variants of some functionality (for example, if the class can work with various database servers).如果要划分和组织具有某些功能的多个变体的整体类（例如，如果该类可以与各种数据库服务器一起使用），请使用 Bridge 模式。</strong></p>
</li>
<li><p>The bigger a class becomes, the harder it is to figure out how it works, and the longer it takes to make a change. The changes made to one of the variations of functionality may require making changes across the whole class, which often results in making errors or not addressing some critical side effects.<br>一个班级变得越大，就越难弄清楚它是如何工作的，做出改变所需的时间就越长。对功能变体之一所做的更改可能需要在整个类中进行更改，这通常会导致出错或无法解决一些关键的副作用。</p>
</li>
</ul>
<p>The Bridge pattern lets you split the monolithic class into several class hierarchies. After this, you can change the classes in each hierarchy independently of the classes in the others. This approach simplifies code maintenance and minimizes the risk of breaking existing code.<br>Bridge 模式允许您将整体类拆分为多个类层次结构。在此之后，您可以独立于其他层次结构中的类更改每个层次结构中的类。此方法简化了代码维护，并最大限度地降低了破坏现有代码的风险。</p>
<ul>
<li><p><strong>Use the pattern when you need to extend a class in several orthogonal (independent) dimensions. 当您需要在多个正交（独立）维度中扩展类时，请使用该模式。</strong></p>
</li>
<li><p>The Bridge suggests that you extract a separate class hierarchy for each of the dimensions. The original class delegates the related work to the objects belonging to those hierarchies instead of doing everything on its own.<br>Bridge 建议您为每个维度提取单独的类层次结构。原始类将相关工作委托给属于这些层次结构的对象，而不是自己执行所有操作。</p>
</li>
</ul>
<p> Use the Bridge if you need to be able to switch implementations at runtime.<br>如果您需要能够在运行时切换实现，请使用 Bridge。</p>
<p> Although it’s optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It’s as easy as assigning a new value to a field.<br>尽管它是可选的，但 Bridge 模式允许您替换抽象中的实现对象。这就像为字段分配新值一样简单。</p>
<p>By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed.<br>顺便说一句，最后一项是这么多人将桥接模式与策略模式混淆的主要原因。请记住，模式不仅仅是构建类的某种方式。它还可以传达意图和正在解决的问题。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction&#x2F;platform, domain&#x2F;infrastructure, front-end&#x2F;back-end, or interface&#x2F;implementation.<br>确定类中的正交维度。这些独立的概念可以是：抽象&#x2F;平台、域&#x2F;基础结构、前端&#x2F;后端或接口&#x2F;实现。</p>
</li>
<li><p>See what operations the client needs and define them in the base abstraction class.<br>查看客户端需要哪些操作，并在基抽象类中定义它们。</p>
</li>
<li><p>Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.<br>确定所有平台上可用的操作。在通用实现接口中声明抽象需要的那些。</p>
</li>
<li><p>For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.<br>对于域中的所有平台，请创建具体的实现类，但请确保它们都遵循实现接口。</p>
</li>
<li><p>Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that’s referenced in that field.<br>在抽象类中，为实现类型添加一个引用字段。抽象将大部分工作委托给该字段中引用的实现对象。</p>
</li>
<li><p>If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.<br>如果有多个高级逻辑变体，请通过扩展基本抽象类为每个变体创建精细的抽象。</p>
</li>
<li><p>The client code should pass an implementation object to the abstraction’s constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.<br>客户端代码应将实现对象传递给抽象的构造函数，以将一个对象与另一个对象相关联。之后，客户端可以忘记实现，只使用抽象对象。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can create platform-independent classes and apps.您可以创建与平台无关的类和应用。</td>
<td>You might make the code more complicated by applying the pattern to a highly cohesive class. 通过将模式应用于高度内聚的类，可以使代码更加复杂。</td>
</tr>
<tr>
<td>The client code works with high-level abstractions. It isn’t exposed to the platform details. 客户端代码使用高级抽象。它不会公开给平台详细信息。</td>
<td></td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new abstractions and implementations independently from each other. 开&#x2F;闭原理。您可以引入新的抽象和实现，彼此独立。</td>
<td></td>
</tr>
<tr>
<td>Single Responsibility Principle. You can focus on high-level logic in the abstraction and on platform details in the implementation. 单一责任原则。您可以专注于抽象中的高级逻辑和实现中的平台细节。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p><strong>Bridge</strong> is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, <strong>Adapter</strong> is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.<br><strong>Bridge</strong> 通常是预先设计的，允许您彼此独立地开发应用程序的各个部分。另一方面，<strong>Adapter</strong> 通常与现有应用程序一起使用，以使一些不兼容的类很好地协同工作。</p>
</li>
<li><p><strong>Bridge, State, Strategy</strong> (and to some degree <strong>Adapter</strong>) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.<br>桥接、状态、策略（在某种程度上还有适配器）具有非常相似的结构。事实上，所有这些模式都是基于构图的，而构图是将工作委托给其他对象。但是，它们都解决了不同的问题。模式不仅仅是以特定方式构建代码的秘诀。它还可以向其他开发人员传达该模式解决的问题。</p>
</li>
<li><p>You can use <strong>Abstract Factory</strong> along with <strong>Bridge</strong>. This pairing is useful when some abstractions defined by <strong>Bridge</strong> can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.</p>
</li>
<li><p>You can combine <strong>Builder</strong> with <strong>Bridge</strong>: the director class plays the role of the abstraction, while different builders act as implementations.<br>您可以将 <strong>Builder</strong> 与 <strong>Bridge</strong> 结合使用：director 类扮演抽象的角色，而不同的构建器充当实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-概念示例"><a href="#Python-Conceptual-Example-概念示例" class="headerlink" title="Python Conceptual Example 概念示例"></a>Python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Bridge design pattern. It focuses on answering these questions:<br>此示例说明了 Bridge 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstraction defines the interface for the &quot;control&quot; part of the two</span></span><br><span class="line"><span class="string">    class hierarchies. It maintains a reference to an object of the</span></span><br><span class="line"><span class="string">    Implementation hierarchy and delegates all of the real work to this object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, implementation: Implementation</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.implementation = implementation</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;Abstraction: Base operation with:\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;self.implementation.operation_implementation()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendedAbstraction</span>(<span class="title class_ inherited__">Abstraction</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    You can extend the Abstraction without changing the Implementation classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;ExtendedAbstraction: Extended operation with:\n&quot;</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;self.implementation.operation_implementation()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Implementation defines the interface for all implementation classes. It</span></span><br><span class="line"><span class="string">    doesn&#x27;t have to match the Abstraction&#x27;s interface. In fact, the two</span></span><br><span class="line"><span class="string">    interfaces can be entirely different. Typically the Implementation interface</span></span><br><span class="line"><span class="string">    provides only primitive operations, while the Abstraction defines higher-</span></span><br><span class="line"><span class="string">    level operations based on those primitives.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Each Concrete Implementation corresponds to a specific platform and implements</span></span><br><span class="line"><span class="string">the Implementation interface using that platform&#x27;s API.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span>(<span class="title class_ inherited__">Implementation</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteImplementationA: Here&#x27;s the result on the platform A.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span>(<span class="title class_ inherited__">Implementation</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_implementation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteImplementationB: Here&#x27;s the result on the platform B.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">abstraction: Abstraction</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Except for the initialization phase, where an Abstraction object gets linked</span></span><br><span class="line"><span class="string">    with a specific Implementation object, the client code should only depend on</span></span><br><span class="line"><span class="string">    the Abstraction class. This way the client code can support any abstraction-</span></span><br><span class="line"><span class="string">    implementation combination.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(abstraction.operation(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code should be able to work with any pre-configured abstraction-</span></span><br><span class="line"><span class="string">    implementation combination.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    implementation = ConcreteImplementationA()</span><br><span class="line">    abstraction = Abstraction(implementation)</span><br><span class="line">    client_code(abstraction)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    implementation = ConcreteImplementationB()</span><br><span class="line">    abstraction = ExtendedAbstraction(implementation)</span><br><span class="line">    client_code(abstraction)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstraction: Base operation with:</span><br><span class="line">ConcreteImplementationA: Here&#x27;s the result on the platform A.</span><br><span class="line"></span><br><span class="line">ExtendedAbstraction: Extended operation with:</span><br><span class="line">ConcreteImplementationB: Here&#x27;s the result on the platform B.</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Conceptual-Example-概念示例"><a href="#Rust-Conceptual-Example-概念示例" class="headerlink" title="Rust Conceptual Example 概念示例"></a>Rust Conceptual Example 概念示例</h3><h4 id="Devices-and-Remotes-设备和遥控器"><a href="#Devices-and-Remotes-设备和遥控器" class="headerlink" title="Devices and Remotes 设备和遥控器"></a>Devices and Remotes 设备和遥控器</h4><p>This example illustrates how the Bridge pattern can help divide the monolithic code of an app that manages devices and their remote controls. The Device classes act as the implementation, whereas the Remotes act as the abstraction.<br>此示例演示了 Bridge 模式如何帮助划分管理设备及其遥控器的应用的整体代码。Device 类充当实现，而 Remote 充当抽象。</p>
<h4 id="remotes-mod-rs"><a href="#remotes-mod-rs" class="headerlink" title="remotes&#x2F;mod.rs"></a>remotes&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> advanced;</span><br><span class="line"><span class="keyword">mod</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> advanced::AdvancedRemove;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> basic::BasicRemote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HasMutableDevice</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Remote</span>&lt;D: Device&gt;: HasMutableDevice&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">power</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: power toggle&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">is_enabled</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">disable</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">enable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume_down</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: volume down&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">volume</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">volume</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_volume</span>(volume - <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume_up</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: volume up&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">volume</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">volume</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_volume</span>(volume + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel_down</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: channel down&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_channel</span>(channel - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel_up</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: channel up&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">set_channel</span>(channel + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="remotes-basic-rs"><a href="#remotes-basic-rs" class="headerlink" title="remotes&#x2F;basic.rs"></a>remotes&#x2F;basic.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::&#123;HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BasicRemote</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    device: D,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; BasicRemote&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(device: D) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; device &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; HasMutableDevice&lt;D&gt; <span class="keyword">for</span> <span class="title class_">BasicRemote</span>&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.device</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; Remote&lt;D&gt; <span class="keyword">for</span> <span class="title class_">BasicRemote</span>&lt;D&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remotes-advanced-rs"><a href="#remotes-advanced-rs" class="headerlink" title="remotes&#x2F;advanced.rs"></a>remotes&#x2F;advanced.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::device::Device;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::&#123;HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AdvancedRemote</span>&lt;D: Device&gt; &#123;</span><br><span class="line">    device: D,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; AdvancedRemote&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(device: D) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; device &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mute</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Remote: mute&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.device.<span class="title function_ invoke__">set_volume</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; HasMutableDevice&lt;D&gt; <span class="keyword">for</span> <span class="title class_">AdvancedRemote</span>&lt;D&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">device</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> D &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.device</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;D: Device&gt; Remote&lt;D&gt; <span class="keyword">for</span> <span class="title class_">AdvancedRemote</span>&lt;D&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="device-mod-rs"><a href="#device-mod-rs" class="headerlink" title="device&#x2F;mod.rs"></a>device&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> radio;</span><br><span class="line"><span class="keyword">mod</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> radio::Radio;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> tv::Tv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="device-radio-rs"><a href="#device-radio-rs" class="headerlink" title="device&#x2F;radio.rs"></a>device&#x2F;radio.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Device;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    on: <span class="type">bool</span>,</span><br><span class="line">    volume: <span class="type">u8</span>,</span><br><span class="line">    channel: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            on: <span class="literal">false</span>,</span><br><span class="line">            volume: <span class="number">30</span>,</span><br><span class="line">            channel: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Device</span> <span class="keyword">for</span> <span class="title class_">Radio</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume = std::cmp::<span class="title function_ invoke__">min</span>(percent, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m radio.&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m &#123;&#125;&quot;</span>, <span class="keyword">if</span> <span class="keyword">self</span>.on &#123; <span class="string">&quot;enabled&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;disabled&quot;</span> &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current volume is &#123;&#125;%&quot;</span>, <span class="keyword">self</span>.volume);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current channel is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.channel);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="device-tv-rs"><a href="#device-tv-rs" class="headerlink" title="device&#x2F;tv.rs"></a>device&#x2F;tv.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Device;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    on: <span class="type">bool</span>,</span><br><span class="line">    volume: <span class="type">u8</span>,</span><br><span class="line">    channel: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            on: <span class="literal">false</span>,</span><br><span class="line">            volume: <span class="number">30</span>,</span><br><span class="line">            channel: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Device</span> <span class="keyword">for</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_enabled</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">disable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.on = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_volume</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, percent: <span class="type">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume = std::cmp::<span class="title function_ invoke__">min</span>(percent, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_channel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_status</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m TV set.&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| I&#x27;m &#123;&#125;&quot;</span>, <span class="keyword">if</span> <span class="keyword">self</span>.on &#123; <span class="string">&quot;enabled&quot;</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;disabled&quot;</span> &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current volume is &#123;&#125;%&quot;</span>, <span class="keyword">self</span>.volume);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;| Current channel is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.channel);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> device;</span><br><span class="line"><span class="keyword">mod</span> remotes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> device::&#123;Device, Radio, Tv&#125;;</span><br><span class="line"><span class="keyword">use</span> remotes::&#123;AdvancedRemove, BasicRemote, HasMutableDevice, Remote&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test_device</span>(Tv::<span class="title function_ invoke__">default</span>());</span><br><span class="line">    <span class="title function_ invoke__">test_device</span>(Radio::<span class="title function_ invoke__">default</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_device</span>(device: <span class="keyword">impl</span> <span class="title class_">Device</span> + <span class="built_in">Clone</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tests with basic remote.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">basic_remote</span> = BasicRemote::<span class="title function_ invoke__">new</span>(device.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    basic_remote.<span class="title function_ invoke__">power</span>();</span><br><span class="line">    basic_remote.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">print_status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tests with advanced remote.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">advanced_remote</span> = AdvancedRemove::<span class="title function_ invoke__">new</span>(device);</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">power</span>();</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">mute</span>();</span><br><span class="line">    advanced_remote.<span class="title function_ invoke__">device</span>().<span class="title function_ invoke__">print_status</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tests with basic remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m TV set.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 30%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with advanced remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">Remote: mute</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m TV set.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 0%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with basic remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m radio.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 30%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">Tests with advanced remote.</span><br><span class="line">Remote: power toggle</span><br><span class="line">Remote: mute</span><br><span class="line">------------------------------------</span><br><span class="line">| I&#x27;m radio.</span><br><span class="line">| I&#x27;m enabled</span><br><span class="line">| Current volume is 0%</span><br><span class="line">| Current channel is 1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>maydat-lip-syncing</title>
    <url>/2023/12/04/mayday-lip-syncing/</url>
    <content><![CDATA[<h3 id="今日单词"><a href="#今日单词" class="headerlink" title="今日单词"></a>今日单词</h3><div align="center"> <img src="/images/lip-synches.png"/>今日单词</div>

<h1 id="Mayday-lip-synches-五月天假唱"><a href="#Mayday-lip-synches-五月天假唱" class="headerlink" title="Mayday lip-synches 五月天假唱"></a>Mayday lip-synches 五月天假唱</h1><h1 id="什么才是真正的摇滚精神？"><a href="#什么才是真正的摇滚精神？" class="headerlink" title="什么才是真正的摇滚精神？"></a>什么才是真正的摇滚精神？</h1><p>真正的摇滚精神是一种对自由、反叛和个人表达的热情。它代表着对传统观念的挑战，对权威和束缚的抗拒。摇滚精神鼓励个体追求自己的激情和独立思考，不受限制地表达自己的声音和观点。它强调对社会问题和不公正的关注，并通过音乐和艺术表达对这些问题的批判和反思。摇滚精神是一种生活态度，鼓励人们勇敢地追求自己的梦想，坚持自己的价值观，并与他人分享共同的热情和信念。</p>
<h2 id="一个歌手假唱意味着什么？"><a href="#一个歌手假唱意味着什么？" class="headerlink" title="一个歌手假唱意味着什么？"></a>一个歌手假唱意味着什么？</h2><p>一个歌手假唱意味着他或她在现场演出时并没有真正地唱歌，而是通过播放预先录制的音乐来模拟演唱。这通常被认为是一种不诚实和欺骗观众的行为，因为观众可能会认为他们正在观看一场真正的现场表演，而事实上，演出者并没有真正地展示他们的音乐才华。此外，假唱也可能违反某些演出和音乐产业的道德标准和规定。</p>
<h2 id="一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？"><a href="#一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？" class="headerlink" title="一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？"></a>一个摇滚歌手假唱符合摇滚精神吗？他的内心能过的安宁吗？</h2><p>摇滚精神强调真实、自由和个人表达，因此一个摇滚歌手假唱与摇滚精神并不相符。假唱被认为是一种不诚实的行为，摇滚精神鼓励艺术家真实地展示他们的才华和表达自己的声音。假唱可能会削弱观众对艺术家的信任和尊重，破坏他们与观众之间的联系。</p>
<p>至于内心的安宁，这是一个个体的感受，每个人的体验可能不同。然而，对于许多艺术家来说，真实地表达自己是一种重要的价值观和追求。当一个摇滚歌手选择假唱时，可能会在内心产生不安和冲突，因为他们没有真正地展示自己的音乐才华和个人表达。因此，假唱可能会对他们的内心和艺术追求造成一定程度的困扰。</p>
<h2 id="演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？"><a href="#演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？" class="headerlink" title="演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？"></a>演唱会假唱对于一个摇滚歌手来说属于轻微错误还是严重错误？</h2><p>对于一个摇滚歌手来说，演唱会假唱可以被认为是一个严重错误。摇滚音乐注重现场表演的真实性和能量，观众期望在演唱会上亲眼见证歌手的实力和情感投入。选择假唱可能会被认为是一种欺骗观众的行为，削弱了演唱会的真实性和互动性。这可能会对歌手的声誉和信任度造成负面影响，并引发观众的不满和失望。</p>
<p>然而，每个情况都是独特的，有时候摇滚歌手选择假唱可能是出于保护嗓子健康或其他技术或声音问题的考虑。因此，如何评价这个错误的严重程度可能因情况而异。但总体而言，对于一个摇滚歌手来说，选择假唱在摇滚音乐领域中可能被视为一个严重错误。</p>
]]></content>
  </entry>
  <entry>
    <title>Composite 部分-整体模式</title>
    <url>/2023/12/07/design-pattern/composite/</url>
    <content><![CDATA[<h1 id="Composite-部分-整体模式"><a href="#Composite-部分-整体模式" class="headerlink" title="Composite 部分-整体模式"></a>Composite 部分-整体模式</h1><p>Also known as: Object Tree<br>也称为：对象树</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Composite</strong> is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.<br>复合是一种结构设计模式，可用于将对象组合成树结构，然后像使用单个对象一样处理这些结构。</p>
<div align="center"> <img src="/images/composite-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Using the Composite pattern makes sense only when the core model of your app can be represented as a tree.<br>只有当应用的核心模型可以表示为树时，使用复合模式才有意义。</p>
<p>For example, imagine that you have two types of objects: <code>Products</code> and <code>Boxes</code>. A <code>Box</code> can contain several <code>Products</code> as well as a number of smaller <code>Boxes</code>. These little <code>Boxes</code> can also hold some <code>Products</code> or even smaller <code>Boxes</code>, and so on.<br>例如，假设您有两种类型的对象： <code>Products</code> 和 <code>Boxes</code>。 一个 <code>Box</code> 可以包含多个以及多个 <code>Products</code> 较小的 <code>Boxes</code>。这些小的也可以容纳一些 <code>Products</code> 甚至更小 <code>Boxes</code> 的 <code>Boxes</code> ，以此类推。</p>
<p>Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products…and other boxes. How would you determine the total price of such an order?<br>假设您决定创建一个使用这些类的排序系统。订单可以包含没有任何包装的简单产品，也可以包含装满产品的盒子……和其他盒子。您如何确定此类订单的总价？</p>
<div align="center"> <img src="/images/composite-problem-en.png"/>An order might comprise various products, packaged in boxes, which are packaged in bigger boxes and so on. The whole structure looks like an upside down tree.</br>一个订单可能包括各种产品，包装在盒子里，这些产品包装在更大的盒子里，依此类推。整个结构看起来像一棵倒置的树。</div>

<p>You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it’s not as simple as running a loop. You have to know the classes of <code>Products</code> and <code>Boxes</code> you’re going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.<br>您可以尝试直接方法：打开所有盒子，检查所有产品，然后计算总数。这在现实世界中是可行的;但在程序中，它并不像运行循环那么简单。你必须事先知道 <code>Boxes</code> 你正在经历的 <code>Products</code> 类别、盒子的嵌套级别和其他令人讨厌的细节。所有这些都使得直接方法要么过于尴尬，甚至不可能。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Composite pattern suggests that you work with <code>Products</code> and <code>Boxes</code> through a common interface which declares a method for calculating the total price.<br>复合模式建议您使用 <code>Products</code> 并通过 <code>Boxes</code> 一个通用接口进行工作，该接口声明了计算总价的方法。</p>
<p>How would this method work? For a product, it’d simply return the product’s price. For a box, it’d go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost.<br>这种方法如何工作？对于产品，它只会返回产品的价格。对于一个盒子，它会检查盒子里的每件物品，询问它的价格，然后返回这个盒子的总数。如果其中一个物品是一个较小的盒子，那么该盒子也会开始检查其内容，依此类推，直到计算出所有内部组件的价格。一个盒子甚至会给最终价格增加一些额外的成本，比如包装成本。</p>
<div align="center"> <img src="/images/composite-comic-1-en.png"/>The Composite pattern lets you run a behavior recursively over all components of an object tree.</br>Composite 模式允许您以递归方式对对象树的所有组件运行行为。</div>

<p>The greatest benefit of this approach is that you don’t need to care about the concrete classes of objects that compose the tree. You don’t need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.<br>这种方法的最大好处是，您不需要关心组成树的具体对象类。您不需要知道一个对象是简单的产品还是复杂的盒子。您可以通过通用界面对它们一视同仁。调用方法时，对象本身会将请求传递到树中。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><div align="center"> <img src="/images/composite-live-example.png"/>An example of a military structure.</br>军事结构的一个例子。</div>
Armies of most countries are structured as hierarchies. An army consists of several divisions; a division is a set of brigades, and a brigade consists of platoons, which can be broken down into squads. Finally, a squad is a small group of real soldiers. Orders are given at the top of the hierarchy and passed down onto each level until every soldier knows what needs to be done.
大多数国家的军队都是等级制度。一支军队由几个师组成;一个师是一组旅，一个旅由排组成，排可以分解成小队。最后，小队是一小群真正的士兵。命令在等级制度的顶端下达，并向下传递到每个级别，直到每个士兵都知道需要做什么。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/composite-structure-en.png"/></div>

<ol>
<li><p>The <strong>Component</strong> interface describes operations that are common to both simple and complex elements of the tree.<br><strong>Component</strong> 接口描述树的简单元素和复杂元素通用的操作。</p>
</li>
<li><p>The Leaf is a basic element of a tree that doesn’t have sub-elements.<br>叶子是树的基本元素，没有子元素。</p>
</li>
</ol>
<p>Usually, leaf components end up doing most of the real work, since they don’t have anyone to delegate the work to.<br>通常，叶子组件最终会完成大部分实际工作，因为它们没有人可以将工作委派给它们。</p>
<ol start="3">
<li>The <strong>Container</strong> (aka composite) is an element that has sub-elements: leaves or other containers. A container doesn’t know the concrete classes of its children. It works with all sub-elements only via the component interface.<br>容器（又名复合）是一个具有子元素的元素：树叶或其他容器。容器不知道其子项的具体类。它仅通过组件接口处理所有子元素。</li>
</ol>
<p>Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.<br>收到请求后，容器将工作委托给其子元素，处理中间结果，然后将最终结果返回给客户端。</p>
<ol start="4">
<li>The <strong>Client</strong> works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.<br>客户端通过组件接口处理所有元素。因此，客户端可以以相同的方式处理树的简单或复杂元素。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the <strong>Composite</strong> pattern lets you implement stacking of geometric shapes in a graphical editor.<br>在此示例中，复合模式允许您在图形编辑器中实现几何形状的堆叠。</p>
<div align="center"> <img src="/images/composite-example1.png"/>The geometric shapes editor example.</br>几何形状编辑器示例。</div>

<p>The <code>CompoundGraphic</code> class is a container that can comprise any number of sub-shapes, including other compound shapes. A compound shape has the same methods as a simple shape. However, instead of doing something on its own, a compound shape passes the request recursively to all its children and “sums up” the result.<br>该 <code>CompoundGraphic</code> 类是一个容器，可以包含任意数量的子形状，包括其他复合形状。复合形状与简单形状具有相同的方法。但是，复合形状不是自己执行某些操作，而是以递归方式将请求传递给其所有子项，并“汇总”结果。</p>
<p>The client code works with all shapes through the single interface common to all shape classes. Thus, the client doesn’t know whether it’s working with a simple shape or a compound one. The client can work with very complex object structures without being coupled to concrete classes that form that structure.<br>客户端代码通过所有形状类通用的单个接口处理所有形状。因此，客户不知道它是在处理简单形状还是复合形状。客户端可以使用非常复杂的对象结构，而无需与构成该结构的具体类耦合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The component interface declares common operations for both</span></span><br><span class="line"><span class="comment">// simple and complex objects of a composition.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The leaf class represents end objects of a composition. A</span></span><br><span class="line"><span class="comment">// leaf object can&#x27;t have any sub-objects. Usually, it&#x27;s leaf</span></span><br><span class="line"><span class="comment">// objects that do the actual work, while composite objects only</span></span><br><span class="line"><span class="comment">// delegate to their sub-components.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dot</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    field x, y</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Dot</span><span class="params">(x, y)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">        <span class="built_in">this</span>.x += x, <span class="built_in">this</span>.y += y</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Draw a dot at X and Y.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All component classes can extend other components.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Dot</span> is</span><br><span class="line">    field radius</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Circle</span><span class="params">(x, y, radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Draw a circle at X and Y with radius R.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The composite class represents complex components that may</span></span><br><span class="line"><span class="comment">// have children. Composite objects usually delegate the actual</span></span><br><span class="line"><span class="comment">// work to their children and then &quot;sum up&quot; the result.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundGraphic</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">    field children: array of Graphic</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A composite object can add or remove other components</span></span><br><span class="line">    <span class="comment">// (both simple or complex) to or from its child list.</span></span><br><span class="line">    method <span class="title function_">add</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">        <span class="comment">// Add a child to the array of children.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">remove</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">        <span class="comment">// Remove a child from the array of children.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">        <span class="title function_">foreach</span> <span class="params">(child in children)</span> <span class="keyword">do</span></span><br><span class="line">            child.move(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A composite executes its primary logic in a particular</span></span><br><span class="line">    <span class="comment">// way. It traverses recursively through all its children,</span></span><br><span class="line">    <span class="comment">// collecting and summing up their results. Since the</span></span><br><span class="line">    <span class="comment">// composite&#x27;s children pass these calls to their own</span></span><br><span class="line">    <span class="comment">// children and so forth, the whole object tree is traversed</span></span><br><span class="line">    <span class="comment">// as a result.</span></span><br><span class="line">    method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 1. For each child component:</span></span><br><span class="line">        <span class="comment">//     - Draw the component.</span></span><br><span class="line">        <span class="comment">//     - Update the bounding rectangle.</span></span><br><span class="line">        <span class="comment">// 2. Draw a dashed rectangle using the bounding</span></span><br><span class="line">        <span class="comment">// coordinates.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code works with all the components via their base</span></span><br><span class="line"><span class="comment">// interface. This way the client code can support simple leaf</span></span><br><span class="line"><span class="comment">// components as well as complex composites.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageEditor</span> is</span><br><span class="line">    field all: CompoundGraphic</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">load</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">all</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">        all.add(<span class="keyword">new</span> <span class="title class_">Dot</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        all.add(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>))</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combine selected components into one complex composite</span></span><br><span class="line">    <span class="comment">// component.</span></span><br><span class="line">    method <span class="title function_">groupSelected</span><span class="params">(components: array of Graphic)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">        foreach (component in components) <span class="keyword">do</span></span><br><span class="line">            group.add(component)</span><br><span class="line">            all.remove(component)</span><br><span class="line">        all.add(group)</span><br><span class="line">        <span class="comment">// All components will be drawn.</span></span><br><span class="line">        all.draw()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p>** Use the Composite pattern when you have to implement a tree-like object structure. 当必须实现树状对象结构时，请使用 Composite 模式。**</p>
</li>
<li><p>The Composite pattern provides you with two basic element types that share a common interface: simple leaves and complex containers. A container can be composed of both leaves and other containers. This lets you construct a nested recursive object structure that resembles a tree.<br>Composite 模式为您提供了两种共享通用接口的基本元素类型：简单叶子和复杂容器。容器可以由叶子和其他容器组成。这使您可以构造类似于树的嵌套递归对象结构。</p>
</li>
<li><p><strong>Use the pattern when you want the client code to treat both simple and complex elements uniformly. 如果希望客户端代码统一处理简单元素和复杂元素，请使用该模式。</strong></p>
</li>
<li><p>All elements defined by the Composite pattern share a common interface. Using this interface, the client doesn’t have to worry about the concrete class of the objects it works with.<br>Composite 模式定义的所有元素共享一个公共接口。使用此接口，客户端不必担心它所处理的对象的具体类。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that the core model of your app can be represented as a tree structure. Try to break it down into simple elements and containers. Remember that containers must be able to contain both simple elements and other containers.<br>确保应用的核心模型可以表示为树结构。尝试将其分解为简单的元素和容器。请记住，容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>Declare the component interface with a list of methods that make sense for both simple and complex components.<br>使用对简单和复杂组件都有意义的方法列表声明组件接口。</p>
</li>
<li><p>Create a leaf class to represent simple elements. A program may have multiple different leaf classes.<br>创建一个叶类来表示简单元素。一个程序可以有多个不同的叶类。</p>
</li>
</ol>
<p>Create a container class to represent complex elements. In this class, provide an array field for storing references to sub-elements. The array must be able to store both leaves and containers, so make sure it’s declared with the component interface type.<br>创建一个容器类来表示复杂元素。在此类中，提供一个数组字段，用于存储对子元素的引用。数组必须能够存储叶子和容器，因此请确保使用组件接口类型声明它。</p>
<ol start="4">
<li><p>While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.<br>在实现组件接口的方法时，请记住，容器应该将大部分工作委托给子元素。</p>
</li>
<li><p>Finally, define the methods for adding and removal of child elements in the container.<br>最后，定义在容器中添加和删除子元素的方法。</p>
</li>
</ol>
<p>Keep in mind that these operations can be declared in the component interface. This would violate the Interface Segregation Principle because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.<br>请记住，这些操作可以在组件接口中声明。这将违反接口隔离原则，因为方法在叶类中为空。但是，客户端将能够平等地对待所有元素，即使在组成树时也是如此。</p>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage. 您可以更方便地使用复杂的树结构：使用多态性和递归来发挥自己的优势。</td>
<td>It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you’d need to overgeneralize the component interface, making it harder to comprehend.可能很难为功能差异太大的类提供通用接口。在某些情况下，需要过度概括组件接口，使其更难理解。</td>
</tr>
<tr>
<td>Open&#x2F;Closed Principle. You can introduce new element types into the app without breaking the existing code, which now works with the object tree. 开&#x2F;闭原理。您可以在不破坏现有代码的情况下将新的元素类型引入应用程序，这些代码现在适用于对象树。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>You can use <strong>Builder</strong> when creating complex <strong>Composite</strong> trees because you can program its construction steps to work recursively.<br>在创建复杂的复合树时，可以使用 Builder，因为您可以对其构造步骤进行编程以递归方式工作。</p>
</li>
<li><p>Chain of <strong>Responsibility</strong> is often used in conjunction with <strong>Composite</strong>. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.<br>责任链通常与复合结合使用。在这种情况下，当叶组件收到请求时，它可能会通过所有父组件的链向下传递到对象树的根目录。</p>
</li>
<li><p>You can use <strong>Iterators</strong> to traverse <strong>Composite</strong> trees.<br>可以使用迭代器遍历复合树。</p>
</li>
<li><p>You can use Visitor to execute an operation over an entire <strong>Composite</strong> tree.<br>您可以使用 Visitor 对整个复合树执行操作。</p>
</li>
<li><p>You can implement shared leaf nodes of the <strong>Composite</strong> tree as <strong>Flyweights</strong> to save some RAM.<br>您可以将复合树的共享叶节点实现为轻量级，以节省一些 RAM。</p>
</li>
<li><p><strong>Composite</strong> and <strong>Decorator</strong> have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.<br>Composite 和 Decorator 具有相似的结构图，因为两者都依赖于递归组合来组织开放数量的对象。<br>A Decorator is like a Composite but only has one child component. There’s another significant difference: Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results.<br>装饰器类似于 Composite，但只有一个子组件。还有另一个显著的区别：Decorator 为包装的对象添加了额外的职责，而 Composite 只是“汇总”其子对象的结果。<br>However, the patterns can also cooperate: you can use Decorator to extend the behavior of a specific object in the Composite tree.<br>但是，这些模式也可以协同工作：您可以使用 Decorator 来扩展 <strong>Composite</strong> 树中特定对象的行为。</p>
</li>
<li><p>Designs that make heavy use of <strong>Composite</strong> and <strong>Decorator</strong> can often benefit from using <strong>Prototype</strong>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用 <strong>Composite</strong> 和 <strong>Decorator</strong> 的设计通常可以从使用 <strong>Prototype</strong> 中受益。通过应用该模式，您可以克隆复杂的结构，而不是从头开始重新构建它们。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-Example-概念示例"><a href="#Python-Conceptual-Example-概念示例" class="headerlink" title="Python Conceptual Example 概念示例"></a>Python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Composite design pattern. It focuses on answering these questions:<br>此示例阐释了 Composite 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<h4 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Component class declares common operations for both simple and</span></span><br><span class="line"><span class="string">    complex objects of a composition.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self</span>) -&gt; Component:</span><br><span class="line">        <span class="keyword">return</span> self._parent</span><br><span class="line"></span><br><span class="line"><span class="meta">    @parent.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, parent: Component</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Optionally, the base Component can declare an interface for setting and</span></span><br><span class="line"><span class="string">        accessing a parent of the component in a tree structure. It can also</span></span><br><span class="line"><span class="string">        provide some default implementation for these methods.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    In some cases, it would be beneficial to define the child-management</span></span><br><span class="line"><span class="string">    operations right in the base Component class. This way, you won&#x27;t need to</span></span><br><span class="line"><span class="string">    expose any concrete component classes to the client code, even during the</span></span><br><span class="line"><span class="string">    object tree assembly. The downside is that these methods will be empty for</span></span><br><span class="line"><span class="string">    the leaf-level components.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_composite</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        You can provide a method that lets the client code figure out whether a</span></span><br><span class="line"><span class="string">        component can bear children.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The base Component may implement some default behavior or leave it to</span></span><br><span class="line"><span class="string">        concrete classes (by declaring the method containing the behavior as</span></span><br><span class="line"><span class="string">        &quot;abstract&quot;).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Leaf class represents the end objects of a composition. A leaf can&#x27;t</span></span><br><span class="line"><span class="string">    have any children.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Usually, it&#x27;s the Leaf objects that do the actual work, whereas Composite</span></span><br><span class="line"><span class="string">    objects only delegate to their sub-components.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Leaf&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Composite class represents the complex components that may have</span></span><br><span class="line"><span class="string">    children. Usually, the Composite objects delegate the actual work to their</span></span><br><span class="line"><span class="string">    children and then &quot;sum-up&quot; the result.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children: <span class="type">List</span>[Component] = []</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A composite object can add or remove other components (both simple or</span></span><br><span class="line"><span class="string">    complex) to or from its child list.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children.append(component)</span><br><span class="line">        component.parent = self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._children.remove(component)</span><br><span class="line">        component.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_composite</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Composite executes its primary logic in a particular way. It</span></span><br><span class="line"><span class="string">        traverses recursively through all its children, collecting and summing</span></span><br><span class="line"><span class="string">        their results. Since the composite&#x27;s children pass these calls to their</span></span><br><span class="line"><span class="string">        children and so forth, the whole object tree is traversed as a result.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self._children:</span><br><span class="line">            results.append(child.operation())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Branch(<span class="subst">&#123;<span class="string">&#x27;+&#x27;</span>.join(results)&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with all of the components via the base interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code2</span>(<span class="params">component1: Component, component2: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Thanks to the fact that the child-management operations are declared in the</span></span><br><span class="line"><span class="string">    base Component class, the client code can work with any component, simple or</span></span><br><span class="line"><span class="string">    complex, without depending on their concrete classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> component1.is_composite():</span><br><span class="line">        component1.add(component2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component1.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># This way the client code can support the simple leaf components...</span></span><br><span class="line">    simple = Leaf()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I&#x27;ve got a simple component:&quot;</span>)</span><br><span class="line">    client_code(simple)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...as well as the complex composites.</span></span><br><span class="line">    tree = Composite()</span><br><span class="line"></span><br><span class="line">    branch1 = Composite()</span><br><span class="line">    branch1.add(Leaf())</span><br><span class="line">    branch1.add(Leaf())</span><br><span class="line"></span><br><span class="line">    branch2 = Composite()</span><br><span class="line">    branch2.add(Leaf())</span><br><span class="line"></span><br><span class="line">    tree.add(branch1)</span><br><span class="line">    tree.add(branch2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Now I&#x27;ve got a composite tree:&quot;</span>)</span><br><span class="line">    client_code(tree)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I don&#x27;t need to check the components classes even when managing the tree:&quot;</span>)</span><br><span class="line">    client_code2(tree, simple)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I&#x27;ve got a simple component:</span><br><span class="line">RESULT: Leaf</span><br><span class="line"></span><br><span class="line">Client: Now I&#x27;ve got a composite tree:</span><br><span class="line">RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))</span><br><span class="line"></span><br><span class="line">Client: I don&#x27;t need to check the components classes even when managing the tree:</span><br><span class="line">RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Files-and-Folders-文件和文件夹"><a href="#Rust-Files-and-Folders-文件和文件夹" class="headerlink" title="Rust: Files and Folders 文件和文件夹"></a>Rust: Files and Folders 文件和文件夹</h3><p>Let’s try to understand the Composite pattern with an example of an operating system’s file system. In the file system, there are two types of objects: files and folders. There are cases when files and folders should be treated to be the same way. This is where the Composite pattern comes in handy.<br>让我们尝试通过操作系统文件系统的示例来理解 Composite 模式。在文件系统中，有两种类型的对象：文件和文件夹。在某些情况下，文件和文件夹应以相同的方式处理。这就是复合模式派上用场的地方。</p>
<p>File and Directory are both of the trait Component with a single search method. For a file, it will just look into the contents of the file; for a folder, it will go through all files of that folder to find that keyword.<br>File 并且 Directory 都 trait Component 使用单一 search 方法。对于文件，它只会查看文件的内容;对于文件夹，它将遍历该文件夹的所有文件以查找该关键字。</p>
<h4 id="fs-mod-rs"><a href="#fs-mod-rs" class="headerlink" title="fs&#x2F;mod.rs"></a>fs&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> file;</span><br><span class="line"><span class="keyword">mod</span> folder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> file::File;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> folder::Folder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fs-file-rs"><a href="#fs-file-rs" class="headerlink" title="fs&#x2F;file.rs"></a>fs&#x2F;file.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Component</span> <span class="keyword">for</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Searching for keyword &#123;&#125; in file &#123;&#125;&quot;</span>, keyword, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fs-folder-rs"><a href="#fs-folder-rs" class="headerlink" title="fs&#x2F;folder.rs"></a>fs&#x2F;folder.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> super::Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>,</span><br><span class="line">    components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Component&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            name,</span><br><span class="line">            components: <span class="built_in">vec!</span>[],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, component: <span class="keyword">impl</span> <span class="title class_">Component</span> + <span class="symbol">&#x27;static</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.components.<span class="title function_ invoke__">push</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(component));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Component</span> <span class="keyword">for</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, keyword: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Searching recursively for keyword &#123;&#125; in folder &#123;&#125;&quot;</span>,</span><br><span class="line">            keyword, <span class="keyword">self</span>.name</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">search</span>(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> fs::&#123;Component, File, Folder&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file1</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file2</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file3</span> = File::<span class="title function_ invoke__">new</span>(<span class="string">&quot;File 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">folder1</span> = Folder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Folder 1&quot;</span>);</span><br><span class="line">    folder1.<span class="title function_ invoke__">add</span>(file1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">folder2</span> = Folder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Folder 2&quot;</span>);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(file2);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(file3);</span><br><span class="line">    folder2.<span class="title function_ invoke__">add</span>(folder1);</span><br><span class="line"></span><br><span class="line">    folder2.<span class="title function_ invoke__">search</span>(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Searching recursively for keyword rose in folder Folder 2</span><br><span class="line">Searching for keyword rose in file File 2</span><br><span class="line">Searching for keyword rose in file File 3</span><br><span class="line">Searching recursively for keyword rose in folder Folder 1</span><br><span class="line">Searching for keyword rose in file File 1</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Decorator 装饰器模式</title>
    <url>/2024/01/28/design-pattern/decorator/</url>
    <content><![CDATA[<h1 id="Decorator-装饰器模式"><a href="#Decorator-装饰器模式" class="headerlink" title="Decorator 装饰器模式"></a>Decorator 装饰器模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Decorator</strong>  is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.<br><strong>装饰器</strong>是一种结构化设计模式，它允许您将新行为附加到对象，方法是将这些对象放置在包含行为的特殊包装器对象中。</p>
<div align="center"> <img src="/images/decorator.png"/></div>


<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem  问题"></a>Problem  问题</h2><p>Imagine that you’re working on a notification library which lets other programs notify their users about important events.<br>假设您正在处理一个通知库，该库允许其他程序通知其用户有关重要事件。</p>
<p>The initial version of the library was based on the <code>Notifier</code> class that had only a few fields, a constructor and a single <code>send</code> method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notifier via its constructor. A third-party app which acted as a client was supposed to create and configure the notifier object once, and then use it each time something important happened.<br>该库的初始版本基于只有几个字段、一个构造函数和一个 <code>send</code> 方法的 <code>Notifier</code> 类。该方法可以接受来自客户端的消息参数，并将消息发送到通过其构造函数传递给通知程序的电子邮件列表。作为客户端的第三方应用程序应该创建和配置一次通知程序对象，然后在每次发生重要事件时使用它。</p>
<div align="center"> <img src="/images/decorator-problem1.png"/>A program could use the notifier class to send notifications about important events to a predefined set of emails.</br>程序可以使用notifier类将有关重要事件的通知发送到一组预定义的电子邮件。</div>


<p>At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications.在某种程度上，您意识到图书馆的用户期望的不仅仅是电子邮件通知。他们中的许多人希望收到关于关键问题的短信。其他人希望在Facebook上获得通知，当然，企业用户也希望获得Slack通知。</p>
<div align="center"> <img src="/images/decorator-problem2.png"/>Each notification type is implemented as a notifier’s subclass.</br>每个通知类型都作为通知程序的子类实现。</div>


<p>How hard can that be? You extended the <code>Notifier</code> class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.<br>这能有多难您扩展了 <code>Notifier</code> 类，并将额外的通知方法放入新的子类中。现在，客户端应该实例化所需的通知类，并将其用于所有进一步的通知。</p>
<p>But then someone reasonably asked you, “Why can’t you use several notification types at once? If your house is on fire, you’d probably want to be informed through every channel.”<br>但是后来有人合理地问你，“为什么你不能同时使用几种通知类型？如果你的房子着火了，你可能希望通过各种渠道得到通知。“</p>
<p>You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well.<br>您试图通过创建特殊的子类来解决这个问题，这些子类在一个类中组合了几个通知方法。然而，很快就发现这种方法会极大地膨胀代码，不仅是库代码，而且还有客户机代码。</p>
<div align="center"> <img src="/images/decorator-problem2.png"/>Combinatorial explosion of subclasses.</br>子类的组合爆炸。</div>


<p>You have to find some other way to structure notifications classes so that their number won’t accidentally break some Guinness record.您必须找到其他方法来构造通知类，以便它们的数量不会意外地打破吉尼斯记录。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution  解决方案"></a>Solution  解决方案</h2><p>Extending a class is the first thing that comes to mind when you need to alter an object’s behavior. However, inheritance has several serious caveats that you need to be aware of.<br>当您需要改变对象的行为时，首先想到的是扩展类。然而，继承有几个严重的警告，你需要知道。</p>
<ul>
<li>Inheritance is static. You can’t alter the behavior of an existing object at runtime. You can only replace the whole object with another one that’s created from a different subclass.<br>继承是静态的。不能在运行时改变现有对象的行为。你只能用另一个从不同子类创建的对象替换整个对象。</li>
<li>Subclasses can have just one parent class. In most languages, inheritance doesn’t let a class inherit behaviors of multiple classes at the same time.<br>子类只能有一个父类。在大多数语言中，继承不会让一个类同时继承多个类的行为。</li>
</ul>
<p>One of the ways to overcome these caveats is by using <em>Aggregation</em> or <em>Composition</em>  instead of <em>Inheritance</em>. Both of the alternatives work almost the same way: one object <em>has a</em> reference to another and delegates it some work, whereas with inheritance, the object itself <em>is</em> able to do that work, inheriting the behavior from its superclass.<br>克服这些警告的方法之一是使用聚合或组合而不是继承。这两种替代方法的工作方式几乎相同：一个对象引用另一个对象并委托它一些工作，而继承，对象本身能够完成这项工作，从其超类继承行为。</p>
<p>With this new approach you can easily substitute the linked “helper” object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Aggregation&#x2F;composition is the key principle behind many design patterns, including Decorator. On that note, let’s return to the pattern discussion.<br>使用这种新方法，您可以轻松地将链接的“helper”对象替换为另一个对象，从而在运行时更改容器的行为。一个对象可以使用各种类的行为，引用多个对象并将各种工作委托给它们。聚合&#x2F;组合是许多设计模式背后的关键原则，包括Decorator。在这一点上，让我们回到模式讨论。</p>
<div align="center"> <img src="/images/decorator-solution1.png"/>Inheritance vs. Aggregation</br>继承与聚合</div>


<p>“Wrapper” is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A <em>wrapper</em> is an object that can be linked with some <em>target</em> object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target.<br>“Wrapper”是Decorator模式的另一个昵称，它清楚地表达了该模式的主要思想。包装器是可以与某个目标对象链接的对象。包装器包含与目标相同的方法集，并将其接收的所有请求委托给它。但是，包装器可以在将请求传递给目标之前或之后执行某些操作，从而改变结果。</p>
<p>When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That’s why from the client’s perspective these objects are identical. Make the wrapper’s reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it.<br>什么时候简单的包装器变成了真实的装饰器？正如我提到的，包装器实现了与被包装对象相同的接口。这就是为什么从客户的角度来看，这些对象是相同的。使包装器的引用字段接受该接口后面的任何对象。这将允许您在多个包装器中覆盖一个对象，并将所有包装器的组合行为添加到该对象中。</p>
<p>In our notifications example, let’s leave the simple email notification behavior inside the base <code>Notifier</code> class, but turn all other notification methods into decorators.<br>在我们的通知示例中，让我们将简单的电子邮件通知行为留在基类 <code>Notifier</code> 中，但将所有其他通知方法转换为装饰器。</p>
<div align="center"> <img src="/images/decorator-solution2.png"/>Various notification methods become decorators.</br>各种通知方法成为装饰器。</div>


<p>The client code would need to wrap a basic notifier object into a set of decorators that match the client’s preferences. The resulting objects will be structured as a stack.客户机代码需要将一个基本的通知程序对象包装到一组符合客户机偏好的装饰器中。生成的对象将被构造为堆栈。</p>
<div align="center"> <img src="/images/decorator-solution2.png"/>Apps might configure complex stacks of notification decorators.</br>应用程序可能会配置复杂的通知装饰器堆栈。</div>


<p>The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won’t care whether it works with the “pure” notifier object or the decorated one.<br>堆栈中的最后一个装饰器将是客户端实际使用的对象。由于所有装饰器都实现了与基本通知器相同的接口，因此客户端代码的其余部分不会关心它是与“纯”通知器对象一起工作还是与装饰的通知器对象一起工作。</p>
<p>We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.<br>我们可以将相同的方法应用于其他行为，例如格式化消息或编写收件人列表。客户端可以使用任何自定义装饰器来装饰对象，只要它们遵循与其他装饰器相同的接口即可。</p>
<h2 id="Real-World-Analogy-现实世界的类比"><a href="#Real-World-Analogy-现实世界的类比" class="headerlink" title="Real-World Analogy  现实世界的类比"></a>Real-World Analogy  现实世界的类比</h2><div align="center"> <img src="/images/decorator-comic-1.png"/>You get a combined effect from wearing multiple pieces of clothing.</br>你会从穿多件衣服中得到一个综合效果。</div>


<p>Wearing clothes is an example of using decorators. When you’re cold, you wrap yourself in a sweater. If you’re still cold with a sweater, you can wear a jacket on top. If it’s raining, you can put on a raincoat. All of these garments “extend” your basic behavior but aren’t part of you, and you can easily take off any piece of clothing whenever you don’t need it.<br>穿衣服是使用装饰器的一个例子。当你冷的时候，你会把自己裹在毛衣里。如果你穿毛衣还是觉得冷，你可以在上面穿一件夹克。如果下雨，你可以穿上雨衣。所有这些衣服都“延伸”了你的基本行为，但不是你的一部分，你可以在不需要的时候轻松地脱掉任何一件衣服。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure  结构"></a>Structure  结构</h2><div align="center"> <img src="/images/decorator-structure1.png"/></div>


<ol>
<li>The <strong>Component</strong> declares the common interface for both wrappers and wrapped objects.<br>组件声明了包装器和包装对象的公共接口。</li>
<li><strong>Concrete Component</strong> is a class of objects being wrapped. It defines the basic behavior, which can be altered by decorators.<br>具体组件是一个被包装的对象类。它定义了基本的行为，可以由装饰器修改。</li>
<li>The <strong>Base Decorator</strong> class has a field for referencing a wrapped object. The field’s type should be declared as the component interface so it can contain both concrete components and decorators. The base decorator delegates all operations to the wrapped object.<br>BaseDecorator类有一个用于引用包装对象的字段。字段的类型应该被声明为组件接口，这样它就可以包含具体的组件和装饰器。基本装饰器将所有操作委托给包装对象。</li>
<li><strong>Concrete Decorators</strong> define extra behaviors that can be added to components dynamically. Concrete decorators override methods of the base decorator and execute their behavior either before or after calling the parent method.<br>具体装饰器定义了可以动态添加到组件的额外行为。具体装饰器覆盖基本装饰器的方法，并在调用父方法之前或之后执行它们的行为。</li>
<li>The <strong>Client</strong> can wrap components in multiple layers of decorators, as long as it works with all objects via the component interface.<br>客户端可以将组件包装在多层装饰器中，只要它通过组件接口与所有对象一起工作。</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode  伪代码"></a>Pseudocode  伪代码</h2><p>In this example, the In this example, the <strong>Decorator</strong> pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data. pattern lets you compress and encrypt sensitive data independently from the code that actually uses this data.在本例中，Decorator模式允许您独立于实际使用敏感数据的代码来压缩和加密这些数据。</p>
<div align="center"> <img src="/images/decorator-example1.png"/>The encryption and compression decorators example.</br>加密和压缩装饰器示例。</div>


<p>The application wraps the data source object with a pair of decorators. Both wrappers change the way the data is written to and read from the disk:<br>应用程序用一对装饰器包装数据源对象。这两种包装器都改变了数据写入磁盘和从磁盘读取的方式：</p>
<ul>
<li>Just before the data is <strong>written to disk</strong>, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.<br>就在数据写入磁盘之前，装饰器加密并压缩数据。原始类将加密和保护的数据写入文件，而不知道更改。</li>
<li>Right after the data is <strong>read from disk</strong>, it goes through the same decorators, which decompress and decode it.<br>在从磁盘读取数据之后，它会经过相同的装饰器，这些装饰器会对数据进行加密和解码。</li>
</ul>
<p>The decorators and the data source class implement the same interface, which makes them all interchangeable in the client code.<br>装饰器和数据源类实现了相同的接口，这使得它们在客户端代码中可以互换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The component interface defines operations that can be</span></span><br><span class="line"><span class="comment">// altered by decorators.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete components provide default implementations for the</span></span><br><span class="line"><span class="comment">// operations. There might be several variations of these</span></span><br><span class="line"><span class="comment">// classes in a program.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    constructor <span class="title function_">FileDataSource</span><span class="params">(filename)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// Write data to file.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// Read data from file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The base decorator class follows the same interface as the</span></span><br><span class="line"><span class="comment">// other components. The primary purpose of this class is to</span></span><br><span class="line"><span class="comment">// define the wrapping interface for all concrete decorators.</span></span><br><span class="line"><span class="comment">// The default implementation of the wrapping code might include</span></span><br><span class="line"><span class="comment">// a field for storing a wrapped component and the means to</span></span><br><span class="line"><span class="comment">// initialize it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSourceDecorator</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">    <span class="keyword">protected</span> field wrappee: DataSource</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">DataSourceDecorator</span><span class="params">(source: DataSource)</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">wrappee</span> <span class="operator">=</span> source</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The base decorator simply delegates all work to the</span></span><br><span class="line">    <span class="comment">// wrapped component. Extra behaviors can be added in</span></span><br><span class="line">    <span class="comment">// concrete decorators.</span></span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        wrappee.writeData(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete decorators may call the parent implementation of</span></span><br><span class="line">    <span class="comment">// the operation instead of calling the wrapped object</span></span><br><span class="line">    <span class="comment">// directly. This approach simplifies extension of decorator</span></span><br><span class="line">    <span class="comment">// classes.</span></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="keyword">return</span> wrappee.readData()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete decorators must call methods on the wrapped object,</span></span><br><span class="line"><span class="comment">// but may add something of their own to the result. Decorators</span></span><br><span class="line"><span class="comment">// can execute the added behavior either before or after the</span></span><br><span class="line"><span class="comment">// call to a wrapped object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// 1. Encrypt passed data.</span></span><br><span class="line">        <span class="comment">// 2. Pass encrypted data to the wrappee&#x27;s writeData</span></span><br><span class="line">        <span class="comment">// method.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// 1. Get data from the wrappee&#x27;s readData method.</span></span><br><span class="line">        <span class="comment">// 2. Try to decrypt it if it&#x27;s encrypted.</span></span><br><span class="line">        <span class="comment">// 3. Return the result.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can wrap objects in several layers of decorators.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">    method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">        <span class="comment">// 1. Compress passed data.</span></span><br><span class="line">        <span class="comment">// 2. Pass compressed data to the wrappee&#x27;s writeData</span></span><br><span class="line">        <span class="comment">// method.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">        <span class="comment">// 1. Get data from the wrappee&#x27;s readData method.</span></span><br><span class="line">        <span class="comment">// 2. Try to decompress it if it&#x27;s compressed.</span></span><br><span class="line">        <span class="comment">// 3. Return the result.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1. A simple example of a decorator assembly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">dumbUsageExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;somefile.dat&quot;</span>)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The target file has been written with plain data.</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The target file has been written with compressed</span></span><br><span class="line">        <span class="comment">// data.</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">        <span class="comment">// The source variable now contains this:</span></span><br><span class="line">        <span class="comment">// Encryption &gt; Compression &gt; FileDataSource</span></span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// The file has been written with compressed and</span></span><br><span class="line">        <span class="comment">// encrypted data.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2. Client code that uses an external data source.</span></span><br><span class="line"><span class="comment">// SalaryManager objects neither know nor care about data</span></span><br><span class="line"><span class="comment">// storage specifics. They work with a pre-configured data</span></span><br><span class="line"><span class="comment">// source received from the app configurator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalaryManager</span> is</span><br><span class="line">    field source: DataSource</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">SalaryManager</span><span class="params">(source: DataSource)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">load</span><span class="params">()</span> is</span><br><span class="line">        <span class="keyword">return</span> source.readData()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">save</span><span class="params">()</span> is</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">    <span class="comment">// ...Other useful methods...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The app can assemble different stacks of decorators at</span></span><br><span class="line"><span class="comment">// runtime, depending on the configuration or environment.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">configurationExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;salary.dat&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">            source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">        <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">            source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line"></span><br><span class="line">        logger = <span class="keyword">new</span> <span class="title class_">SalaryManager</span>(source)</span><br><span class="line">        salary = logger.load()</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability  适用性"></a>Applicability  适用性</h2><ul>
<li><p>Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.<br>当您需要能够在运行时为对象分配额外的行为而不破坏使用这些对象的代码时，请使用装饰器模式。</p>
</li>
<li><p>The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.<br>Decorator允许您将业务逻辑结构化到层中，为每一层创建一个装饰器，并在运行时使用此逻辑的各种组合来组合对象。客户端代码可以以相同的方式处理所有这些对象，因为它们都遵循一个公共接口。</p>
</li>
<li><p>Use the pattern when it’s awkward or not possible to extend an object’s behavior using inheritance.<br>当难以或不可能使用继承扩展对象的行为时，请使用该模式。</p>
</li>
<li><p>Many programming languages have the <code>final</code> keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.<br>许多编程语言都有 <code>final</code> 关键字，可以用来防止类的进一步扩展。对于最后一个类，重用现有行为的唯一方法是使用自己的包装器（使用Decorator模式）包装该类。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实施"><a href="#How-to-Implement-如何实施" class="headerlink" title="How to Implement 如何实施"></a>How to Implement 如何实施</h2><ol>
<li>Make sure your business domain can be represented as a primary component with multiple optional layers over it.<br>确保您的业务域可以表示为一个主要组件，在其上有多个可选层。</li>
<li>Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.<br>找出主要组件和可选层共有的方法。创建一个组件接口并在那里声明这些方法。</li>
<li>Create a concrete component class and define the base behavior in it.<br>创建一个具体的组件类，并在其中定义基本行为。</li>
<li>Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.<br>创建一个基本装饰器类。它应该有一个用于存储对包装对象的引用的字段。该字段应该用组件接口类型声明，以允许链接到具体的组件以及装饰器。基本装饰器必须将所有工作委托给包装对象。</li>
<li>Make sure all classes implement the component interface.<br>确保所有类都实现组件接口。</li>
<li>Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).<br>通过从基本装饰器扩展它们来创建具体的装饰器。一个具体的装饰器必须在调用父方法之前或之后执行它的行为（父方法总是委托给被包装的对象）。</li>
<li>The client code must be responsible for creating decorators and composing them in the way the client needs.<br>客户端代码必须负责创建装饰器并以客户端需要的方式组合它们。</li>
</ol>
<h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p>利弊</p>
<ul>
<li><p> You can extend an object’s behavior without making a new subclass.<br>你可以扩展一个对象的行为而不需要创建一个新的子类。</p>
</li>
<li><p> You can add or remove responsibilities from an object at runtime.<br>您可以在运行时添加或删除对象的责任。</p>
</li>
<li><p> You can combine several behaviors by wrapping an object into multiple decorators.<br>通过将一个对象包装到多个装饰器中，可以联合收割机组合多种行为。</p>
</li>
<li><p> <em>Single Responsibility Principle</em>. You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.<br>单一责任原则。您可以将实现许多可能的行为变体的单体类划分为几个较小的类。</p>
</li>
<li><p> It’s hard to remove a specific wrapper from the wrappers stack.<br>很难从wrapper堆栈中删除特定的wrapper。</p>
</li>
<li><p> It’s hard to implement a decorator in such a way that its behavior doesn’t depend on the order in the decorators stack.<br>很难实现一个装饰器，使其行为不依赖于装饰器堆栈中的顺序。</p>
</li>
<li><p> The initial configuration code of layers might look pretty ugly.<br>层的初始配置代码可能看起来很难看。</p>
</li>
</ul>
<h2 id="Relations-with-Other-Patterns"><a href="#Relations-with-Other-Patterns" class="headerlink" title="Relations with Other Patterns"></a>Relations with Other Patterns</h2><p>与其他模式的关系</p>
<ul>
<li><p><a href="https://refactoring.guru/design-patterns/adapter">Adapter</a> provides a completely different interface for accessing an existing object. On the other hand, with the <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> pattern the interface either stays the same or gets extended. In addition, <em>Decorator</em> supports recursive composition, which isn’t possible when you use <em>Adapter</em>.<br>Adapter为访问现有对象提供了一个完全不同的接口。另一方面，对于Decorator模式，接口要么保持不变，要么得到扩展。此外，Decorator支持递归组合，这在使用Adapter时是不可能的。</p>
</li>
<li><p>With <a href="https://refactoring.guru/design-patterns/adapter">Adapter</a> you access an existing object via different interface. With <a href="https://refactoring.guru/design-patterns/proxy">Proxy</a>, the interface stays the same. With <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> you access the object via an enhanced interface.<br>使用Adapter，您可以通过不同的接口访问现有对象。使用Proxy，接口保持不变。使用Decorator，您可以通过增强的接口访问对象。</p>
</li>
<li><p><a href="https://refactoring.guru/design-patterns/chain-of-responsibility">Chain of Responsibility</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences.<br>Chain of Responsibility和Decorator具有非常相似的类结构。这两种模式都依赖于递归组合来通过一系列对象传递执行。然而，有几个关键的区别。</p>
<p>The <em>CoR</em> handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various <em>Decorators</em> can extend the object’s behavior while keeping it consistent with the base interface. In addition, decorators aren’t allowed to break the flow of the request.</p>
</li>
</ul>
<p>CoR处理程序可以彼此独立地执行任意操作。他们也可以在任何时候停止进一步传递请求。另一方面，各种装饰器可以扩展对象的行为，同时保持它与基接口的一致性。此外，装饰器不允许中断请求流。</p>
<ul>
<li><p><a href="https://refactoring.guru/design-patterns/composite">Composite</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.<br>Composite和Decorator具有类似的结构图，因为它们都依赖于递归组合来组织开放数量的对象。</p>
<p>A <em>Decorator</em> is like a <em>Composite</em> but only has one child component. There’s another significant difference: <em>Decorator</em> adds additional responsibilities to the wrapped object, while <em>Composite</em> just “sums up” its children’s results.</p>
</li>
</ul>
<p>Decorator类似于Composite，但只有一个子组件。还有另一个显著的区别：Decorator为包装的对象添加了额外的责任，而Composite只是“总结”其子对象的结果。</p>
<p>  However, the patterns can also cooperate: you can use <em>Decorator</em> to extend the behavior of a specific object in the <em>Composite</em> tree.<br>然而，模式也可以合作：您可以使用Decorator来扩展Composite树中特定对象的行为。</p>
<ul>
<li>Designs that make heavy use of <a href="https://refactoring.guru/design-patterns/composite">Composite</a> and <a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> can often benefit from using <a href="https://refactoring.guru/design-patterns/prototype">Prototype</a>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用Composite和Decorator的设计通常可以从使用Prototype中受益。应用该模式可以克隆复杂的结构，而不是从头开始重新构造它们。</li>
<li><a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> lets you change the skin of an object, while <a href="https://refactoring.guru/design-patterns/strategy">Strategy</a> lets you change the guts.<br>Decorator允许您更改对象的皮肤，而Strategy允许您更改内部。</li>
<li><a href="https://refactoring.guru/design-patterns/decorator">Decorator</a> and <a href="https://refactoring.guru/design-patterns/proxy">Proxy</a> have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a <em>Proxy</em> usually manages the life cycle of its service object on its own, whereas the composition of <em>Decorators</em> is always controlled by the client.<br>Decorator和Proxy具有类似的结构，但意图非常不同。这两种模式都建立在组合原则上，其中一个对象应该将一些工作委托给另一个对象。不同之处在于，Proxy通常自己管理其服务对象的生命周期，而Decorators的组成始终由客户端控制。</li>
</ul>
<h1 id="Decorator-in-Python-Python中的Decorator"><a href="#Decorator-in-Python-Python中的Decorator" class="headerlink" title="Decorator in Python Python中的Decorator"></a><strong>Decorator</strong> in Python Python中的Decorator</h1><p><strong>Decorator</strong> is a structural pattern that allows adding new behaviors to objects dynamically by placing them inside special wrapper objects, called <em>decorators</em>.<br>装饰器是一种结构化模式，它允许通过将对象放置在特殊的包装器对象（称为装饰器）中来动态地向对象添加新行为。</p>
<p>Using decorators you can wrap objects countless number of times since both target objects and decorators follow the same interface. The resulting object will get a stacking behavior of all wrappers.<br>使用装饰器，你可以无数次地包装对象，因为目标对象和装饰器都遵循相同的接口。结果对象将获得所有包装器的堆叠行为。</p>
<h2 id="Conceptual-Example-概念示例"><a href="#Conceptual-Example-概念示例" class="headerlink" title="Conceptual Example 概念示例"></a>Conceptual Example 概念示例</h2><p>This example illustrates the structure of the <strong>Decorator</strong> design pattern. It focuses on answering these questions:<br>这个例子说明了装饰器设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些班级扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Component interface defines operations that can be altered by</span></span><br><span class="line"><span class="string">    decorators.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Components provide default implementations of the operations. There</span></span><br><span class="line"><span class="string">    might be several variations of these classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcreteComponent&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span>(<span class="title class_ inherited__">Component</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base Decorator class follows the same interface as the other components.</span></span><br><span class="line"><span class="string">    The primary purpose of this class is to define the wrapping interface for</span></span><br><span class="line"><span class="string">    all concrete decorators. The default implementation of the wrapping code</span></span><br><span class="line"><span class="string">    might include a field for storing a wrapped component and the means to</span></span><br><span class="line"><span class="string">    initialize it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _component: Component = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._component = component</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">component</span>(<span class="params">self</span>) -&gt; Component:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Decorator delegates all work to the wrapped component.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._component</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> self._component.operation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span>(<span class="title class_ inherited__">Decorator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Decorators call the wrapped object and alter its result in some</span></span><br><span class="line"><span class="string">    way.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Decorators may call parent implementation of the operation, instead of</span></span><br><span class="line"><span class="string">        calling the wrapped object directly. This approach simplifies extension</span></span><br><span class="line"><span class="string">        of decorator classes.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;ConcreteDecoratorA(<span class="subst">&#123;self.component.operation()&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span>(<span class="title class_ inherited__">Decorator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decorators can execute their behavior either before or after the call to a</span></span><br><span class="line"><span class="string">    wrapped object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;ConcreteDecoratorB(<span class="subst">&#123;self.component.operation()&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">component: Component</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with all objects using the Component interface. This</span></span><br><span class="line"><span class="string">    way it can stay independent of the concrete classes of components it works</span></span><br><span class="line"><span class="string">    with.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;RESULT: <span class="subst">&#123;component.operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># This way the client code can support both simple components...</span></span><br><span class="line">    simple = ConcreteComponent()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: I&#x27;ve got a simple component:&quot;</span>)</span><br><span class="line">    client_code(simple)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...as well as decorated ones.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note how decorators can wrap not only simple components but the other</span></span><br><span class="line">    <span class="comment"># decorators as well.</span></span><br><span class="line">    decorator1 = ConcreteDecoratorA(simple)</span><br><span class="line">    decorator2 = ConcreteDecoratorB(decorator1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Now I&#x27;ve got a decorated component:&quot;</span>)</span><br><span class="line">    client_code(decorator2)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: I&#x27;ve got a simple component:</span><br><span class="line">RESULT: ConcreteComponent</span><br><span class="line"></span><br><span class="line">Client: Now I&#x27;ve got a decorated component:</span><br><span class="line">RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))</span><br></pre></td></tr></table></figure>

<h1 id="Decorator-in-Rust-饰Rust"><a href="#Decorator-in-Rust-饰Rust" class="headerlink" title="Decorator in Rust 饰Rust"></a><strong>Decorator</strong> in Rust 饰Rust</h1><p><strong>Decorator</strong> is a structural pattern that allows adding new behaviors to objects dynamically by placing them inside special wrapper objects, called <em>decorators</em>.<br>装饰器是一种结构化模式，它允许通过将对象放置在特殊的包装器对象（称为装饰器）中来动态地向对象添加新行为。</p>
<p>Using decorators you can wrap objects countless number of times since both target objects and decorators follow the same interface. The resulting object will get a stacking behavior of all wrappers.<br>使用装饰器，你可以无数次地包装对象，因为目标对象和装饰器都遵循相同的接口。结果对象将获得所有包装器的堆叠行为。</p>
<h2 id="Input-streams-decoration"><a href="#Input-streams-decoration" class="headerlink" title="Input streams decoration"></a>Input streams decoration</h2><p>输入流装饰</p>
<p>There is a <em><strong>practical example</strong></em>  in Rust’s standard library for input&#x2F;output operations.<br>在Rust的标准库中有一个实际的输入&#x2F;输出操作示例。</p>
<p>A buffered reader decorates a vector reader adding buffered behavior.<br>缓冲读取器装饰添加缓冲行为的向量读取器。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = BufReader::<span class="title function_ invoke__">new</span>(Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Input data&quot;</span>));</span><br><span class="line">input.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;BufReader, Cursor, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0u8</span>; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A buffered reader decorates a vector reader which wraps input data.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = BufReader::<span class="title function_ invoke__">new</span>(Cursor::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Input data&quot;</span>));</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">ok</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Read from a buffered reader: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">byte</span> <span class="keyword">in</span> buf &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="type">char</span>::<span class="title function_ invoke__">from</span>(byte));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output 输出"></a>Output 输出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Read from a buffered reader: Input data</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Facade 门面（外观）模式</title>
    <url>/2024/01/29/design-pattern/facade/</url>
    <content><![CDATA[<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>Facade是一种结构化设计模式，它为库、框架或任何其他复杂的类集提供了一个简化的接口。</p>
<div align="center"> <img src="/images/facade.png"/></div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>设想一下，您必须让代码处理属于复杂库或框架的大量对象。通常，您需要初始化所有这些对象，跟踪依赖关系，以正确的顺序执行方法，等等。</p>
<p>因此，类的业务逻辑将与第三方类的实现细节紧密耦合，从而难以理解和维护。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Facade是一个类，它为包含许多移动部件的复杂子系统提供简单的接口。与直接使用子系统相比，外观可能提供有限的功能。但是，它只包含客户真正关心的那些功能。</p>
<p>Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality.<br>当你需要将你的应用与一个复杂的库集成时，拥有一个外观是很方便的，这个库有几十个功能，但你只需要它的一小部分功能。</p>
<p>例如，一个将猫的搞笑短视频上传到社交媒体的应用程序可能会使用专业的视频转换库。然而，它真正需要的只是一个带有单一方法 <code>encode(filename, format)</code> 的类。在创建这样一个类并将其与视频转换库连接之后，您将拥有第一个外观。</p>
<h2 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h2><div align="center"> <img src="/images/facade-live-example.png"/>通过电话订购。</div>


<p>当你打电话给一家商店下电话订单时，接线员是你对商店所有服务和部门的门面。运营商为您提供一个简单的语音界面，用于订购系统、支付网关和各种交付服务。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center"> <img src="/images/facade-structure.png"/></div>


<ol>
<li><strong>Facade</strong>提供了对子系统功能的特定部分的方便访问。它知道在哪里引导客户的请求，以及如何操作所有的活动部件。</li>
<li>可以创建一个<strong>Additional Facade</strong>类，以防止使用不相关的功能污染单个facade，这些功能可能会使其成为另一个复杂的结构。客户端和其他立面都可以使用其他立面。</li>
<li><strong>复杂子系统</strong>由几十个不同的对象组成。为了让它们都做一些有意义的事情，你必须深入研究子系统的实现细节，比如以正确的顺序初始化对象，并以正确的格式为它们提供数据。子系统类不知道facade的存在。他们在系统内运作，并直接相互合作。</li>
<li>客户端使用facade而不是直接调用子系统对象。</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中，Facade模式简化了与复杂视频转换框架的交互。</p>
<div align="center"> <img src="/images/facade-example1.png"/>在一个facade类中隔离多个依赖项的示例。</div>


<p>与其让你的代码直接与几十个框架类一起工作，不如创建一个facade类来封装这些功能，并将其隐藏在代码的其余部分中。这种结构还可以帮助您最大限度地减少升级到框架的未来版本或用另一个版本替换它的工作。你在应用中唯一需要改变的是facade方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These are some of the classes of a complex 3rd-party video</span></span><br><span class="line"><span class="comment">// conversion framework. We don&#x27;t control that code, therefore</span></span><br><span class="line"><span class="comment">// can&#x27;t simplify it.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoFile</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OggCompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MPEG4CompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodecFactory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitrateReader</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioMixer</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We create a facade class to hide the framework&#x27;s complexity</span></span><br><span class="line"><span class="comment">// behind a simple interface. It&#x27;s a trade-off between</span></span><br><span class="line"><span class="comment">// functionality and simplicity.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoConverter</span> is</span><br><span class="line">    method <span class="title function_">convert</span><span class="params">(filename, format)</span>:File <span class="type">is</span></span><br><span class="line">        <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(filename)</span><br><span class="line">        sourceCodec = (<span class="keyword">new</span> <span class="title class_">CodecFactory</span>).extract(file)</span><br><span class="line">        <span class="keyword">if</span> (format == <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">            destinationCodec = <span class="keyword">new</span> <span class="title class_">MPEG4CompressionCodec</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            destinationCodec = <span class="keyword">new</span> <span class="title class_">OggCompressionCodec</span>()</span><br><span class="line">        buffer = BitrateReader.read(filename, sourceCodec)</span><br><span class="line">        result = BitrateReader.convert(buffer, destinationCodec)</span><br><span class="line">        result = (<span class="keyword">new</span> <span class="title class_">AudioMixer</span>()).fix(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Application classes don&#x27;t depend on a billion classes</span></span><br><span class="line"><span class="comment">// provided by the complex framework. Also, if you decide to</span></span><br><span class="line"><span class="comment">// switch frameworks, you only need to rewrite the facade class.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">convertor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoConverter</span>()</span><br><span class="line">        mp4 = convertor.convert(<span class="string">&quot;funny-cats-video.ogg&quot;</span>, <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">        mp4.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><ul>
<li><strong>当您需要一个有限但直接的接口到一个复杂的子系统时，请使用Facade模式。</strong></li>
<li>通常，子系统会随着时间的推移变得更加复杂。即使应用设计模式通常也会导致创建更多的类。子系统可能变得更加灵活，更容易在各种上下文中重用，但它需要从客户端获得的配置和样板代码的数量越来越大。Facade试图通过提供子系统最常用功能的快捷方式来解决这个问题，以满足大多数客户的需求。</li>
<li>当你想把一个子系统组织成层时，使用Facade。</li>
<li>创建外观以定义子系统每个级别的入口点。您可以通过要求多个子系统仅通过外观进行通信来减少它们之间的耦合。例如，让我们回到我们的视频转换框架。它可以分为两个层次：视频和音频相关。对于每一层，您可以创建一个外观，然后使每一层的类通过这些外观相互通信。这种方法看起来与Mediator模式非常相似。</li>
</ul>
<h2 id="如何实施"><a href="#如何实施" class="headerlink" title="如何实施"></a>如何实施</h2><ol>
<li>检查是否有可能提供比现有子系统已经提供的接口更简单的接口。如果这个接口使客户机代码独立于许多子系统的类，那么您就走对了路。</li>
<li>在一个新的facade类中decompose并实现这个接口。facade应该将客户端代码的调用重定向到子系统的适当对象。facade应该负责初始化子系统并管理其进一步的生命周期，除非客户端代码已经这样做了。</li>
<li>要从模式中获得全部好处，请使所有客户机代码仅通过外观与子系统通信。现在，客户端代码受到保护，不受子系统代码中任何更改的影响。例如，当子系统升级到新版本时，您只需要修改外观中的代码。</li>
<li>如果外观变得太大，考虑将其行为的一部分提取到一个新的、改进的外观类中。</li>
</ol>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><ul>
<li>利：您可以将代码与子系统的复杂性隔离开来。</li>
<li> 弊：facade可以成为耦合到应用程序的所有类的god对象。</li>
</ul>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><p>Facade为现有对象定义了一个新的接口，而Adapter试图使现有接口可用。Adapter通常只包装一个对象，而Facade则处理整个对象子系统。</p>
</li>
<li><p>当您只想隐藏从客户端代码创建子系统对象的方式时，抽象工厂可以作为Facade的替代方案。</p>
</li>
<li><p>Flyweight展示了如何制作许多小对象，而Facade展示了如何制作代表整个子系统的单个对象。</p>
</li>
<li><p>Facade和Mediator有着类似的工作：它们试图组织许多紧密耦合的类之间的协作。</p>
<ul>
<li>Facade为对象子系统定义了一个简化的接口，但它没有引入任何新功能。子系统本身不知道facade。子系统内的对象可以直接通信。</li>
<li>Mediator集中系统组件之间的通信。组件只知道中介对象，不直接通信。</li>
</ul>
</li>
<li><p>Facade类通常可以转换为Singleton，因为在大多数情况下，单个facade对象就足够了。</p>
</li>
<li><p>Facade与Proxy类似，都缓冲一个复杂的实体并自己初始化它。与Facade不同，Proxy与其服务对象具有相同的接口，这使得它们可以互换。</p>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Python中的Facade"><a href="#Python中的Facade" class="headerlink" title="Python中的Facade"></a>Python中的Facade</h1><p>Facade是一种结构化设计模式，它为复杂的类、库或框架系统提供了一个简化的（但有限的）接口。</p>
<p>虽然Facade降低了应用程序的整体复杂性，但它也有助于将不需要的依赖项移到一个地方。</p>
<h2 id="概念示例"><a href="#概念示例" class="headerlink" title="概念示例"></a>概念示例</h2><p>这个例子说明了Facade设计模式的结构。它侧重于回答这些问题：</p>
<ul>
<li>它由哪些类组成？</li>
<li>这些班级扮演什么角色？</li>
<li>模式中的元素是以什么方式联系在一起的？</li>
</ul>
<h4 id="main-py：概念性示例"><a href="#main-py：概念性示例" class="headerlink" title="main.py：概念性示例"></a>main.py：概念性示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Facade class provides a simple interface to the complex logic of one or</span></span><br><span class="line"><span class="string">    several subsystems. The Facade delegates the client requests to the</span></span><br><span class="line"><span class="string">    appropriate objects within the subsystem. The Facade is also responsible for</span></span><br><span class="line"><span class="string">    managing their lifecycle. All of this shields the client from the undesired</span></span><br><span class="line"><span class="string">    complexity of the subsystem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subsystem1: Subsystem1, subsystem2: Subsystem2</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Depending on your application&#x27;s needs, you can provide the Facade with</span></span><br><span class="line"><span class="string">        existing subsystem objects or force the Facade to create them on its</span></span><br><span class="line"><span class="string">        own.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self._subsystem1 = subsystem1 <span class="keyword">or</span> Subsystem1()</span><br><span class="line">        self._subsystem2 = subsystem2 <span class="keyword">or</span> Subsystem2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Facade&#x27;s methods are convenient shortcuts to the sophisticated</span></span><br><span class="line"><span class="string">        functionality of the subsystems. However, clients get only to a fraction</span></span><br><span class="line"><span class="string">        of a subsystem&#x27;s capabilities.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line">        results.append(<span class="string">&quot;Facade initializes subsystems:&quot;</span>)</span><br><span class="line">        results.append(self._subsystem1.operation1())</span><br><span class="line">        results.append(self._subsystem2.operation1())</span><br><span class="line">        results.append(<span class="string">&quot;Facade orders subsystems to perform the action:&quot;</span>)</span><br><span class="line">        results.append(self._subsystem1.operation_n())</span><br><span class="line">        results.append(self._subsystem2.operation_z())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subsystem1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subsystem can accept requests either from the facade or client directly.</span></span><br><span class="line"><span class="string">    In any case, to the Subsystem, the Facade is yet another client, and it&#x27;s</span></span><br><span class="line"><span class="string">    not a part of the Subsystem.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem1: Ready!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_n</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem1: Go!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subsystem2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Some facades can work with multiple subsystems at the same time.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation1</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem2: Get ready!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation_z</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subsystem2: Fire!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">facade: Facade</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with complex subsystems through a simple interface</span></span><br><span class="line"><span class="string">    provided by the Facade. When a facade manages the lifecycle of the</span></span><br><span class="line"><span class="string">    subsystem, the client might not even know about the existence of the</span></span><br><span class="line"><span class="string">    subsystem. This approach lets you keep the complexity under control.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(facade.operation(), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code may have some of the subsystem&#x27;s objects already created.</span></span><br><span class="line">    <span class="comment"># In this case, it might be worthwhile to initialize the Facade with these</span></span><br><span class="line">    <span class="comment"># objects instead of letting the Facade create new instances.</span></span><br><span class="line">    subsystem1 = Subsystem1()</span><br><span class="line">    subsystem2 = Subsystem2()</span><br><span class="line">    facade = Facade(subsystem1, subsystem2)</span><br><span class="line">    client_code(facade)</span><br></pre></td></tr></table></figure>

<h4 id="Output-txt：执行结果"><a href="#Output-txt：执行结果" class="headerlink" title="Output.txt：执行结果"></a>Output.txt：执行结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Facade initializes subsystems:</span><br><span class="line">Subsystem1: Ready!</span><br><span class="line">Subsystem2: Get ready!</span><br><span class="line">Facade orders subsystems to perform the action:</span><br><span class="line">Subsystem1: Go!</span><br><span class="line">Subsystem2: Fire!</span><br></pre></td></tr></table></figure>

<h1 id="Facade-in-Rust"><a href="#Facade-in-Rust" class="headerlink" title="Facade in Rust"></a><strong>Facade</strong> in Rust</h1><p>Facade是一种结构化设计模式，它为复杂的类、库或框架系统提供了一个简化的（但有限的）接口。</p>
<p>虽然Facade降低了应用程序的整体复杂性，但它也有助于将不需要的依赖项移到一个地方。</p>
<h2 id="概念示例-1"><a href="#概念示例-1" class="headerlink" title="概念示例"></a>概念示例</h2><p><code>pub struct WalletFacade</code> 在其API背后隐藏了复杂的逻辑。一个方法 <code>add_money_to_wallet</code> 在后台与账户、代码、钱包、通知和账本进行交互。</p>
<h4 id="wallet-facade-rs"><a href="#wallet-facade-rs" class="headerlink" title="wallet_facade.rs"></a><strong>wallet_facade.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    account::Account, ledger::Ledger, notification::Notification, security_code::SecurityCode,</span><br><span class="line">    wallet::Wallet,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Facade hides a complex logic behind the API.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WalletFacade</span> &#123;</span><br><span class="line">    account: Account,</span><br><span class="line">    wallet: Wallet,</span><br><span class="line">    code: SecurityCode,</span><br><span class="line">    notification: Notification,</span><br><span class="line">    ledger: Ledger,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">WalletFacade</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(account_id: <span class="type">String</span>, code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting create account&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">            account: Account::<span class="title function_ invoke__">new</span>(account_id),</span><br><span class="line">            wallet: Wallet::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            code: SecurityCode::<span class="title function_ invoke__">new</span>(code),</span><br><span class="line">            notification: Notification,</span><br><span class="line">            ledger: Ledger,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Account created&quot;</span>);</span><br><span class="line">        this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_money_to_wallet</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        account_id: &amp;<span class="type">String</span>,</span><br><span class="line">        security_code: <span class="type">u32</span>,</span><br><span class="line">        amount: <span class="type">u32</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting add money to wallet&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.account.<span class="title function_ invoke__">check</span>(account_id)?;</span><br><span class="line">        <span class="keyword">self</span>.code.<span class="title function_ invoke__">check</span>(security_code)?;</span><br><span class="line">        <span class="keyword">self</span>.wallet.<span class="title function_ invoke__">credit_balance</span>(amount);</span><br><span class="line">        <span class="keyword">self</span>.notification.<span class="title function_ invoke__">send_wallet_credit_notification</span>();</span><br><span class="line">        <span class="keyword">self</span>.ledger.<span class="title function_ invoke__">make_entry</span>(account_id, <span class="string">&quot;credit&quot;</span>.<span class="title function_ invoke__">into</span>(), amount);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deduct_money_from_wallet</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        account_id: &amp;<span class="type">String</span>,</span><br><span class="line">        security_code: <span class="type">u32</span>,</span><br><span class="line">        amount: <span class="type">u32</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Starting debit money from wallet&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.account.<span class="title function_ invoke__">check</span>(account_id)?;</span><br><span class="line">        <span class="keyword">self</span>.code.<span class="title function_ invoke__">check</span>(security_code)?;</span><br><span class="line">        <span class="keyword">self</span>.wallet.<span class="title function_ invoke__">debit_balance</span>(amount);</span><br><span class="line">        <span class="keyword">self</span>.notification.<span class="title function_ invoke__">send_wallet_debit_notification</span>();</span><br><span class="line">        <span class="keyword">self</span>.ledger.<span class="title function_ invoke__">make_entry</span>(account_id, <span class="string">&quot;debit&quot;</span>.<span class="title function_ invoke__">into</span>(), amount);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wallet-rs"><a href="#wallet-rs" class="headerlink" title="wallet.rs"></a><strong>wallet.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    balance: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; balance: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">credit_balance</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">debit_balance</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.balance</span><br><span class="line">            .<span class="title function_ invoke__">checked_sub</span>(amount)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Balance is not sufficient&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="account-rs"><a href="#account-rs" class="headerlink" title="account.rs"></a><strong>account.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; name &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">check</span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">self</span>.name != name &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Account name is incorrect&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Account verified&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ledger-rs"><a href="#ledger-rs" class="headerlink" title="ledger.rs"></a><strong>ledger.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Ledger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Ledger</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">make_entry</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, account_id: &amp;<span class="type">String</span>, txn_type: <span class="type">String</span>, amount: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Make ledger entry for accountId &#123;&#125; with transaction type &#123;&#125; for amount &#123;&#125;&quot;</span>,</span><br><span class="line">            account_id, txn_type, amount</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="notification-rs"><a href="#notification-rs" class="headerlink" title="notification.rs"></a><strong>notification.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Notification</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send_wallet_credit_notification</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sending wallet credit notification&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send_wallet_debit_notification</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Sending wallet debit notification&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="security-code-rs"><a href="#security-code-rs" class="headerlink" title="security_code.rs"></a><strong>security_code.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SecurityCode</span> &#123;</span><br><span class="line">    code: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SecurityCode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; code &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">check</span>(&amp;<span class="keyword">self</span>, code: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.code != code &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Security code is incorrect&quot;</span>.<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Security code verified&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a><strong>main.rs</strong></h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> account;</span><br><span class="line"><span class="keyword">mod</span> ledger;</span><br><span class="line"><span class="keyword">mod</span> notification;</span><br><span class="line"><span class="keyword">mod</span> security_code;</span><br><span class="line"><span class="keyword">mod</span> wallet;</span><br><span class="line"><span class="keyword">mod</span> wallet_facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> wallet_facade::WalletFacade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wallet</span> = WalletFacade::<span class="title function_ invoke__">new</span>(<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wallet Facade interacts with the account, code, wallet, notification and</span></span><br><span class="line">    <span class="comment">// ledger behind the scenes.</span></span><br><span class="line">    wallet.<span class="title function_ invoke__">add_money_to_wallet</span>(&amp;<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>, <span class="number">10</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    wallet.<span class="title function_ invoke__">deduct_money_from_wallet</span>(&amp;<span class="string">&quot;abc&quot;</span>.<span class="title function_ invoke__">into</span>(), <span class="number">1234</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting create account</span><br><span class="line">Account created</span><br><span class="line"></span><br><span class="line">Starting add money to wallet</span><br><span class="line">Account verified</span><br><span class="line">Security code verified</span><br><span class="line">Sending wallet credit notification</span><br><span class="line">Make ledger entry for accountId abc with transaction type credit for amount 10</span><br><span class="line"></span><br><span class="line">Starting debit money from wallet</span><br><span class="line">Account verified</span><br><span class="line">Security code verified</span><br><span class="line">Sending wallet debit notification</span><br><span class="line">Make ledger entry for accountId abc with transaction type debit for amount 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
</search>
