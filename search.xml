<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(Life) Advice From The Creator of C++</title>
    <url>/2023/08/31/Life-Advice-From-The-Creator-of-Cpp/</url>
    <content><![CDATA[<h3 id="C-之父-Bjarne-Stroustrup-分享人生建议"><a href="#C-之父-Bjarne-Stroustrup-分享人生建议" class="headerlink" title="C++ 之父 Bjarne Stroustrup 分享人生建议"></a>C++ 之父 Bjarne Stroustrup 分享人生建议</h3><p>72岁的Bjarne Stroustrup发明了c++(于1985年首次发布)。38年后，他接受了Honeypot.io公司的一次简短<a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">采访</a>。提供了自己的人生建议:<br>不要过度专业化。不要太确定你知道未来的情况。要灵活变通,记住职业和工作是长期的事情。太多年轻人认为他们可以优化某些东西,然后发现自己在某些可能不是正确的东西上花费了两三年的时间进行专业化。在这个过程中,他们会感到烧毁,因为他们没有花足够的时间建立友谊和生活中的其他事情。<br>我遇到很多“初级极客”——我不知道该怎么称呼他们——他们认为计算机编程、AI、图形之类的专业知识才是唯一重要的东西。其实不是这样的……如果他们什么也不做,只是编写最好的代码,他们认为可以改变世界。但你必须能够倾听。你必须能够与潜在的用户沟通,并从他们那里学习。你也必须能够向他们传达自己的想法。<br>所以你不能只写代码。你必须做一些关于文化和表达想法的事情。我的意思是,我从来不后悔学习历史和数学所花的时间。数学增强你的思维,历史让你对自己的局限性和世界上正在发生的事情有所了解。所以不要太自信。花时间过平衡的生活。<br>要做好抓住机会的准备。我的意思是,广泛的教育,广泛的技能组合——通过教育建立起来的——意味着当机会出现时你可以抓住它。有时候你可以认识到它。我们有很多机会。但我们中很多人要么无法抓住,要么没有注意到。我相对广泛的教育经历——我学过标准的计算机科学,编译器,多种语言……我当时大概知道二十几种。我还学过机器架构,操作系统。这套技能组合发挥了作用。</p>
<h3 id="Life-Advice-From-The-Creator-of-C"><a href="#Life-Advice-From-The-Creator-of-C" class="headerlink" title="(Life) Advice From The Creator of C++"></a>(Life) Advice From The Creator of C++</h3><p>72-year-old Bjarne Stroustrup invented C++ (first released in 1985). 38 years later, he gave a <a href="https://www.youtube.com/watch?v=-QxI-RP6-HM">short interview</a> for Honeypot.io (which calls itself “Europe’s largest tech-focused job platform”) offering his own advice for life:</p>
<p>Don’t overspecialize. Don’t be too sure that you know the future. Be flexible, and remember that careers and jobs are a long-term thing. Too many young people think they can optimize something, and then they find they’ve spent a couple of years or more specializing in something that may not have been the right thing. And in the process they burn out, because they haven’t spent enough time building up friendships and having a life outside computing.</p>
<p>I meet a lot of sort of — I don’t know what you call them, “junior geeks”? — that just think that the only thing that matters is the speciality of computing — programming or AI or graphics or something like that. And — well, it isn’t… And if they do nothing else, well — if you don’t communicate your ideas, you can just as well do Sudoku… You have to communicate. And a lot of sort of caricature nerds forget that. They think that if they can just write the best code, they’ll change the world. But you have to be able to listen. You have to be able to communicate with your would-be users and learn from them. And you have to be able to communicate your ideas to them.</p>
<p>So you can’t just do code. You have to do something about culture and how to express ideas. I mean, I never regretted the time I spent on history and on math. Math sharpens your mind, history gives you some idea of your limitations and what’s going on in the world. And so don’t be too sure. Take time to have a balanced life.</p>
<p>And be ready for the opportunity. I mean, a broad-based education, a broad-based skill set — which is what you build up when you educate, you’re basically building a portfolio of skills — means that you can take advantage of an opportunity when it comes along. You can recognize it sometimes. We have lots of opportunities. But a lot of them, we either can’t take advantage of, or we don’t notice. It was my fairly broad education — I’ve done standard computer science, I’ve done compilers, I’ve done multiple languages… I think I knew two dozen at the time. And I have done machine architecture, I’ve done operating systems. And that skill set turned out to be useful.</p>
<p>At the beginning of the video, Stroustrup jokes that it’s hard to give advice — and that it’s at least as difficult as it is to take advice.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一键部署 Ollama在本地启动并运行大语言模型</title>
    <url>/2023/11/02/Ollama-%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;ollama/ollama:latest&#x27; locally</span><br><span class="line">latest: Pulling from ollama/ollama</span><br><span class="line">aece8493d397: Pull complete</span><br><span class="line">4eca1ad9be6c: Pull complete</span><br><span class="line">fcd9fc6db2c0: Pull complete</span><br><span class="line">Digest: sha256:871505ffb1050381f75875a645e7b24c37e1436fc51b915fd91a8ed202583e3b</span><br><span class="line">Status: Downloaded newer image for ollama/ollama:latest</span><br><span class="line">e8291c35ef1f8414f9b8ab008bc3c3523cb7881ad96ccf60745fffb5916e2d9e</span><br><span class="line">&gt; docker exec -it ollama ollama run llama2</span><br><span class="line">pulling manifest</span><br><span class="line">pulling 22f7f8ef5f4c... 100% |█████████████████████████████████| (3.8/3.8 GB, 29 MB/s)</span><br><span class="line">pulling 8c17c2ebb0ea... 100% |███████████████████████████████████| (7.0/7.0 kB, 3.2 kB/s)</span><br><span class="line">pulling 7c23fb36d801... 100% |███████████████████████████████████| (4.8/4.8 kB, 2.0 kB/s)</span><br><span class="line">pulling 2e0493f67d0c... 100% |████████████████████████████████████████| (59/59 B, 27 B/s)</span><br><span class="line">pulling 2759286baa87... 100% |██████████████████████████████████████| (105/105 B, 45 B/s)</span><br><span class="line">pulling 5407e3188df9... 100% |█████████████████████████████████████| (529/529 B, 163 B/s)</span><br><span class="line">verifying sha256 digest</span><br><span class="line">writing manifest</span><br><span class="line">removing any unused layers</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<blockquote>
<p>what’s your name?</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>你叫什么？</p>
</blockquote>
<p>I’m just an AI, I don’t have a personal name. My purpose is to assist and provide information to users like you through text-based conversations. How may I help you today?</p>
<blockquote>
<p>请帮我写一段自我介绍，我是一个python     后端程序员</p>
</blockquote>
<p>Sure, here’s a simple self-introduction for a Python developer:</p>
<p>“Hi there! My name is [Your Name], and I’m a Python developer with [Number of Years] years of experience. I specialize in developing web applications, data analysis, and machine learning models using Python. I’m passionate about solving complex problems and creating innovative solutions using my technical skills. In my free time, I enjoy learning new technologies and sharing knowledge with the developer community. Let’s connect and work together on exciting projects!”</p>
<blockquote>
<p> &#x2F;?</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;set         Set session variables<br>  &#x2F;show        Show model information<br>  &#x2F;bye         Exit<br>  &#x2F;?, &#x2F;help    Help for a command</p>
<p>Use <code>&quot;&quot;&quot;</code> to begin a multi-line message.</p>
<blockquote>
<p>&#x2F;show</p>
</blockquote>
<p>Available Commands:<br>  &#x2F;show license      Show model license<br>  &#x2F;show modelfile    Show Modelfile for this model<br>  &#x2F;show parameters   Show parameters for this model<br>  &#x2F;show system       Show system prompt<br>  &#x2F;show template     Show prompt template</p>
<blockquote>
<p> 我现在是在命令 行进行输入，怎么才能 输入多行呢？</p>
</blockquote>
<p>Great, you want to input multiple lines of text! In the command line, you can input multiple lines by pressing the <code>Enter</code> key after each line. For example:</p>
<ol>
<li><code>My name is John.</code></li>
<li><code>I&#39;m a Python developer with 5 years of experience.</code></li>
<li><code>I specialize in developing web applications and data analysis using Python.</code></li>
<li><code>In my free time, I enjoy learning new technologies and sharing knowledge with the developer community.</code></li>
</ol>
<p>After each line, press the <code>Enter</code> key to move on to the next line. When you’re finished, you can press <code>Ctrl+D</code> to exit the command prompt.</p>
<blockquote>
<p>可以帮我写一个python的冒泡排序吗？&#96;</p>
</blockquote>
<p>Of course! Here is an example of a simple bubble sort algorithm written in Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>This algorithm takes an array as input and sorts it using the bubble sort algorithm. It works by repeatedly iterating over the array, comparing adjacent elements, and swapping them if they are in the wrong order. The <code>range()</code> function is used to generate the loop indices for the iteration.</p>
<p>Here’s an example of how you could use this function:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(arr))</span><br></pre></td></tr></table></figure>
<p>This would output the sorted array <code>[1, 2, 3, 4, 5, 7]</code>.</p>
<p>Keep in mind that this is a very basic implementation of bubble sort, and it has a time complexity of O(n^2), which means it can take a long time to sort large arrays. There are more efficient algorithms for sorting large arrays, such as quicksort or mergesort.</p>
<blockquote>
<p>你可以用中文回答我吗？</p>
</blockquote>
<p>Of course! I can answer in Chinese if you’d like. Here is the same information in Chinese:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">泡沫排序</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>请使用以上函数来排序一个数组。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(泡沫排序(arr))</span><br></pre></td></tr></table></figure>
<p>这将输出排序后的数组 <code>[1, 2, 3, 4, 5, 7]</code>.</p>
]]></content>
  </entry>
  <entry>
    <title>I am Grinding King</title>
    <url>/2023/11/01/I-am-Grinding-King/</url>
    <content><![CDATA[<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解在中文里面“卷”的特别的意思吗？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>对,我了解在中文里“卷”这个词有一些特殊的含义:</p>
<ol>
<li>考试成绩很高,取得好成绩的意思。例如“他考试卷了满分”。</li>
<li>努力拼搏,全力以赴的意思。例如“为了考上好大学,他卷了一年”。</li>
<li>在某个领域技术很强,实力很厉害的意思。例如“他编程卷得很”。</li>
<li>某些事情处理的很到位或做得很好的意思。例如“这件事他卷得真不错”。</li>
<li>作弊或不正当手段取得好成绩的意思。例如“这场考试被人卷了”。</li>
<li>某地域的人学习努力或拼搏的风气。例如“J省的卷气太重”。<br>所以“卷”在口语或者网络语言中有着非常丰富的意思,需要根据上下文理解其具体所表示的意思。我会注意根据上下文去理解“卷”这个词的不同含义。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>你理解的很不错，我想说的就是内卷的那个意思，那么用英文怎么表达卷更加贴切呢</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>嗯,根据你提到的”内卷”的意思,我理解你问的”卷”指的是过度竞争造成的不健康的拼搏和压力。用英文来表达”卷”这层意思,一些较贴切的说法可以是:<br>Over-competition - 过度竞争<br>Cutthroat competition - 激烈的竞争<br>Rat race - 鼠竞<br>Treadmill effect - 越卷越累的效应<br>Vicious circle of competition - 恶性竞争怪圈<br>The pressure cooker effect - 压力煲效应<br>Burnout from excessive striving - 过度拼搏导致的倦怠<br>So in English, using terms like “over-competition”, “rat race”, “treadmill effect” can vividly convey the meaning of “内卷”. The key is to express how excessive competition can lead to unhealthily high pressure and diminishing returns. (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>但是我想卷还包含上进，努力，不停止的学习，前进，增加认知，不停地提升自己的能力 再次翻译一下试试</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您提到的卷含有上进、努力、不停止学习和提升自我的正面内涵,让我重新思考如何更好地翻译“卷”这个词。结合正面和负面含义,我建议可以这样表达:<br>Striving - 努力奋斗,全力以赴<br>Hustling - 拼搏,穷尽全力<br>Grinding - 不断磨练,持之以恒<br>Leveling up - 不断提升自我<br>Self-improvement through hard work - 通过努力工作来自我提升<br>Reaching for excellence - 追求卓越<br>Pushing oneself to the limit - 推动自我到达极限<br>Relentless self-cultivation - 不懈自我培养<br>以上词汇既能表达努力奋斗的积极意义,也能表达过度竞争的负面影响。重点是要传达一种在竞争中保持进取心和奋发向上的健康心态。希望这样的翻译更准确地把握“卷”的本意。请让我知道如果还有需要调整或补充的地方。 (edited)</p>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Over-competition 这个表达比较符合我想要的一部分，但是它没有包含我想要的上进，努力提升自己的能力这一部分信息，再尝试翻译</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您的意见令我获益匪浅。根据您进一步的解释,我认为“over-competition”无法全面表达“卷”所包含的积极意义。经过思考,我建议使用“self-improvement grind”来翻译更为贴切:<br>Self-improvement grind: 自我提升的拼搏磨砺<br>理由如下:</p>
<ol>
<li>Self-improvement 包含了上进心态与增强自我能力的意思。</li>
<li>Grind 包含努力不懈、持之以恒的意思。</li>
<li>将 self-improvement 和 grind 搭配,可以表达用拼搏的精神磨砺自己、不断取得进步的意思。</li>
<li>与 over-competition 相比,它更强调主动进取,而不是被动的过度竞争。</li>
<li>它可以平衡表达努力和压力,更全面捕捉“卷”的本意。<br>请您评价一下“self-improvement grind” 这个翻译是否准确表达了“卷”的意思。如果还有需要调整的地方,非常欢迎您提出宝贵意见,我会继续完善翻译。衷心感谢您的精彩思路和建设性反馈! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>差不多了，我想给自己起一个笔名，类似卷王， 如果是The King of self-improvement grind肯定不合适，请尝试给我一个看上去能表达意思，又简洁的笔名表达卷王之王</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您好,很高兴我对“卷”的翻译越来越接近您要表达的意思了。<br>针对“卷王”这个笔名,我推荐使用:<br>Grind King<br>理由如下:</p>
<ol>
<li>Grind 包含拼搏和努力的意味,可表达“卷”的精神内涵。</li>
<li>King 表示“王者”,与“卷王”对应。</li>
<li>Grind King 简洁有力,与 Self-improvement King 相比更加精准表达“卷王”之意。</li>
<li>保留 Grind 而不使用 Self-improvement,更贴合“卷王”强调拼搏竞争的一面。</li>
<li>英文名字简短且易记,能够成为一个好的笔名。<br>请您评价一下“Grind King”这个笔名是否表达了“卷王”的意思并适合作为笔名使用。如果还有需要调整的地方,非常欢迎您提出修改意见。我会继续努力,找到一个既响亮又精准的翻译。衷心感谢您的反馈和指导! (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>Grinding King是不是会更加贴切，表达出一种正在卷的一种状态？</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>您给我的反馈令我受益匪浅!您提出使用 “Grinding King” 会更加贴切和准确,我完全同意这一建议:</p>
<ol>
<li>Grinding 作为动词进行时,能够表达出一个正在卷并保持卷的状态,更贴合“卷王”的意思。</li>
<li>Grinding King 相比 Grind King 更能突出这是一个持续努力的过程,而不是一个终点。</li>
<li>在笔名和称号中使用动词进行时,能够增加一个正处在努力卷中状态的感觉,更有活力。</li>
<li>Grinding King 在视觉和语义上都很连贯、朗朗上口。<br>综上所述,我认为 Grinding King 是翻译“卷王”的最佳选择。它既简洁有力,又准确传达了正处于持续卷中的意味。非常感谢您给我的反馈,这极大地帮助我澄清和完善了对这个翻译的理解。我会牢记您的建议,继续提高翻译的准确性和传神性。 (edited)</li>
</ol>
<blockquote>
<p><em><strong>Ice:</strong></em></p>
</blockquote>
<p>好的，请叫我Grinding King</p>
<blockquote>
<p><em><strong>Claude:</strong></em></p>
</blockquote>
<p>好的,很高兴我们最终找到了一个您满意的翻译 - Grinding King 来表示“卷王”。我从这一讨论过程中学习到:</p>
<ol>
<li>翻译一个词语需要考虑它的文化内涵和语境,不能生搬硬套。</li>
<li>和您多次交流和反馈非常关键,让我不断优化和调整翻译方案。</li>
<li>动词进行时能增加活力和连续的意味,更贴合“卷王”的意思。</li>
<li>一个好的翻译需要兼顾准确和简洁。<br>我会牢记这次讨论的经验教训,来提高我的中文翻译能力,以后的翻译工作中表达更加地道和传神。再次感谢您的时间和反馈,让我受益良多。每次和人交流对我来说都是宝贵的学习经历。祝您生活愉快,Grinding King!</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hexo Commands</title>
    <url>/2023/08/19/hexo-commands/</url>
    <content><![CDATA[<h3 id="Hexo-命令"><a href="#Hexo-命令" class="headerlink" title="Hexo 命令"></a>Hexo 命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>-p, –path</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td>文章的slug， 作为新文章的文件名和发布后的url</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加分类和标签</title>
    <url>/2023/08/20/hexo_categories_tag/</url>
    <content><![CDATA[<h3 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h3><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-08-20 15:33:52</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。<br>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h3 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h3><p>生成“标签”页并添加tpye属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2023-08-20 15:40:07</span><br><span class="line">type: tag</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello Rust</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Rust学习资料</span><br><span class="line">tag: Rust</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>PEP 703（使全局解释器锁在 CPython 中可选）验收</title>
    <url>/2023/10/27/pep-703-making-the-global-interpreter-lock-optional-in-cpython-acceptance/</url>
    <content><![CDATA[<h3 id="PEP-703（使全局解释器锁在-CPython-中可选）验收"><a href="#PEP-703（使全局解释器锁在-CPython-中可选）验收" class="headerlink" title="PEP 703（使全局解释器锁在 CPython 中可选）验收"></a>PEP 703（使全局解释器锁在 CPython 中可选）验收</h3><p>(Posted for the whole Steering Council.)<br>（发布给整个指导委员会。)</p>
<p>As we’ve <a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">announced before</a>, the Steering Council has decided to accept <a href="https://peps.python.org/pep-0703/">PEP 703 (Making the Global Interpreter Lock Optional in CPython)</a> . We want to make it clear why, and under what expectations we’re doing so.<br>正如我们之前<a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">宣布</a>的，指导委员会已决定接受<a href="https://peps.python.org/pep-0703/">PEP 703（使CPython中的全局解释器锁可选）</a>。我们想明确说明为什么，以及我们这样做的期望。</p>
<p>It is clear to the Steering Council that theoretically, a no-GIL (or free-threaded) Python would be of great benefit, and the majority of the community seems in agreement. Threads have significant downsides and caveats, but they are widely adopted, both by software and hardware, and they do enable more scalable solutions to problems. The GIL clearly inhibits CPython in this, and removing that barrier would be a good thing.<br>指导委员会很清楚，从理论上讲，无 GIL（或自由线程）Python 将大有裨益，社区的大多数人似乎都同意这一点。线程有明显的缺点和警告，但它们被软件和硬件广泛采用，并且它们确实为问题提供了更具可扩展性的解决方案。GIL在这方面显然抑制了CPython，消除这种障碍将是一件好事。</p>
<p>At the same time we’re not sure if it’s possible to remove the GIL without fundamentally breaking all extension modules out there, or significantly reducing the performance or maintainability of CPython. The third-party&#x2F;PyPI package ecosystem is one of Python’s strengths, and the tight, efficient integration with C libraries is one of CPython’s. It has enabled the existence of a diverse selection of packages that’s a unique selling point for Python. We need to be careful that we do not destroy those benefits, or discard decades worth of package development.<br>同时，我们不确定是否可以在不从根本上破坏所有扩展模块的情况下删除 GIL，或者显着降低 CPython 的性能或可维护性。第三方&#x2F;PyPI 包生态系统是 Python 的优势之一，与 C 库的紧密、高效集成是 CPython 的优势之一。它使各种包的存在成为可能，这是Python的独特卖点。我们需要小心，不要破坏这些好处，或者放弃几十年的软件包开发。</p>
<p>Assessing the practical impact, and the practicality of adapting third-party packages to the new free-threaded situation, is difficult without a finished implementation. The unpredictable nature of thread-related issues makes it extra difficult, as some issues won’t show up until put under significant load. The changes necessary to remove the GIL are substantive enough, and require so much coordination with other CPython development happening at the same time, that we can’t reasonably do these experiments in a fork of CPython. We also want to avoid the risk of ecosystem fragmentation and unnecessarily diverging changes because of the work being done in a fork. For PEP 703 to move forward, it has to be included in CPython’s main, and released as part of regular releases (albeit not necessarily by default).<br>如果没有完成的实现，评估实际影响以及使第三方包适应新的自由线程情况的实用性是很困难的。线程相关问题的不可预测性使其变得格外困难，因为某些问题在承受大量负载之前不会显示出来。删除 GIL 所需的更改是实质性的，并且需要与同时发生的其他 CPython 开发进行如此多的协调，以至于我们无法合理地在 CPython 的分支中进行这些实验。我们还希望避免由于分叉中所做的工作而导致生态系统碎片化和不必要的差异变化的风险。为了使PEP 703向前发展，它必须包含在CPython的主版本中，并作为常规版本的一部分发布（尽管不一定是默认的）。</p>
<p>But while we think removal of the GIL is a worthy and necessary goal, and PEP 703 is the best proposal for it so far, we can’t at this stage guarantee that it will work out. We have to, as we develop PEP 703’s implementation and the necessary user-visible changes to semantics, APIs and ABIs, continually evaluate the feasibility, and be prepared to change course – or reverse it, if that turns out to be necessary.<br>但是，虽然我们认为取消 GIL 是一个有价值且必要的目标，并且 PEP 703 是迄今为止最好的建议，但我们不能在现阶段保证它会成功。当我们开发PEP 703的实现以及对语义，API和ABI的必要用户可见更改时，我们必须不断评估可行性，并准备改变方向 - 或者在必要时扭转它。</p>
<p>As mentioned before, we see this as a rollout in roughly three stages:<br>如前所述，我们认为这是大约三个阶段的推出：</p>
<ul>
<li>Phase I: Experimental phase, which can start immediately, in which the free-threaded build is enabled through a build-time option. This should not be the default install anywhere. At least one major Python release should include this experimental free-threaded build, to allow third-party packages to test and do their own experimentation. In this stage we should make it clear the build is experimental, not supported for “production use”, and may be reverted.<br>阶段 I：实验阶段，可以立即开始，其中通过构建时选项启用自由线程构建。这不应该是任何地方的默认安装。至少一个主要的 Python 版本应该包含这个实验性的自由线程构建，以允许第三方包进行测试并进行自己的实验。在此阶段，我们应该明确构建是实验性的，不支持“生产用途”，并且可以还原。</li>
<li>Phase II: Supported-but-not-default phase, which would start when the API and ABI changes have sufficiently settled, and there is sufficient community support. Exact criteria for this phase are hard to pin down at this stage, so this will have to involve some discussion among Core Devs and the community, and a decision by the SC at the time. At this point reverting should still be possible (so for example preprocessor guards should remain in place) although obviously we aren’t expecting it.<br>第二阶段：支持但非默认阶段，当 API 和 ABI 更改充分解决并且有足够的社区支持时，该阶段将开始。在这个阶段很难确定这个阶段的确切标准，所以这必须涉及核心开发人员和社区之间的一些讨论，以及当时SC的决定。在这一点上，恢复应该是可能的（因此，例如预处理器保护应该保留在原位），尽管显然我们并不期望它。</li>
<li>Phase III: Default phase, at which point the free-threaded build becomes the default (but can initially still be disabled). Again, the exact criteria are hard to pin down this far ahead, but the aim is to make this as seamless and painless a default flip as possible. Like the previous phase, the SC at the time will need to make a decision as to when this occurs. Some time after the default flip, when we have a good indication it’s no longer widely used, we should start the discussion on removing the GIL build entirely.<br>阶段 III：默认阶段，此时自由线程构建成为默认阶段（但最初仍可禁用）。同样，确切的标准很难确定这么远，但目的是使它尽可能无缝和无痛地默认翻转。与上一阶段一样，当时的SC需要决定何时发生这种情况。在默认翻转后的一段时间，当我们有一个很好的指示它不再被广泛使用时，我们应该开始讨论完全删除 GIL 构建。<br>The details of the phases are deliberately vague, simply because we can’t know all the ecosystem impact details yet, and we don’t want to set conservative standards now and then hold people to them when in practice we’re being too cautious. (We don’t want to set overly ambitious goals and break too many things, either.)<br>这些阶段的细节故意含糊不清，仅仅是因为我们还不能知道所有的生态系统影响细节，我们不想现在设定保守的标准，然后在实践中我们过于谨慎时让人们遵守这些标准。（我们也不想设定过于雄心勃勃的目标，也不想破坏太多的东西。</li>
</ul>
<p>For some of the changes necessary for the free-threaded build, like switching to <a href="https://github.com/microsoft/mimalloc">mimalloc</a> or significant changes to the GC, it may be useful to make these separately build-time opt-ins, and perhaps make them the default before the free-threaded build becomes the default build (but not before it becomes fully supported). Having them separately enableable allows for experimentation, performance measurements and debugging focusing on the isolated set of changes. We don’t want a complex matrix of build flags, so this should probably be limited to one or two.<br>对于自由线程构建所需的某些更改，例如切换到<a href="https://github.com/microsoft/mimalloc">mimalloc</a>或对 GC 进行重大更改，进行这些单独的构建时选择加入可能很有用，并且可能在自由线程构建成为默认构建之前将它们设为默认值（但不是在它完全受支持之前）。让它们单独启用允许实验、性能测量和调试，重点是孤立的一组更改。我们不想要一个复杂的构建标志矩阵，所以这可能应该限制在一个或两个。</p>
<p>Regarding the expected performance impact of the free-threaded build, the SC thinks a significant performance penalty is expected in a free-threaded build, and the benefit is probably worth that price. At this point we’re expecting a (worst case) performance penalty of 10-15%. We don’t want to set strict limits on acceptable performance, partly because we don’t want to get stuck in arguments about how to measure performance and partly because it will depend on user expectations and, for example, how much performance work is invalidated and how much we can expect to see recuperated over time. Solutions for the free-threaded build that are fundamentally problematic for performance improvements going forward, are less acceptable than solutions that are currently suboptimal but have room for improvement.<br>关于自由线程构建的预期性能影响，SC 认为自由线程构建中预计会出现显著的性能损失，其好处可能值得这个价格。在这一点上，我们预计（最坏情况）性能损失为 10-15%。我们不想对可接受的性能设置严格的限制，部分原因是我们不想陷入关于如何衡量性能的争论中，部分原因是这将取决于用户的期望，例如，有多少性能工作无效，以及我们可以期望看到多少随着时间的推移而恢复。自由线程构建的解决方案从根本上对未来的性能改进存在问题，与当前次优但有改进空间的解决方案相比，这些解决方案更不可接受。</p>
<p>The performance impact should be isolated to a free-threaded build; a GIL build should not see any performance impact in existing code. For API and ABI changes necessary to support both GIL and free-threaded builds (e.g. avoiding APIs that return borrowed references or that rely on the GIL to protect shared data), it’s reasonable for the new interfaces to be slightly less performant, but we expect this to be very limited and usually lost in the noise.<br>性能影响应隔离到自由线程生成;GIL 生成不应在现有代码中看到任何性能影响。对于支持 GIL 和自由线程构建所需的 API 和 ABI 更改（例如，避免返回借用引用或依赖 GIL 来保护共享数据的 API），新接口的性能略低是合理的，但我们预计这非常有限，并且通常会在噪音中丢失。</p>
<p>In a similar vein, it’s important that as the free-threaded build lands in main, so that its implementation is considered in other development work that’s going on. New features can’t land without proper support for the free-threaded build, when the two intersect. It may seem tempting to ignore free-threaded when developing thread-adjacent changes, but in the end someone will have to make it work, and it’s neither fair nor particularly forward-thinking to expect the free-threaded maintainers to do all the work. We also need to be mindful of the cohesiveness of the language, the implementation and the C API. We have to assume the free-threaded build will be the only build in the reasonable future, and like other fundamental changes to CPython internals, we all have to learn the new way of approaching these problems. This may be a bit of a jump in terms of complexity – the GIL implicitly simplified so much – but it is a necessary step. We do expect, at least initially, the free-threaded build experts to help others ramp up here. The experimental phase is there for CPython and the Core Devs to get used to the free-threaded build as much as it is for users.<br>同样，重要的是，随着自由线程构建登陆main，以便在正在进行的其他开发工作中考虑其实现。当两者相交时，如果没有对自由线程构建的适当支持，新功能就无法落地。在开发与线程相邻的更改时，忽略自由线程似乎很诱人，但最终必须有人让它工作，期望自由线程维护者完成所有工作既不公平也不特别具有前瞻性。我们还需要注意语言、实现和 C API 的凝聚力。我们必须假设自由线程构建将是合理未来唯一的构建，并且就像 CPython 内部的其他根本性更改一样，我们都必须学习解决这些问题的新方法。就复杂性而言，这可能有点飞跃 - GIL隐含地简化了这么多 - 但这是一个必要的步骤。我们确实希望，至少在最初，自由线程构建专家能够帮助其他人在这里提升。实验阶段是CPython和核心开发人员习惯自由线程构建的，就像用户一样。</p>
<p>We do need a few specific things resolved before PEP 703 can leave the experimental phase. For starters, we need a solution for the ABI. The SC believes strongly that a single ABI serving both with-GIL and free-threaded builds should be possible, should be made possible, and should be required before leaving the experimental phase. If this turns out to be an unreasonable requirement, we’ll have to look at alternative solutions to ease the pressure on package maintainers (e.g. building two extension modules in the same wheel, or providing a compatibility layer through a separate library).<br>在PEP 703离开实验阶段之前，我们确实需要解决一些具体问题。首先，我们需要一个针对 ABI 的解决方案。SC 坚信，在离开实验阶段之前，应该有可能，应该成为可能，并且应该需要同时使用 GIL 和自由线程构建的单个 ABI。如果事实证明这是一个不合理的要求，我们将不得不寻找替代解决方案来减轻软件包维护者的压力（例如，在同一轮子上构建两个扩展模块，或通过单独的库提供兼容层）。</p>
<p>We also need to consider the testing matrix, both for CPython and for third-party packages. Even with a stable ABI we still need to multiply the test matrix. We probably don’t need complete coverage on all supported platforms, but we do want at least one free-threaded buildbot for each of the T1&#x2F;T2 platforms, as well as some way to test the validity of the unified ABI (a way to build things in one build mode and test against an interpreter built in the other build mode). We currently rely on the stable ABI check and third-party testing of the stable ABI, but that will probably not be good enough to ensure the compatibility between the GIL and free-threaded builds. To get to the supported phase we also expect CI checks on GitHub for free-threaded builds on each of the major platforms.<br>我们还需要考虑CPython和第三方软件包的测试矩阵。即使有稳定的ABI，我们仍然需要乘以测试矩阵。我们可能不需要在所有支持的平台上完全覆盖，但我们确实希望每个 T1&#x2F;T2 平台至少有一个自由线程构建机器人，以及某种方法来测试统一 ABI 的有效性（一种在一种构建模式下构建东西并针对在另一种构建模式下构建的解释器进行测试的方法）。我们目前依赖于稳定 ABI 检查和稳定 ABI 的第三方测试，但这可能不足以确保 GIL 和自由线程构建之间的兼容性。为了进入支持的阶段，我们还希望在 GitHub 上对每个主要平台上的自由线程构建进行 CI 检查。</p>
<p>There are a few specific things we want to avoid. We do not want the free-threaded build to be used as the default Python anywhere until the Core Devs and the Python community are ready for that. Obviously we can’t stop users and distributors from installing a free-threaded build by default, but we think at this stage it would be a mistake to do so for anything besides end-to-end experimentation. We also want to avoid labelling the free-threaded build “experimental” after the experimental phase. Build-time flags, defines, comments in the code should avoid the word. We want to avoid negatives in terms and flags and such, so we won’t get into double-negative terrain (like we do when we talk about ‘non no-GIL’). We’d like a positive, clear term to talk about the no-GIL build, and we’re suggesting ‘free-threaded’. (Relatedly, that’s why the build mode&#x2F;ABI letter is ‘t’ and not ‘n’; that change was already made.)<br>我们想要避免一些具体的事情。我们不希望在核心开发人员和 Python 社区准备好之前，在任何地方将自由线程构建用作默认 Python。显然，默认情况下，我们无法阻止用户和分销商安装自由线程构建，但我们认为在现阶段，除了端到端实验之外，这样做都是错误的。我们还希望避免在实验阶段之后将自由线程构建标记为“实验性”。代码中的构建时标志、定义、注释应避免使用这个词。我们希望避免在术语和标志等方面出现负面因素，因此我们不会陷入双重负面领域（就像我们谈论“非无 GIL”时所做的那样）。我们想要一个积极、明确的术语来讨论无 GIL 构建，我们建议使用“自由线程”。（与此相关的是，这就是为什么构建模式&#x2F;ABI 字母是“t”而不是“n”;该更改已经进行了。</p>
<p>In short, the SC accepts PEP 703, but with clear provisio: that the rollout be gradual and break as little as possible, and that we can roll back any changes that turn out to be too disruptive – which includes potentially rolling back all of PEP 703 entirely if necessary (however unlikely or undesirable we expect that to be).<br>简而言之，SC 接受 PEP 703，但有明确的条件：推出是渐进的，尽可能少地中断，我们可以回滚任何破坏性太大的更改——其中包括在必要时可能完全回滚所有 PEP 703（无论我们期望多么不可能或不希望）。</p>
<p>For the whole SC,<br>Thomas.</p>
]]></content>
  </entry>
  <entry>
    <title>我应该支持以色列还是巴勒斯坦？</title>
    <url>/2023/10/20/should_I_support_Israel_or_Palestine/</url>
    <content><![CDATA[<h3 id="我应该支持以色列还是巴勒斯坦？"><a href="#我应该支持以色列还是巴勒斯坦？" class="headerlink" title="我应该支持以色列还是巴勒斯坦？"></a>我应该支持以色列还是巴勒斯坦？</h3><p>这是我在quora上看到到一个高赞回答，粗浅翻译一下，重点是他来自以色列特拉维夫。<br>原文地址：<a href="https://qr.ae/pKvZJk">https://qr.ae/pKvZJk</a><br>原文作者信息：<br>Sociology and Management from The Open UniversityGraduated 2015<br>Lives in Tel Aviv, Israel<br>863K content views258.7K this month<br>Joined November 2013</p>
<p>I am an Israeli, and as an Israeli, I should, with a heavy heart, suggest you support the Palestinians. Why? Because, unlike Israel, they need your support.<br>我是以色列人，作为以色列人，我应该怀着沉重的心情建议你支持巴勒斯坦人。为什么？因为，与以色列不同，他们需要您的支持。</p>
<p>I don’t want to talk about history. Both sides can provide good arguments as to why this piece of land is theirs by right. I don’t want to go into who’s responsible for the conflict - both sides will provide countless examples of the atrocities inflicted on them by the other side.<br>我不想谈论历史。双方都可以提供很好的论据来解释为什么这块土地理所当然地属于他们。我不想讨论谁对这场冲突负责——双方都会提供无数的例子来说明对方对他们施加的暴行。</p>
<p>I want to talk about the here and now. The fact is that there are currently 9 million Israeli citizens (6 million of them are Jews) who live in a relative comfort: they can go, live and work wherever they want inside Israel. Israel is a democracy, so we’re free to elect and out-vote our leaders in case we don’t like how they manage our affairs. In addition, because Israel is a recognized member of the UN, an Israeli citizen is free to use their passport to travel and trade with the rest of the world.<br>我想谈谈此时此地。事实是，目前有 900 万以色列公民（其中 600 万是犹太人）生活相对舒适：他们可以在以色列境内任何想去的地方生活和工作。以色列是一个民主国家，因此，如果我们不喜欢他们管理我们事务的方式，我们可以自由地选举和否决我们的领导人。此外，由于以色列是联合国公认的成员，以色列公民可以自由使用其护照与世界其他地区旅行和贸易。</p>
<p>The 5 million Palestinians living in Gaza and The West Bank, on the other hand, do not enjoy those freedoms. They practically live in an occupied territory which is governed by Israel, but was never officially annexed. That means they do not enjoy the rights of Israeli citizens (they are not citizens after all), but they are forced to live their lives based on decisions made by Israeli politicians and army generals. They cannot build houses or start new businesses outside their current cities, they have to get permits to work inside Israel or to travel abroad, and their borders are controlled by Israel, so they can’t import and export goods and cultivate a healthy economy. They are basically completely reliant on their Israeli occupiers. The Palestinians tried to revolt many times - either by force or in diplomatic manners. But all their attempts have failed miserably by the much stronger Israel.<br>另一方面，生活在加沙和西岸的 500 万巴勒斯坦人却无法享受这些自由。他们实际上生活在以色列管辖的被占领土上，但从未被正式吞并。这意味着他们不享有以色列公民的权利（他们毕竟不是公民），但他们被迫根据以色列政客和军队将军的决定而生活。他们不能在现有城市之外建造房屋或开办新企业，必须获得在以色列境内工作或出国旅行的许可，而且他们的边境由以色列控制，因此他们无法进出口货物并培育健康的经济。他们基本上完全依赖以色列占领者。巴勒斯坦人多次试图通过武力或外交方式进行反抗。但他们的所有尝试都因强大得多的以色列而惨遭失败。</p>
<p>Ask the average Israeli about it, and they’ll tell you that the Palestinians have brought it onto themselves. Considering the horrible violence showed in the past by the Palestinians and the other Arabic countries - Israel would be crazy to give up on its right to defend itself. They may be right, but it doesn’t change the fact that there are 5 million people who are the citizens of no country and who live under occupation. I suspect that even if the Palestinians will promise to never use violence against it - Israel will never trust their word and give up on its control. Things will only change if people like you will support the Palestinians’ right to live like any other citizen in any other normal country in the world. It doesn’t mean you should support Palestinian violence though, but do support, and demand, their right to be free.<br>问问普通以色列人，他们会告诉你这是巴勒斯坦人自找的。考虑到巴勒斯坦人和其他阿拉伯国家过去所表现出的可怕暴力——以色列放弃自卫权将是疯狂的。他们也许是对的，但这并不能改变这样一个事实：有 500 万人不是任何国家的公民，生活在占领之下。我怀疑，即使巴勒斯坦人承诺永远不会对其使用暴力，以色列也永远不会相信他们的诺言并放弃对其的控制。只有像你们这样的人支持巴勒斯坦人像世界上任何其他正常国家的任何其他公民一样生活的权利，事情才会改变。但这并不意味着您应该支持巴勒斯坦暴力，而是支持并要求他们的自由权。</p>
<p>So support Palestine. Otherwise, things will never change.<br>所以支持巴勒斯坦。否则，事情永远不会改变。</p>
<p>Edit: Wow… I never thought this answer would attract so much attention. Thank you for all the upvotes, comments and shares. Still, I decided to block new comments for now. Whether you agreed with my opinion or not - most of you guys posted warm and respectful comments and I apologize for not being able to respond to all of them. Still, some of the readers out there decided it would be the best to express their disagreement by posting sarcastic, cynical or plain hateful comments which I got tired of reading at some point.<br>编辑：哇…我从没想过这个答案会引起如此多的关注。感谢大家的点赞、评论和分享。尽管如此，我还是决定暂时阻止新评论。无论您是否同意我的观点 - 你们中的大多数人都发表了热情而尊重的评论，对于无法回复所有评论，我深表歉意。尽管如此，一些读者还是认为最好通过发表讽刺、愤世嫉俗或纯粹的仇恨评论来表达他们的不同意见，而我在某些时候厌倦了阅读这些评论。</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 只保留最近一周的日志</title>
    <url>/2023/08/18/ubuntu-%E5%8F%AA%E4%BF%9D%E7%95%99%E6%9C%80%E8%BF%91%E4%B8%80%E5%91%A8%E7%9A%84%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="只保留最近一周的日志"><a href="#只保留最近一周的日志" class="headerlink" title="只保留最近一周的日志"></a>只保留最近一周的日志</h3><ul>
<li><p>只保留最近一周的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-time=1w</span><br></pre></td></tr></table></figure>
</li>
<li><p>只保留最多500M日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-size=500M</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 时钟显示秒</title>
    <url>/2023/08/18/ubuntu-%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA%E7%A7%92/</url>
    <content><![CDATA[<h3 id="时钟显示秒"><a href="#时钟显示秒" class="headerlink" title="时钟显示秒"></a>时钟显示秒</h3><p>Ubuntu 日期时间显示格式“月-日 星期, 时-分-秒”命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.interface clock-show-seconds true</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20.04/ubuntu22.04 安装，环境配置遇到的问题以及解决方案</title>
    <url>/2023/08/29/ubuntu20-04-ubuntu22-04-%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="build-a-python-env-on-ubuntu20-04"><a href="#build-a-python-env-on-ubuntu20-04" class="headerlink" title="build a python env on ubuntu20.04"></a>build a python env on ubuntu20.04</h3><h4 id="fix-virtualenvwarpper"><a href="#fix-virtualenvwarpper" class="headerlink" title="fix virtualenvwarpper"></a>fix virtualenvwarpper</h4><p>(Ubuntu20.04安装virtualenv方法以及安装过程中遇到的问题处理)[<a href="https://blog.csdn.net/qq_42296146/article/details/108291436]">https://blog.csdn.net/qq_42296146/article/details/108291436]</a></p>
<p>问题：bash: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh: No such file or directory</p>
<p>ubuntu18及以上版本，virtualenvwrapper.sh被安装到了家目录下的.local&#x2F;bin&#x2F;中，非原来的&#x2F;usr&#x2F;local&#x2F;bin&#x2F;中</p>
<p>&#x2F;usr&#x2F;share&#x2F;virtualenvwrapper&#x2F;virtualenvwrapper.sh 实际安装的位置，只要把这个地址配置到.brashrc之后就可以正常运行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.10</span><br><span class="line">export VIRTUALENVWRAPPER_VIRTUALENV=/usr/bin/virtualenv</span><br><span class="line">source /usr/share/virtualenvwrapper/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>
<h4 id="install-a-local-git-repo-updata"><a href="#install-a-local-git-repo-updata" class="headerlink" title="install a local git repo updata"></a>install a local git repo updata</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@bitbucket.org:ginolegaltech/updata.git</span><br><span class="line">$ cd updata</span><br><span class="line">&amp; python3.10 setup.py install</span><br><span class="line">$ rm -rf build/</span><br><span class="line">$ rm -rf updata.egg-info/</span><br></pre></td></tr></table></figure>

<h5 id="fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py"><a href="#fix-ImportError-cannot-import-name-‘html5lib’-from-‘pip-vendor’-home-ice-virtualenvs-310-lib-python3-10-site-packages-pip-vendor-init-py" class="headerlink" title="fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;init.py)"></a>fix ImportError: cannot import name ‘html5lib’ from ‘pip._vendor’ (&#x2F;home&#x2F;ice&#x2F;.virtualenvs&#x2F;310&#x2F;lib&#x2F;python3.10&#x2F;site-packages&#x2F;pip&#x2F;_vendor&#x2F;<strong>init</strong>.py)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sS https://bootstrap.pypa.io/get-pip.py | python3.10</span><br></pre></td></tr></table></figure>



<h4 id="bash-显示当前所在分支"><a href="#bash-显示当前所在分支" class="headerlink" title="bash 显示当前所在分支"></a>bash 显示当前所在分支</h4><p>在.bashrc文件追加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function git_branch &#123;</span><br><span class="line">   branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\*&quot; | sed -e &quot;s/^\*\ //&quot;`&quot;</span><br><span class="line">   if [ &quot;$&#123;branch&#125;&quot; != &quot;&quot; ];then</span><br><span class="line">       if [ &quot;$&#123;branch&#125;&quot; = &quot;(no branch)&quot; ];then</span><br><span class="line">           branch=&quot;(`git rev-parse --short HEAD`...)&quot;</span><br><span class="line">       fi</span><br><span class="line">       echo &quot; ($branch)&quot;</span><br><span class="line">   fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export PS1=&#x27;\u@\h \[\033[01;36m\]\w\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#x27;</span><br></pre></td></tr></table></figure>

<h4 id="install-virtualbox"><a href="#install-virtualbox" class="headerlink" title="install virtualbox"></a>install virtualbox</h4><p><a href="https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/">https://computingforgeeks.com/install-virtualbox-6-on-ubuntu-linux/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># step 1</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y upgrade</span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line"># step 2</span><br><span class="line">#Download</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox_2016.asc | gpg --dearmor &gt; oracle_vbox_2016.gpg</span><br><span class="line">curl https://www.virtualbox.org/download/oracle_vbox.asc | gpg --dearmor &gt; oracle_vbox.gpg</span><br><span class="line">#Install on system</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox_2016.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line">sudo install -o root -g root -m 644 oracle_vbox.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><br><span class="line"># step 3</span><br><span class="line"># ubuntu 22.04 </span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian focal contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># Ubuntu 20.04/18.04:</span><br><span class="line">echo &quot;deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian $(lsb_release -sc) contrib&quot; | sudo tee /etc/apt/sources.list.d/virtualbox.list</span><br><span class="line"></span><br><span class="line"># step 4</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install linux-headers-$(uname -r) dkms</span><br><span class="line">sudo apt install virtualbox-6.1</span><br></pre></td></tr></table></figure>

<p>virtualbox start error:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig </span><br><span class="line">[sudo] password for rcrozier:           </span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: You must sign these kernel modules before using VirtualBox:</span><br><span class="line">  vboxdrv vboxnetflt vboxnetadp</span><br><span class="line">See the documenatation for your Linux distribution..</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">debconf: DbDriver &quot;config&quot;: /var/cache/debconf/config.dat is locked by another process: Resource temporarily unavailable</span><br><span class="line">vboxdrv.sh: Failed to enroll secure boot key..</span><br><span class="line">vboxdrv.sh: failed: modprobe vboxdrv failed. Please use &#x27;dmesg&#x27; to find out why.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>

<p>搜索了很多解决方案都无法处理，最后还是仔细看了报错信息，这里其实有一个很重要的提示信息<code>Secure Boot you may need to sign the kernel modules</code></p>
<p>最后搜到<a href="https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why">https://askubuntu.com/questions/900118/vboxdrv-sh-failed-modprobe-vboxdrv-failed-please-use-dmesg-to-find-out-why</a> 这个答案最后的以解决答案：</p>
<p>The above answer probably works fine, but if you want an easier time for it:</p>
<p>I was able to solve it by</p>
<p>booting into the BIOS and going &gt; advanced (f7) &gt; boot &gt; scroll down to “secure boot” &gt; change “Windows EUFI mode” to “other OS”</p>
<p>My virtualbox works perfectly now.</p>
<p>最后对于为为的解决方案就是进入BIOS系统之后，和这个答案每个硬件平台的BIOS版本会有所不同(我的硬件三HUAWEI MateBook X Pro 2022)找到”secure boot”关键词对应的默认直是enable，为改为disable，第一次修改没有其作用，是应推出的时候没有保存，第二次再修改选择save and exit，再进入ubuntu启动virtualbox就可以正常运作了。</p>
<p>最近在ubuntu22.04 安装virtualbox的时候遇到另外还有一个报错：</p>
<h3 id="vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv"><a href="#vboxdrv-sh-failed-Cannot-change-group-vboxusers-for-device-dev-vboxdrv" class="headerlink" title="vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv."></a>vboxdrv.sh: failed: Cannot change group vboxusers for device &#x2F;dev&#x2F;vboxdrv.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行：/sbin/vboxconfig</span><br><span class="line">输出如下报错</span><br><span class="line">root@ice:~# /sbin/vboxconfig</span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">vboxdrv.sh: failed: Cannot change group vboxusers for device /dev/vboxdrv.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system&#x27;s documentation for more information.</span><br></pre></td></tr></table></figure>
<ul>
<li>创建vboxusers group<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd vboxusers</span><br></pre></td></tr></table></figure></li>
<li>把当前user 加入到这个group， 你替换这里的ice<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -a -G vboxusers ice</span><br></pre></td></tr></table></figure></li>
<li>检查是否添加成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep vboxusers /etc/group</span><br><span class="line"># 输出为:</span><br><span class="line"># vboxusers:x:1003:ice</span><br></pre></td></tr></table></figure></li>
<li>然后运行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/vboxconfig</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>人在什么情况下成长最快？</title>
    <url>/2023/08/21/%E4%BA%BA%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%88%90%E9%95%BF%E6%9C%80%E5%BF%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="人在什么情况下成长最快？"><a href="#人在什么情况下成长最快？" class="headerlink" title="人在什么情况下成长最快？"></a>人在什么情况下成长最快？</h3><p>今天读到一篇知乎回答，感觉挺好的，记录一下自己的理解。<br>人成长最快的时候是: 一个场景， 三个条件。</p>
<h4 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景:"></a>一个场景:</h4><p>要牵头做事， 承担责任， 空想是不可能有什么成长的。做事也分很多种，有时候是与其他部门或者人配合做事，有时候是居中协调各个部门、有时候是牵头负责一件事。这里牵头负责一件事是最锻炼人了，成长也是最快的，牵头对成长的好处, 首先就是事情的强度和和面对事情的态度，牵头负责一件事的成败都系于你一人，你需要对这件事情负全责，无论结果怎样躲是躲不掉， 所以唯一的选择就是竭尽全力达成。<br>牵头做事另一方面的锻炼就是解决问题的能力，牵头负责一件事情, 你会发现处处是问题， 人是问题，钱是问题， 你的上面领导是问题，你的下面人是问题， 推进事情节奏是问题， 协调是问题; 出了问题那就得解决问题， 你发现你每一天都在解决问题。有的时候你得哄着团队成员，哄着领导，有时候给吓着他们，有时候还得瞒着，有时候得抓紧， 有时候得放松，有时候亢奋， 有时候失落, 还想散摊子回高老庄。总之到了最后结果也许好也许坏，但这个过程中的你就像八卦炉里的孙猴子，固然伤病一身，但本事也是结结实实地在成长了。</p>
<h4 id="三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开"><a href="#三个条件：有动力也有压力，-有支持也有劝，-有认真也有放开" class="headerlink" title="三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开"></a>三个条件：有动力也有压力， 有支持也有劝， 有认真也有放开</h4><ol>
<li><p>是有动力也有压力: 首先得有动力, 要么是自己喜欢, 自己很想, 要么是激励机制到位，你的积极性被激发了，总之首先你的得渴望做成这件事, 只有渴望成事，事情才能成， 其次必须有一定的压力， 这种压力往往来自明确的目标核对结果要求(deadline&#x2F;数据&#x2F;指标&#x2F;盈利养活团队…)，结果会呼唤效率，倒逼自己或者团队改进，只有动力没有压力人很容易进入一种什么都想做， 什么都放弃不了， 无法衡量结果好坏的泥潭，长时间使用自己喜欢过去习惯, 主观认同而非客观最高效率的方式， 直到自己的激情被耗尽。 这种情况下人是很难有快速的成长， 说白了成长是有痛感的， 没有什么事情从头到尾都是快乐的，最后还成事了，那都只有在小说里存在。 这是因为外部结果在对自己的认知、习惯、心态等进行修正和淬炼。没有压力就谈不上任何修正。 </p>
</li>
<li><p>有支持也有劝诫: 支持是必须的，物质上给资源、金钱； 精神上给鼓励肯定。环境上给决策权力。说到底做事一要有权， 二要有资源， 三要有肯定。领导只是口头上支持不给权、不给钱、那事情就很难做不如不做。还得有劝诫，自己做事很容易一根筋， 容易有盲区， 很多时候做的事问题很多， 但自己感觉不到， 这时候上面的领导能给自己提点，下面的团队成员敢提出问题这就很关键，这里面的分寸不好掌握, 需要自己慢慢体会。 另外，能成事的人一定有固执的一面， 有原则有坚持的一面， 什么地方该坚持什么地方该灵活改进需要自己去认真把握。</p>
</li>
<li><p>有认真也有放开: 就是说自己的心态要认真，想做成事， 必须很认真。 要有担当， 竭尽全力。把事情扛在肩上，放在心理，也就是得上心，得时刻绷着点。很多时候事情不是自己想做成就能做成， 很多时候甚至不是事情的问题， 只是时间还没， 到条件还没到。如果人过度焦虑， 心理负担太重就容易过度反应， 自习把自己压垮。事情还没怎样人已经扛不住了， 这种心理素质是不行的， 这时候人要懂得该放开时需放开，你控制不了的事情就别在意。无论压力多大， 人得有定力， 能冷静分析当前的局势问题到底在哪里? 做事的人最忌讳情绪大起大落。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>人生南北多歧路,君向潇湘我向秦</title>
    <url>/2023/08/25/%E4%BA%BA%E7%94%9F%E5%8D%97%E5%8C%97%E5%A4%9A%E6%AD%A7%E8%B7%AF-%E5%90%9B%E5%90%91%E6%BD%87%E6%B9%98%E6%88%91%E5%90%91%E7%A7%A6/</url>
    <content><![CDATA[<h3 id="人生南北多歧路-君向潇湘我向秦"><a href="#人生南北多歧路-君向潇湘我向秦" class="headerlink" title="人生南北多歧路,君向潇湘我向秦"></a>人生南北多歧路,君向潇湘我向秦</h3><p>这两句诗道尽初遇时的情投意合，最终却南辕北辙，遗憾分开的悲伤结局，有很多人可能并不知道这是被裁缝到一起的。<br>人生南北多歧路清代吴敬梓的《儒林外史》的一首词《秦时月》</p>
<p>《秦时月》：<br>人生南北多歧路。<br>将相神仙，也要凡人做。<br>百代兴亡朝复暮，<br>江风吹倒前朝树。<br>功名富贵无凭据。<br>费尽心情，总把流光误。<br>浊酒三杯沉醉去，<br>水流花谢知何处。</p>
<p>而后一句“君向潇湘我向秦”出自唐代诗人郑谷的《淮上与友人别》<br>《淮上与友人别》<br>郑谷<br>扬子江头杨柳春，杨花愁杀渡江人。<br>数声风笛离亭晚，君向潇湘我向秦。</p>
<p>扬子江边杨柳青青春意正浓，漫天飞扬的杨花使渡江之人非常的愁烦。<br>微风轻拂，笛声幽咽，离亭渐渐染上暮色，你就要南下潇湘我却奔向西秦。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谈日本向海洋排放核污染水</title>
    <url>/2023/08/29/%E8%B0%88%E6%97%A5%E6%9C%AC%E5%90%91%E6%B5%B7%E6%B4%8B%E6%8E%92%E6%A0%B8%E6%B1%A1%E6%9F%93%E6%B0%B4/</url>
    <content><![CDATA[<h3 id="谈日本向海洋排放核污染水"><a href="#谈日本向海洋排放核污染水" class="headerlink" title="谈日本向海洋排放核污染水"></a>谈日本向海洋排放核污染水</h3><p>8月24日13时，日本福岛第一核电站启动核污染水排海。而且是计划至少30年持续核污染水排海。</p>
<h4 id="一个极其清晰明了的逻辑"><a href="#一个极其清晰明了的逻辑" class="headerlink" title="一个极其清晰明了的逻辑"></a>一个极其清晰明了的逻辑</h4><p>如果日本的核污水像日本人说的那样是干净的，那么日本就不应该顶着全世界各国的反对非要核污染水排海。<br>如果日本人说了谎，核污染水不干净，那么日本就更加不应该冒天下之大不韪将核污染水排海。<br>因此，日本绝对是不应该将核污染水排海的。</p>
<h4 id="日本核污染水排海造成的恐慌"><a href="#日本核污染水排海造成的恐慌" class="headerlink" title="日本核污染水排海造成的恐慌"></a>日本核污染水排海造成的恐慌</h4><p>日本核污染水排海实施消息一出，国内有很多人表示很慌，以后不能去海边了，不能去吃海鲜了。也有一些人表示不慌，可能通过网上一些知识博主的宣传了解了一些太平洋洋流的知识，核污水传遍太平洋到东海，南海还需要一段时间。<br>我的观点是，没必要慌，因为慌也没有用，你慌并不能阻止日本人和世界人民有”辐“同享的无耻行径。反而像24号当天有很多抢盐的行为并不可取，让人哭笑不得。以后日本的东西就尽量避免使用、食用。<br>说道海鲜，最近海鲜因为这个事件，导致大面积降价，我觉得倒是可以抓紧去吃一吃，过段时间倒是真的谨慎吃不能吃了哟。</p>
<h4 id="日本将遭到短视的严重反噬"><a href="#日本将遭到短视的严重反噬" class="headerlink" title="日本将遭到短视的严重反噬"></a>日本将遭到短视的严重反噬</h4><p>日本核污水排海，美国带头默许，西方世界全体失声, 或者表示理解。且看他们做了什么，不要看他们说了什么。<br>日本核污水排海公布之后，欧美各个国家都纷纷发布对日本水产品限制进口政策，已经说明了问题。<br>日本即将迎来的是日本产品被贴上核污染的标签，或者至少不是第一选择产品。日本整个国家的各种产品可能和水有关系的都会面临如此的下场。日本的产品可能含有微量剧毒，可能会导致癌症风险增加。只要大家对日本产品都有这样的印象就够了，这是一个非常可怕的精神暗示。因为水太重要了，它参与着农产品，工业产品的生产。都是对日本是极具毁灭性的打击。</p>
<p>如开头的逻辑所说，无论如何日本都不应该核污水排海的错误行为。这是对自己国家人民的不负责，也是对世界人民的不负责。那么，我们能做什么呢？尽量不用日本的产品，一方面是对自身健康的考量，另一方面也是对日本这种不负责任的行为的沉默抵抗。另外，宣传更要让日本产品与核污染牢牢绑定。就像他们权衡利益用最廉价却又不最不负责任的处理核污染水一样，让他们无法拒绝地停止核污染水排海。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Abstract Factory</title>
    <url>/2023/11/20/design-pattern/abstract-factory/</url>
    <content><![CDATA[<h1 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.<br>抽象工厂是一种创建性设计模式，它允许您生成相关对象的族，而无需指定其具体类。</p>
<div align="center"> <img src="/images/abstract-factory-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent:<br>想象一下，您正在创建一个家具店模拟器。代码由表示以下内容的类组成：</p>
<p>A family of related products, say: <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>.<br>一系列相关产品，如：<code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code>。</p>
<p>Several variants of this family. For example, products <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> are available in these variants: <code>Modern</code>, <code>Victorian</code>, <code>ArtDeco</code>.<br>该系列的几个变体。例如，产品 <code>Chair</code> + <code>Sofa</code> + <code>CoffeeTable</code> 提供以下变体： <code>Modern</code> + <code>Victorian</code> + <code>ArtDeco</code> 。</p>
<div align="center"> <img src="/images/abs-fac-problem2-en.png"/>Product families and their variants.</br> 产品系列及其变体。</div>

<p>You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.<br>您需要一种方法来创建单个家具对象，以便它们与同一系列的其他对象相匹配。当客户收到不匹配的家具时，他们会非常生气。</p>
<div align="center"> <img src="/images/abstract-factory-comic-1-en.png"/>A Modern-style sofa doesn’t match Victorian-style chairs.</div>

<p>A Modern-style sofa doesn’t match Victorian-style chairs.<br>现代风格的沙发与维多利亚风格的椅子不匹配。</p>
<p>Also, you don’t want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn’t want to change the core code each time it happens.<br>此外，在向程序添加新产品或产品系列时，您不希望更改现有代码。家具供应商经常更新他们的目录，您不希望每次都更改核心代码。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the <code>Chair</code> interface; all coffee table variants can implement the <code>CoffeeTable</code> interface, and so on.<br>抽象工厂模式建议的第一件事是显式声明产品系列中每个不同产品（例如，椅子、沙发或咖啡桌）的接口。然后，您可以使产品的所有变体都遵循这些接口。例如，所有椅子变体都可以实现该 <code>Chair</code> 接口;所有咖啡桌变体都可以实现接口 <code>CoffeeTable</code> ，依此类推。</p>
<div align="center"> <img src="/images/abs-fac-solution1.png"/>All variants of the same object must be moved to a single class hierarchy.</br>必须将同一对象的所有变体移动到单个类层次结构中。</div>

<p>The next move is to declare the Abstract Factory—an interface with a list of creation methods for all products that are part of the product family (for example, <code>createChair</code>, <code>createSofa</code> and <code>createCoffeeTable</code>). These methods must return abstract product types represented by the interfaces we extracted previously: <code>Chair</code>, <code>Sofa</code>, <code>CoffeeTable</code> and so on.<br>下一步是声明抽象工厂 - 一个接口，其中包含属于产品系列的所有产品的创建方法列表（例如， <code>createChair</code> 、 <code>createSofa </code>和 <code>createCoffeeTable</code> ）。这些方法必须返回由我们之前提取的接口表示的抽象产品类型： <code>Chair</code> 、 <code>Sofa</code> 等 <code>CoffeeTable</code> 。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>Each concrete factory corresponds to a specific product variant.</br>每个混凝土工厂对应一个特定的产品变型。</div>
The _Factories_ class hierarchy
Each concrete factory corresponds to a specific product variant.
每个混凝土工厂对应一个特定的产品变型。

<p>Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the <code>AbstractFactory</code> interface. A factory is a class that returns products of a particular kind. For example, the <code>ModernFurnitureFactory</code> can only create <code>ModernChair</code>, <code>ModernSofa</code> and <code>ModernCoffeeTable</code> objects.<br>现在，产品变体怎么样？对于产品系列的每个变体，我们基于 <code>AbstractFactory</code> 接口创建一个单独的工厂类。工厂是返回特定种类产品的类。例如，只能 <code>ModernFurnitureFactory</code> 创建 <code>ModernChair</code> 和 <code>ModernSofa</code> <code>ModernCoffeeTable</code> 对象。</p>
<p>The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.<br>客户端代码必须通过工厂和产品各自的抽象接口进行处理。这样，您就可以更改传递给客户端代码的工厂类型，以及客户端代码接收的产品变型，而不会破坏实际的客户端代码。</p>
<div align="center"> <img src="/images/abs-fac-solution2.png"/>The client shouldn’t care about the concrete class of the factory it works with.</br>客户不应该关心与它合作的工厂的具体类别。</div>

<p>The client shouldn’t care about the concrete class of the factory it works with.<br>客户不应该关心与它合作的工厂的具体类别。</p>
<p>Say the client wants a factory to produce a chair. The client doesn’t have to be aware of the factory’s class, nor does it matter what kind of chair it gets. Whether it’s a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract <code>Chair</code> interface. With this approach, the only thing that the client knows about the chair is that it implements the sitOn method in some way. Also, whichever variant of the chair is returned, it’ll always match the type of sofa or coffee table produced by the same factory object.<br>假设客户想要一家工厂生产一把椅子。客户不必知道工厂的等级，也不必知道它得到什么样的椅子。无论是现代模型还是维多利亚风格的椅子，客户都必须使用抽象 <code>Chair</code> 界面以相同的方式对待所有椅子。使用这种方法，客户对椅子的唯一了解是它以某种方式实现了 <code>sitOn</code> 该方法。此外，无论返回哪种椅子变体，它都将始终与同一工厂对象生产的沙发或咖啡桌类型相匹配。</p>
<p>There’s one more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.<br>还有一件事需要澄清：如果客户端只暴露给抽象接口，那么是什么创建了实际的工厂对象？通常，应用程序在初始化阶段创建一个具体的工厂对象。在此之前，应用程序必须根据配置或环境设置选择出厂类型。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/abs-fac-structure.png"/></br></div>

<ol>
<li><p><strong>Abstract Products</strong> declare interfaces for a set of distinct but related products which make up a product family.<br>抽象产品声明了一组不同但相关的产品的接口，这些产品构成了一个产品系列。</p>
</li>
<li><p><strong>concrete Products</strong> are various implementations of abstract products, grouped by variants. Each abstract product (chair&#x2F;sofa) must be implemented in all given variants (Victorian&#x2F;Modern).<br>具体产品是抽象产品的各种实现，按变体分组。每个抽象产品（椅子&#x2F;沙发）都必须在所有给定的变体（维多利亚式&#x2F;现代式）中实现。</p>
</li>
<li><p>The <strong>Abstract Factory</strong> interface declares a set of methods for creating each of the abstract products.<br>抽象工厂接口声明了一组用于创建每个抽象产品的方法。</p>
</li>
<li><p><strong>Concrete Factories</strong> implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.<br>具体工厂实现了抽象工厂的创建方法。每个混凝土工厂对应于产品的特定变体，并且仅创建这些产品变体。</p>
</li>
<li><p><strong>Although concrete</strong> factories instantiate concrete products, signatures of their creation methods must return corresponding abstract products. This way the client code that uses a factory doesn’t get coupled to the specific variant of the product it gets from a factory. The Client can work with any concrete factory&#x2F;product variant, as long as it communicates with their objects via abstract interfaces.<br>虽然具体工厂实例化了具体产品，但其创建方法的签名必须返回相应的抽象产品。这样，使用工厂的客户端代码就不会与它从工厂获得的产品的特定变体耦合。客户端可以使用任何具体的工厂&#x2F;产品变体，只要它通过抽象接口与它们的对象进行通信即可。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the <strong>Abstract Factory</strong> pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.<br>此示例演示如何使用抽象工厂模式创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类，同时使所有创建的元素与所选操作系统保持一致。</p>
<div align="center"> <img src="/images/abs-fac-example.png"/>The cross-platform UI classes example.</br>跨平台 UI 类示例。</div>
The same UI elements in a cross-platform application are expected to behave similarly, but look a little bit different under different operating systems. Moreover, it’s your job to make sure that the UI elements match the style of the current operating system. You wouldn’t want your program to render macOS controls when it’s executed in Windows.
跨平台应用程序中的相同 UI 元素的行为应相似，但在不同的操作系统下看起来略有不同。此外，您的工作是确保 UI 元素与当前操作系统的样式相匹配。你不希望程序在 Windows 中执行时呈现 macOS 控件。

<p>The Abstract Factory interface declares a set of creation methods that the client code can use to produce different types of UI elements. Concrete factories correspond to specific operating systems and create the UI elements that match that particular OS.<br>抽象工厂接口声明了一组创建方法，客户端代码可以使用这些方法生成不同类型的 UI 元素。具体工厂对应于特定的操作系统，并创建与该特定操作系统匹配的 UI 元素。</p>
<p>It works like this: when an application launches, it checks the type of the current operating system. The app uses this information to create a factory object from a class that matches the operating system. The rest of the code uses this factory to create UI elements. This prevents the wrong elements from being created.<br>它的工作原理是这样的：当应用程序启动时，它会检查当前操作系统的类型。应用使用此信息从与操作系统匹配的类创建工厂对象。代码的其余部分使用此工厂创建 UI 元素。这样可以防止创建错误的元素。</p>
<p>With this approach, the client code doesn’t depend on concrete classes of factories and UI elements as long as it works with these objects via their abstract interfaces. This also lets the client code support other factories or UI elements that you might add in the future.<br>使用这种方法，客户端代码不依赖于工厂和 UI 元素的具体类，只要它通过其抽象接口处理这些对象即可。这也允许客户端代码支持将来可能添加的其他工厂或 UI 元素。</p>
<p>As a result, you don’t need to modify the client code each time you add a new variation of UI elements to your app. You just have to create a new factory class that produces these elements and slightly modify the app’s initialization code so it selects that class when appropriate.<br>因此，每次向应用添加新的 UI 元素变体时，都无需修改客户端代码。只需创建一个新的工厂类来生成这些元素，并稍微修改应用的初始化代码，以便它在适当的时候选择该类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The abstract factory interface declares a set of methods that</span></span><br><span class="line"><span class="comment">// return different abstract products. These products are called</span></span><br><span class="line"><span class="comment">// a family and are related by a high-level theme or concept.</span></span><br><span class="line"><span class="comment">// Products of one family are usually able to collaborate among</span></span><br><span class="line"><span class="comment">// themselves. A family of products may have several variants,</span></span><br><span class="line"><span class="comment">// but the products of one variant are incompatible with the</span></span><br><span class="line"><span class="comment">// products of another variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete factories produce a family of products that belong</span></span><br><span class="line"><span class="comment">// to a single variant. The factory guarantees that the</span></span><br><span class="line"><span class="comment">// resulting products are compatible. Signatures of the concrete</span></span><br><span class="line"><span class="comment">// factory&#x27;s methods return an abstract product, while inside</span></span><br><span class="line"><span class="comment">// the method a concrete product is instantiated.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each concrete factory has a corresponding product variant.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Each distinct product of a product family should have a base</span></span><br><span class="line"><span class="comment">// interface. All variants of the product must implement this</span></span><br><span class="line"><span class="comment">// interface.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products are created by corresponding concrete</span></span><br><span class="line"><span class="comment">// factories.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a button in macOS style.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s the base interface of another product. All products</span></span><br><span class="line"><span class="comment">// can interact with each other, but proper interaction is</span></span><br><span class="line"><span class="comment">// possible only between products of the same concrete variant.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in Windows style.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Render a checkbox in macOS style.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code works with factories and products only</span></span><br><span class="line"><span class="comment">// through abstract types: GUIFactory, Button and Checkbox. This</span></span><br><span class="line"><span class="comment">// lets you pass any factory or product subclass to the client</span></span><br><span class="line"><span class="comment">// code without breaking it.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">    <span class="keyword">private</span> field button: Button</span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">        <span class="built_in">this</span>.factory = factory</span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The application picks the factory type depending on the</span></span><br><span class="line"><span class="comment">// current configuration or environment settings and creates it</span></span><br><span class="line"><span class="comment">// at runtime (usually at the initialization stage).</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.<br>当您的代码需要处理各种相关产品系列，但您不希望它依赖于这些产品的具体类时，请使用抽象工厂 - 它们可能事先是未知的，或者您只是想允许将来的可扩展性。</strong></p>
</li>
<li><p>The Abstract Factory provides you with an interface for creating objects from each class of the product family. As long as your code creates objects via this interface, you don’t have to worry about creating the wrong variant of a product which doesn’t match the products already created by your app.<br>抽象工厂为您提供了一个接口，用于从产品系列的每个类创建对象。只要您的代码通过此接口创建对象，您就不必担心创建错误的产品变体，而该变体与您的应用已创建的产品不匹配。</p>
</li>
<li><p><strong>Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.<br>当您有一个具有一组模糊其主要职责的工厂方法的类时，请考虑实现抽象工厂。</strong></p>
</li>
<li><p>In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.<br>在一个精心设计的程序中，每个类只负责一件事。当一个类处理多种产品类型时，可能值得将其工厂方法提取到独立的工厂类或成熟的抽象工厂实现中。</p>
</li>
</ul>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Map out a matrix of distinct product types versus variants of these products.<br>绘制出不同产品类型与这些产品变体的矩阵。</p>
</li>
<li><p>Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.<br>声明所有产品类型的抽象产品接口。然后让所有具体的产品类实现这些接口。</p>
</li>
<li><p>Declare the abstract factory interface with a set of creation methods for all abstract products.<br>声明抽象工厂接口，其中包含所有抽象产品的一组创建方法。</p>
</li>
<li><p>Implement a set of concrete factory classes, one for each product variant.<br>实现一组具体的工厂类，每个产品变型对应一个。</p>
</li>
<li><p>Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.<br>在应用的某个位置创建工厂初始化代码。它应该实例化一个具体的工厂类，具体取决于应用程序配置或当前环境。将此工厂对象传递给构造产品的所有类。</p>
</li>
<li><p>Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.<br>扫描代码并找到对产品构造函数的所有直接调用。将它们替换为对工厂对象上相应创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li>You can be sure that the products you’re getting from a factory are compatible with each other.<br>您可以确定您从工厂获得的产品彼此兼容。</li>
<li>You avoid tight coupling between concrete products and client code.<br>可以避免具体产品和客户端代码之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can extract the product creation code into one place, making the code easier to support.<br>单一责任原则。您可以将产品创建代码提取到一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new variants of products without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下引入新的产品变体。</li>
</ul>
<h3 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h3><ul>
<li>The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.<br>代码可能会变得比应有的更复杂，因为许多新的接口和类与模式一起引入。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <strong>Factory Method</strong> (less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step.** Abstract Factory** specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p><strong>Abstract Factory</strong> classes are often based on a set of <strong>Factory Methods</strong>, but you can also use <strong>Prototype</strong> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><strong>Abstract Factory</strong> can serve as an alternative to <strong>Facade</strong> when you only want to hide the way the subsystem objects are created from the client code.<br>抽象工厂可以作为 Facade 的替代方法，当您只想从客户端代码中隐藏子系统对象的创建方式时。</p>
</li>
<li><p>You can use <strong>Abstract Factory</strong> along with <strong>Bridge</strong>. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations. In this case, Abstract Factory can encapsulate these relations and hide the complexity from the client code.<br>您可以将 Abstract Factory 与 Bridge 一起使用。当 Bridge 定义的某些抽象只能与特定实现一起使用时，这种配对非常有用。在这种情况下，抽象工厂可以封装这些关系，并从客户端代码中隐藏复杂性。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-示例代码"><a href="#Code-Examples-示例代码" class="headerlink" title="Code Examples 示例代码"></a>Code Examples 示例代码</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Abstract Factory interface declares a set of methods that return</span></span><br><span class="line"><span class="string">    different abstract products. These products are called a family and are</span></span><br><span class="line"><span class="string">    related by a high-level theme or concept. Products of one family are usually</span></span><br><span class="line"><span class="string">    able to collaborate among themselves. A family of products may have several</span></span><br><span class="line"><span class="string">    variants, but the products of one variant are incompatible with products of</span></span><br><span class="line"><span class="string">    another.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Concrete Factories produce a family of products that belong to a single</span></span><br><span class="line"><span class="string">    variant. The factory guarantees that resulting products are compatible. Note</span></span><br><span class="line"><span class="string">    that signatures of the Concrete Factory&#x27;s methods return an abstract</span></span><br><span class="line"><span class="string">    product, while inside the method a concrete product is instantiated.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA1()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span>(<span class="title class_ inherited__">AbstractFactory</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Factory has a corresponding product variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_a</span>(<span class="params">self</span>) -&gt; AbstractProductA:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductA2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product_b</span>(<span class="params">self</span>) -&gt; AbstractProductB:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProductB2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each distinct product of a product family should have a base interface. All</span></span><br><span class="line"><span class="string">    variants of the product must implement this interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A1.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span>(<span class="title class_ inherited__">AbstractProductA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product A2.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Here&#x27;s the the base interface of another product. All products can interact</span></span><br><span class="line"><span class="string">    with each other, but proper interaction is possible only between products of</span></span><br><span class="line"><span class="string">    the same concrete variant.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Product B is able to do its own thing...</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ...but it also can collaborate with the ProductA.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The Abstract Factory makes sure that all products it creates are of the</span></span><br><span class="line"><span class="string">        same variant and thus, compatible.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products are created by corresponding Concrete Factories.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B1.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The variant, Product B1, is only able to work correctly with the variant,</span></span><br><span class="line"><span class="string">    Product A1. Nevertheless, it accepts any instance of AbstractProductA as an</span></span><br><span class="line"><span class="string">    argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B1 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span>(<span class="title class_ inherited__">AbstractProductB</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">useful_function_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The result of the product B2.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">another_useful_function_b</span>(<span class="params">self, collaborator: AbstractProductA</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The variant, Product B2, is only able to work correctly with the</span></span><br><span class="line"><span class="string">        variant, Product A2. Nevertheless, it accepts any instance of</span></span><br><span class="line"><span class="string">        AbstractProductA as an argument.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = collaborator.useful_function_a()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The result of the B2 collaborating with the (<span class="subst">&#123;result&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">factory: AbstractFactory</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with factories and products only through abstract</span></span><br><span class="line"><span class="string">    types: AbstractFactory and AbstractProduct. This lets you pass any factory</span></span><br><span class="line"><span class="string">    or product subclass to the client code without breaking it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    product_a = factory.create_product_a()</span><br><span class="line">    product_b = factory.create_product_b()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.useful_function_b()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;product_b.another_useful_function_b(product_a)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can work with any concrete factory class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing client code with the first factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory1())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Client: Testing the same client code with the second factory type:&quot;</span>)</span><br><span class="line">    client_code(ConcreteFactory2())</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Exception-result"><a href="#Output-txt-Exception-result" class="headerlink" title="Output.txt: Exception result"></a>Output.txt: Exception result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Testing client code with the first factory type:</span><br><span class="line">The result of the product B1.</span><br><span class="line">The result of the B1 collaborating with the (The result of the product A1.)</span><br><span class="line"></span><br><span class="line">Client: Testing the same client code with the second factory type:</span><br><span class="line">The result of the product B2.</span><br><span class="line">The result of the B2 collaborating with the (The result of the product A2.)</span><br></pre></td></tr></table></figure>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><h4 id="GUI-Elements-Factory-GUI-元素工厂"><a href="#GUI-Elements-Factory-GUI-元素工厂" class="headerlink" title="GUI Elements Factory GUI 元素工厂"></a>GUI Elements Factory GUI 元素工厂</h4><p>This example illustrates how a GUI framework can organize its classes into independent libraries:<br>此示例说明了 GUI 框架如何将其类组织到独立的库中：</p>
<ol>
<li>The gui library defines interfaces for all the components.<br>该 gui 库定义了所有组件的接口。<br>It has no external dependencies.<br>它没有外部依赖关系。</li>
<li>The windows-gui library provides Windows implementation of the base GUI.<br>该 windows-gui 库提供基本 GUI 的 Windows 实现。<br>Depends on gui.<br>取决于 gui 。</li>
<li>The macos-gui library provides Mac OS implementation of the base GUI.<br>该 macos-gui 库提供基本 GUI 的 Mac OS 实现。<br>Depends on gui.<br>取决于 gui 。<br>The app is a client application that can use several implementations of the GUI framework, depending on the current environment or configuration. However, most of the app code doesn’t depend on specific types of GUI elements. All the client code works with GUI elements through abstract interfaces (traits) defined by the gui lib.<br>是一个 app 客户端应用程序，可以使用 GUI 框架的多个实现，具体取决于当前环境或配置。但是，大多数 app 代码并不依赖于特定类型的 GUI 元素。所有客户端代码都通过 gui 库定义的抽象接口（特征）与 GUI 元素一起使用。</li>
</ol>
<p>There are two approaches to implementing abstract factories in Rust:<br>在 Rust 中实现抽象工厂有两种方法：<br>1.using generics (static dispatch)<br>使用泛型（静态调度）<br>2.using dynamic allocation (dynamic dispatch)<br>使用动态分配（动态调度）</p>
<p>When you’re given a choice between static and dynamic dispatch, there is rarely a clear-cut correct answer. You’ll want to use static dispatch in your libraries and dynamic dispatch in your binaries. In a library, you want to allow your users to decide what kind of dispatch is best for them since you don’t know what their needs are. If you use dynamic dispatch, they’re forced to do the same, whereas if you use static dispatch, they can choose whether to use dynamic dispatch or not.<br>当您在静态调度和动态调度之间做出选择时，很少有明确的正确答案。您需要在库中使用静态调度，在二进制文件中使用动态调度。在图书馆中，您希望允许用户决定哪种调度最适合他们，因为您不知道他们的需求是什么。如果您使用动态调度，他们将被迫执行相同的操作，而如果您使用静态调度，则可以选择是否使用动态调度。</p>
<h4 id="gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品"><a href="#gui-Abstract-Factory-and-Abstract-Products-gui：抽象工厂和抽象产品" class="headerlink" title="gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品"></a>gui: Abstract Factory and Abstract Products gui：抽象工厂和抽象产品</h4><ul>
<li>gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">press</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">switch</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using generics.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactory</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>: Button;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">C</span>: Checkbox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::B;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Abstract Factory defined using Box pointer.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GuiFactoryDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_checkbox</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Checkbox&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>macos-gui: One family of products<br>file: macos-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
<li>windows-gui: Another family of products<br>file: windows-gui&#x2F;lib.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> button;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> checkbox;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> factory;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Static-dispatch-静态调度"><a href="#Static-dispatch-静态调度" class="headerlink" title="Static dispatch 静态调度"></a>Static dispatch 静态调度</h4><p>Here, the abstract factory is implemented via generics which lets the compiler create a code that does NOT require dynamic dispatch in runtime.<br>在这里，抽象工厂是通过泛型实现的，它允许编译器创建不需要在运行时动态调度的代码。</p>
<ul>
<li>app: Client code with static dispatch<br>file: app&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> windows &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(WindowsFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">render</span>(MacFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renders GUI. Factory object must be passed as a parameter to such the</span></span><br><span class="line"><span class="comment">// generic function with factory invocation to utilize static dispatch.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: <span class="keyword">impl</span> <span class="title class_">GuiFactory</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> gui::&#123;Button, Checkbox&#125;;</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Dynamic-dispatch-动态调度"><a href="#Dynamic-dispatch-动态调度" class="headerlink" title="Dynamic dispatch 动态调度"></a>Dynamic dispatch 动态调度</h4><p>If a concrete type of abstract factory is not known at the compilation time, then is should be implemented using Box pointers.<br>如果在编译时不知道抽象工厂的具体类型，则应使用 Box 指针实现。</p>
<ul>
<li>app-dyn: Client code with dynamic dispatch<br>file: app-dyn&#x2F;main.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> render::render;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"><span class="keyword">use</span> macos_gui::factory::MacFactory;</span><br><span class="line"><span class="keyword">use</span> windows_gui::factory::WindowsFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">windows</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a factory object in runtime depending on unpredictable input.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">factory</span>: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic = <span class="keyword">if</span> windows &#123;</span><br><span class="line">        &amp;WindowsFactory</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &amp;MacFactory</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory invocation can be inlined right here.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    button.<span class="title function_ invoke__">press</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory object can be passed to a function as a parameter.</span></span><br><span class="line">    <span class="title function_ invoke__">render</span>(factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
file: app-dyn&#x2F;render.rs<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! The code demonstrates that it doesn&#x27;t depend on a concrete</span></span><br><span class="line"><span class="comment">//! factory implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gui::GuiFactoryDynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Renders GUI.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">render</span>(factory: &amp;<span class="keyword">dyn</span> GuiFactoryDynamic) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button1</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button2</span> = factory.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox1</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">checkbox2</span> = factory.<span class="title function_ invoke__">create_checkbox</span>();</span><br><span class="line"></span><br><span class="line">    button1.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    button2.<span class="title function_ invoke__">press</span>();</span><br><span class="line">    checkbox1.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">    checkbox2.<span class="title function_ invoke__">switch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows button has pressed</span><br><span class="line">Windows button has pressed</span><br><span class="line">Windows checkbox has switched</span><br><span class="line">Windows checkbox has switched</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>classification of patterns</title>
    <url>/2023/11/15/design-pattern/classification-of-patterns/</url>
    <content><![CDATA[<h1 id="Classification-of-patterns"><a href="#Classification-of-patterns" class="headerlink" title="Classification of patterns"></a>Classification of patterns</h1><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p>Design patterns differ by their complexity, level of detail and scale of applicability to the entire system being designed. I like the analogy to road construction: you can make an intersection safer by either installing some traffic lights or building an entire multi-level interchange with underground passages for pedestrians.</p>
<p>设计模式的复杂性、详细程度和对整个设计的系统的适用范围各不相同。我喜欢与道路建设的类比：你可以通过安装一些交通信号灯或建造一个完整的多层立交桥和地下通道来使十字路口更安全。</p>
<p>The most basic and low-level patterns are often called idioms. They usually apply only to a single programming language.</p>
<p>最基本和最底层的模式通常被称为成语。它们通常仅适用于一种编程语言。</p>
<p>The most universal and high-level patterns are architectural patterns. Developers can implement these patterns in virtually any language. Unlike other patterns, they can be used to design the architecture of an entire application.</p>
<p>最通用和高级的模式是体系结构模式。开发人员几乎可以用任何语言实现这些模式。与其他模式不同，它们可用于设计整个应用程序的体系结构。</p>
<p>In addition, all patterns can be categorized by their intent, or purpose. This book covers three main groups of patterns:</p>
<p>此外，所有模式都可以按其意图或目的进行分类。本书涵盖三大类模式：</p>
<ul>
<li><p>Creational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.<br>创建模式提供了对象创建机制，可提高现有代码的灵活性和重用性。</p>
</li>
<li><p>Structural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.<br>结构模式解释了如何将对象和类组合成更大的结构，同时保持这些结构的灵活性和效率。</p>
</li>
<li><p>Behavioral patterns take care of effective communication and the assignment of responsibilities between objects.<br>行为模式负责对象之间的有效沟通和责任分配。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Factory Method</title>
    <url>/2023/11/16/design-pattern/factory-method/</url>
    <content><![CDATA[<h1 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h1><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>Also known as: Virtual Constructor<br>也称为： Virtual Constructor</p>
<h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p>Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.</p>
<p>工厂方法是一种创建设计模式，它提供了一个接口，用于在超类中创建对象，但允许子类更改将要创建的对象的类型。<br><img src="/images/factory-method-en.png"></p>
<p>Factory Method pattern</p>
<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the Truck class.<br>假设您正在创建一个物流管理应用程序。应用的第一个版本只能处理卡车运输，因此大部分代码都位于 Truck 类中。</p>
<p>After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.</p>
<p>一段时间后，您的应用程序变得非常受欢迎。每天，您都会收到数十个来自海运公司的请求，要求将海运物流纳入应用程序。</p>
<div align="center"> <img src="/images/problem1-en.png"/> Adding a new class to the program isn’t that simple if the rest of the code is already coupled to existing classes.</br>如果代码的其余部分已经耦合到现有类，则向程序添加新类并不那么简单。 </div>

<p>Great news, right? But how about the code? At present, most of your code is coupled to the <code>Truck</code> class. Adding <code>Ships</code> into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.<br>好消息，对吧？但是代码呢？目前，您的大部分代码都与类 Truck 耦合。添加到 Ships 应用程序中需要对整个代码库进行更改。此外，如果您以后决定向应用程序添加另一种类型的交通工具，您可能需要再次进行所有这些更改。</p>
<p>As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects.<br>结果，你最终会得到非常讨厌的代码，其中充斥着条件，这些条件根据运输对象的类别来切换应用程序的行为。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method. Don’t worry: the objects are still created via the new operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products.<br>工厂方法模式建议将直接对象构造调用（使用运 new 算符）替换为对特殊工厂方法的调用。不用担心：对象仍然是通过运算符 new 创建的，但它是从工厂方法中调用的。工厂方法返回的对象通常称为产品。</p>
<div align="center"> <img src="/images/solution1.png"/> Subclasses can alter the class of objects being returned by the factory method.</br>子类可以更改工厂方法返回的对象的类。</div>

<p>At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.</p>
<p>乍一看，这种变化可能看起来毫无意义：我们只是将构造函数调用从程序的一部分移动到另一部分。但是，请考虑以下情况：现在您可以在子类中重写工厂方法，并更改该方法创建的产品类。</p>
<p>There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.</p>
<p>但是有一个轻微的限制：只有当这些产品具有共同的基类或接口时，子类才能返回不同类型的产品。此外，基类中的工厂方法应将其返回类型声明为此接口。</p>
<p>The structure of the products hierarchy<br>All products must follow the same interface.<br>所有产品必须遵循相同的界面。</p>
<div align="center"> <img src="/images/solution1.png"/>All products must follow the same interface.</br>所有产品必须遵循相同的界面。</div>

<p>For example, both <code>Truck</code> and <code>Ship</code> classes should implement the <code>Transport</code> interface, which declares a method called <code>deliver</code>. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the <code>RoadLogistics</code> class returns truck objects, whereas the factory method in the <code>SeaLogistics</code> class returns ships.<br>例如，和类都应该 <code>Truck</code> 实现接口 <code>Transport</code> ，该接口声明了一个名为 <code>deliver</code> . <code>Ship</code> 每个类别都以不同的方式实现这种方法：卡车通过陆路运送货物，船舶通过海上运送货物。 <code>RoadLogistics</code> 类中的 <code>factory</code> 方法返回 <code>truck</code> 对象，而 <code>SeaLogistics</code> 类中的 <code>factory</code> 方法返回 <code>ships</code>。</p>
<div align="center"> <img src="/images/solution2.png"/>As long as all product classes implement a common interface, you can pass their objects to the client code without breaking it.</br>只要所有产品类都实现一个通用接口，就可以将其对象传递给客户端代码，而不会中断它。</div>

<p>The code that uses the factory method (often called the client code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract <code>Transport</code>. The client knows that all transport objects are supposed to have the <code>deliver</code> method, but exactly how it works isn’t important to the client.<br>使用工厂方法的代码（通常称为客户端代码）看不到各个子类返回的实际产品之间的差异。客户将所有产品视为抽象 <code>Transport</code> 产品。客户端知道所有传输对象都应该具有该 <code>deliver</code> 方法，但其工作方式对客户端来说并不重要。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/structure.png"/></div>

<h4 id="1-Prodcut"><a href="#1-Prodcut" class="headerlink" title="1.Prodcut"></a>1.Prodcut</h4><p>The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.</p>
<p>Product 声明接口，该接口对于创建者及其子类可以生成的所有对象都是通用的。</p>
<h4 id="2-Concrete-Products"><a href="#2-Concrete-Products" class="headerlink" title="2.Concrete Products"></a>2.Concrete Products</h4><p>Concrete Products are different implementations of the product interface.<br>具体产品是产品接口的不同实现。</p>
<h4 id="3-Creator"><a href="#3-Creator" class="headerlink" title="3.Creator"></a>3.Creator</h4><p>The Creator class declares the factory method that returns new product objects. It’s important that the return type of this method matches the product interface.</p>
<p>Creator 类声明返回新产品对象的工厂方法。此方法的返回类型必须与产品接口匹配，这一点很重要。</p>
<p>You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.</p>
<p>您可以声明工厂方法，以 abstract 强制所有子类实现其自己的方法版本。或者，基工厂方法可以返回一些默认产品类型。</p>
<p>Note, despite its name, product creation is not the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.</p>
<p>请注意，尽管它的名字，产品创建并不是创建者的主要责任。通常，creator 类已经有一些与产品相关的核心业务逻辑。工厂方法有助于将此逻辑与具体的产品类分离。打个比方：一家大型软件开发公司可以有一个程序员培训部门。然而，整个公司的主要职能仍然是编写代码，而不是培养程序员。</p>
<h4 id="4-Concrete-Creators"><a href="#4-Concrete-Creators" class="headerlink" title="4.Concrete Creators"></a>4.Concrete Creators</h4><p>Concrete Creators override the base factory method so it returns a different type of product.<br>Concrete Creators 会重写基本工厂方法，因此它会返回不同类型的产品。</p>
<p>Note that the factory method doesn’t have to create new instances all the time. It can also return existing objects from a cache, an object pool, or another source.<br>请注意，工厂方法不必一直创建新实例。它还可以从缓存、对象池或其他源返回现有对象。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.</p>
<p>此示例演示如何使用 Factory 方法创建跨平台 UI 元素，而无需将客户端代码耦合到具体的 UI 类。</p>
<div align="center"> <img src="/images/example.png"/>The cross-platform dialog example.</br>跨平台对话框示例。</div>

<p>The base <code>Dialog</code> class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.<br>基 <code>Dialog</code> 类使用不同的 UI 元素来呈现其窗口。在各种操作系统下，这些元素可能看起来略有不同，但它们的行为仍应一致。Windows 中的按钮仍然是 Linux 中的按钮。</p>
<p>When the factory method comes into play, you don’t need to rewrite the logic of the <code>Dialog</code> class for each operating system. If we declare a factory method that produces buttons inside the base <code>Dialog</code> class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.<br>当工厂方法发挥作用时，无需为每个操作系统重写 <code>Dialog</code> 类的逻辑。如果我们声明一个在基 <code>Dialog</code> 类中生成按钮的工厂方法，我们稍后可以创建一个子类，该子类从工厂方法返回 Windows 样式的按钮。然后，该子类从基类继承大部分代码，但是，由于工厂方法，可以在屏幕上呈现具有 Windows 外观的按钮。</p>
<p>For this pattern to work, the base <code>Dialog</code> class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within <code>Dialog</code> remains functional, whichever type of buttons it works with.<br>要使此模式起作用，基类必须使用抽象按钮：所有具体按钮都遵循的基 <code>Dialog</code> 类或接口。这样，无论使用哪种类型的按钮，其中 <code>Dialog</code> 的代码都可以正常工作。</p>
<p>Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the <code>Dialog</code>, you get closer to the Abstract Factory pattern. Fear not, we’ll talk about this pattern later.<br>当然，您也可以将此方法应用于其他 UI 元素。但是，随着您添加到 <code>Dialog</code> 的每个新工厂方法，您都更接近抽象工厂模式。不要害怕，我们稍后会讨论这种模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The creator class declares the factory method that must</span></span><br><span class="line"><span class="comment">// return an object of a product class. The creator&#x27;s subclasses</span></span><br><span class="line"><span class="comment">// usually provide the implementation of this method.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    <span class="comment">// The creator may also provide some default implementation</span></span><br><span class="line">    <span class="comment">// of the factory method.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that, despite its name, the creator&#x27;s primary</span></span><br><span class="line">    <span class="comment">// responsibility isn&#x27;t creating products. It usually</span></span><br><span class="line">    <span class="comment">// contains some core business logic that relies on product</span></span><br><span class="line">    <span class="comment">// objects returned by the factory method. Subclasses can</span></span><br><span class="line">    <span class="comment">// indirectly change that business logic by overriding the</span></span><br><span class="line">    <span class="comment">// factory method and returning a different type of product</span></span><br><span class="line">    <span class="comment">// from it.</span></span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Call the factory method to create a product object.</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">        <span class="comment">// Now use the product.</span></span><br><span class="line">        okButton.onClick(closeDialog)</span><br><span class="line">        okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete creators override the factory method to change the</span></span><br><span class="line"><span class="comment">// resulting product&#x27;s type.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The product interface declares the operations that all</span></span><br><span class="line"><span class="comment">// concrete products must implement.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete products provide various implementations of the</span></span><br><span class="line"><span class="comment">// product interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Render a button in Windows style.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a native OS click event.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// Return an HTML representation of a button.</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// Bind a web browser click event.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field dialog: Dialog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The application picks a creator&#x27;s type depending on the</span></span><br><span class="line">    <span class="comment">// current configuration or environment settings.</span></span><br><span class="line">    method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error! Unknown operating system.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The client code works with an instance of a concrete</span></span><br><span class="line">    <span class="comment">// creator, albeit through its base interface. As long as</span></span><br><span class="line">    <span class="comment">// the client keeps working with the creator via the base</span></span><br><span class="line">    <span class="comment">// interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.initialize()</span><br><span class="line">        dialog.render()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><p><strong>Use the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with.</strong><br><strong>当您事先不知道代码应使用的对象的确切类型和依赖项时，请使用工厂方法。</strong></p>
<p>The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code.</p>
<p>Factory 方法将产品构造代码与实际使用产品的代码分开。因此，独立于代码的其余部分扩展产品构造代码更容易。</p>
<p>For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it.</p>
<p>例如，要向应用添加新的产品类型，只需创建一个新的创建者子类并重写其中的工厂方法。</p>
<p><strong>Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.</strong><br><strong>如果要为库或框架的用户提供扩展其内部组件的方法，请使用工厂方法。</strong></p>
<p>Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?<br>继承可能是扩展库或框架默认行为的最简单方法。但是，框架如何识别应该使用您的子类而不是标准组件呢？</p>
<p>The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.<br>解决方案是将跨框架构造组件的代码简化为单个工厂方法，并允许任何人在扩展组件本身之外重写此方法。</p>
<p>Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard <code>Button</code> class with a glorious <code>RoundButton</code> subclass. But now you need to tell the main <code>UIFramework</code> class to use the new button subclass instead of a default one.<br>让我们看看这将如何工作。想象一下，你使用开源 UI 框架编写一个应用。你的应用应该有圆形按钮，但框架只提供方形按钮。你用一个光荣的 <code>RoundButton</code> 子类扩展了标准 Button 类。但是现在你需要告诉主 <code>UIFramework</code> 类使用新的按钮子类，而不是默认的子类。</p>
<p>To achieve this, you create a subclass <code>UIWithRoundButtons</code> from a base framework class and override its createButton method. While this method returns <code>Button</code> objects in the base class, you make your subclass return <code>RoundButton</code> objects. Now use the <code>UIWithRoundButtons</code> class instead of <code>UIFramework</code>. And that’s about it!<br>为此，可以从基框架类创建一个子类 <code>UIWithRoundButtons</code> 并重写其 createButton 方法。当此方法返回基类中的对象时，您可以使子类返回 Button <code>RoundButton</code> 对象。现在使用类 <code>UIWithRoundButtons</code> 而不是 <code>UIFramework</code> .仅此而已！</p>
<p><strong>Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.</strong><br><strong>如果要通过重用现有对象而不是每次都重新生成它们来节省系统资源，请使用工厂方法。</strong></p>
<p>You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.<br>在处理大型资源密集型对象（如数据库连接、文件系统和网络资源）时，您经常会遇到这种需求。</p>
<p>Let’s think about what has to be done to reuse an existing object:<br>让我们考虑一下重用现有对象必须做些什么：</p>
<ul>
<li>First, you need to create some storage to keep track of all of the created objects.<br>首先，您需要创建一些存储来跟踪所有创建的对象。</li>
<li>When someone requests an object, the program should look for a free object inside that pool.<br>当有人请求某个对象时，程序应该在该池中查找一个空闲对象。</li>
<li>… and then return it to the client code.<br>…，然后将其返回给客户端代码。</li>
<li>If there are no free objects, the program should create a new one (and add it to the pool).<br>如果没有空闲对象，程序应创建一个新对象（并将其添加到池中）。</li>
</ul>
<p>That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code.<br>这是一大堆代码！而且必须将它们全部放在一个地方，这样您就不会用重复的代码污染程序。</p>
<p>Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return <strong>new objects</strong> by definition. It can’t return existing instances.<br>放置此代码的最明显和最方便的位置可能是我们尝试重用其对象的类的构造函数。但是，根据定义，构造函数必须始终返回<strong>new objects</strong>。它无法返回现有实例。</p>
<p>Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method.<br>因此，您需要有一个能够创建新对象以及重用现有对象的常规方法。这听起来很像工厂方法。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ul>
<li><p>Make all products follow the same interface. This interface should declare methods that make sense in every product.<br>使所有产品都遵循相同的界面。此接口应声明在每个产品中都有意义的方法。</p>
</li>
<li><p>Add an empty factory method inside the creator class. The return type of the method should match the common product interface.<br>在 creator 类中添加一个空的工厂方法。方法的返回类型应与通用产品接口匹配。</p>
</li>
<li><p>In the creator’s code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method.<br>在创建者的代码中，找到对产品构造函数的所有引用。将它们逐个替换为对工厂方法的调用，同时将产品创建代码提取到工厂方法中。</p>
</li>
</ul>
<p>You might need to add a temporary parameter to the factory method to control the type of returned product.<br>您可能需要向工厂方法添加临时参数，以控制返回产品的类型。</p>
<p>At this point, the code of the factory method may look pretty ugly. It may have a large <code>switch</code> statement that picks which product class to instantiate. But don’t worry, we’ll fix it soon enough.<br>在这一点上，工厂方法的代码可能看起来很丑陋。它可能有一个大 <code>switch</code> 语句，用于选择要实例化的产品类。但别担心，我们会尽快修复它。</p>
<ul>
<li><p>Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.<br>现在，为 factory 方法中列出的每种类型的产品创建一组创建者子类。重写子类中的工厂方法，并从基方法中提取适当的构造代码位。</p>
</li>
<li><p>If there are too many product types and it doesn’t make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses.<br>如果产品类型太多，并且为所有产品类型创建子类没有意义，则可以在子类中重用基类中的控制参数。</p>
</li>
</ul>
<p>For instance, imagine that you have the following hierarchy of classes: the base <code>Mail</code> class with a couple of subclasses: <code>AirMail</code> and <code>GroundMail</code>; the <code>Transport</code> classes are <code>Plane</code>, <code>Truck</code> and <code>Train</code>. While the <code>AirMail</code> class only uses <code>Plane</code> objects, <code>GroundMail</code> may work with both <code>Truck</code> and <code>Train</code> objects. You can create a new subclass (say <code>TrainMail</code>) to handle both cases, but there’s another option. The client code can pass an argument to the factory method of the <code>GroundMail</code> class to control which product it wants to receive.<br>例如，假设您有以下类层次结构：具有几个子类的基 <code>Mail</code> 类： <code>AirMail</code> 和 <code>GroundMail</code> ; <code>Transport</code> 这些类是 <code>Plane</code>,  <code>Truck</code>和 <code>Train</code> 。虽然该 <code>AirMail</code> 类仅使用 <code>Plane</code> 对象， <code>GroundMail</code> 但可以同时 <code>Truck</code> 使用和 <code>Train</code> 对象。您可以创建一个新的子类（例如 <code>TrainMail</code> ）来处理这两种情况，但还有另一种选择。客户端代码可以将参数传递给 <code>GroundMail</code> 类的工厂方法，以控制它要接收的产品。</p>
<ul>
<li>If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there’s something left, you can make it a default behavior of the method.<br>如果在所有提取之后，基本工厂方法已变为空，则可以将其抽象化。如果还剩下一些东西，可以将其设置为方法的默认行为。</li>
</ul>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h4 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h4><ul>
<li>You avoid tight coupling between the creator and the concrete products.<br>您可以避免创建者和具体产品之间的紧密耦合。</li>
<li>Single Responsibility Principle. You can move the product creation code into one place in the program, making the code easier to support.<br>单一责任原则。您可以将产品创建代码移动到程序中的一个位置，使代码更易于支持。</li>
<li>Open&#x2F;Closed Principle. You can introduce new types of products into the program without breaking existing client code.<br>开&#x2F;闭原理。您可以在不破坏现有客户端代码的情况下将新类型的产品引入程序。</li>
</ul>
<h4 id="Cons-缺点"><a href="#Cons-缺点" class="headerlink" title="Cons 缺点"></a>Cons 缺点</h4><p>The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you’re introducing the pattern into an existing hierarchy of creator classes.<br>代码可能会变得更加复杂，因为您需要引入许多新的子类来实现该模式。最好的情况是将模式引入到创建者类的现有层次结构中。</p>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p>Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p>You can use Factory Method along with Iterator to let collection subclasses return different types of iterators that are compatible with the collections.<br>可以将工厂方法与迭代器一起使用，让集合子类返回与集合兼容的不同类型的迭代器。</p>
</li>
<li><p>Prototype isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. Factory Method is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method.<br>工厂方法是模板方法的专业化。同时，工厂方法可以作为大型模板方法中的一个步骤。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><ul>
<li><p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Creator class declares the factory method that is supposed to return an</span></span><br><span class="line"><span class="string">    object of a Product class. The Creator&#x27;s subclasses usually provide the</span></span><br><span class="line"><span class="string">    implementation of this method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Note that the Creator may also provide some default implementation of</span></span><br><span class="line"><span class="string">        the factory method.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Also note that, despite its name, the Creator&#x27;s primary responsibility</span></span><br><span class="line"><span class="string">        is not creating products. Usually, it contains some core business logic</span></span><br><span class="line"><span class="string">        that relies on Product objects, returned by the factory method.</span></span><br><span class="line"><span class="string">        Subclasses can indirectly change that business logic by overriding the</span></span><br><span class="line"><span class="string">        factory method and returning a different type of product from it.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call the factory method to create a Product object.</span></span><br><span class="line">        product = self.factory_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now, use the product.</span></span><br><span class="line">        result = <span class="string">f&quot;Creator: The same creator&#x27;s code has just worked with <span class="subst">&#123;product.operation()&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Creators override the factory method in order to change the resulting</span></span><br><span class="line"><span class="string">product&#x27;s type.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator1</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Note that the signature of the method still uses the abstract product type,</span></span><br><span class="line"><span class="string">    even though the concrete product is actually returned from the method. This</span></span><br><span class="line"><span class="string">    way the Creator can stay independent of concrete product classes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreator2</span>(<span class="title class_ inherited__">Creator</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">factory_method</span>(<span class="params">self</span>) -&gt; Product:</span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Product interface declares the operations that all concrete products</span></span><br><span class="line"><span class="string">    must implement.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Concrete Products provide various implementations of the Product interface.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct1&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct2&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_code</span>(<span class="params">creator: Creator</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code works with an instance of a concrete creator, albeit through</span></span><br><span class="line"><span class="string">    its base interface. As long as the client keeps working with the creator via</span></span><br><span class="line"><span class="string">    the base interface, you can pass it any creator&#x27;s subclass.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span></span><br><span class="line">          <span class="string">f&quot;<span class="subst">&#123;creator.some_operation()&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator1.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator1())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;App: Launched with the ConcreteCreator2.&quot;</span>)</span><br><span class="line">    client_code(ConcreteCreator2())</span><br></pre></td></tr></table></figure>
<p><strong>Output.txt: Execution result</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">App: Launched <span class="keyword">with</span> the ConcreteCreator1.</span><br><span class="line">Client: I<span class="string">&#x27;m not aware of the creator&#x27;</span>s <span class="keyword">class</span>, but it still works.</span><br><span class="line">Creator: The same creato<span class="string">r&#x27;s code has just worked with &#123;Result of the ConcreteProduct1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">App: Launched with the ConcreteCreator2.</span></span><br><span class="line"><span class="string">Client: I&#x27;</span>m <span class="keyword">not</span> aware of the creato<span class="string">r&#x27;s class, but it still works.</span></span><br><span class="line"><span class="string">Creator: The same creator&#x27;</span>s code has just worked <span class="keyword">with</span> &#123;Result of the ConcreteProduct2&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Rust<br><strong>gui.rs:Prodcut &amp; Creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Dialog has a factory method `create_button`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It creates different buttons depending on a factory implementation.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line">    <span class="comment">/// The factory method. It must be overridden with a concrete implementation.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">button</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">create_button</span>();</span><br><span class="line">        button.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">refresh</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dialog - Refresh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>html_gui.rs: Concrete creator</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">HtmlButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&lt;button&gt;Test Button&lt;/button&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Button says - &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">HtmlDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">HtmlDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates an HTML button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HtmlButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>windows_gui.rs: Another concrete creator</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::&#123;Button, Dialog&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Button</span> <span class="keyword">for</span> <span class="title class_">WindowsButton</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Drawing a Windows button&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">on_click</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_click</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Click! Hello, Windows!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WindowsDialog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dialog</span> <span class="keyword">for</span> <span class="title class_">WindowsDialog</span> &#123;</span><br><span class="line">    <span class="comment">/// Creates a Windows button.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_button</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Button&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(WindowsButton)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>init.rs: Initialization code</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::gui::Dialog;</span><br><span class="line"><span class="keyword">use</span> crate::html_gui::HtmlDialog;</span><br><span class="line"><span class="keyword">use</span> crate::windows_gui::WindowsDialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">initialize</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">dyn</span> Dialog &#123;</span><br><span class="line">    <span class="comment">// The dialog type is selected depending on the environment settings or configuration.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cfg!</span>(windows) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- Windows detected, creating Windows GUI --&quot;</span>);</span><br><span class="line">        &amp;WindowsDialog</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;-- No OS detected, creating the HTML GUI --&quot;</span>);</span><br><span class="line">        &amp;HtmlDialog</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.rs: Client code main.rs</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> gui;</span><br><span class="line"><span class="keyword">mod</span> html_gui;</span><br><span class="line"><span class="keyword">mod</span> init;</span><br><span class="line"><span class="keyword">mod</span> windows_gui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> init::initialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// The rest of the code doesn&#x27;t depend on specific dialog types, because</span></span><br><span class="line">    <span class="comment">// it works with all dialog objects via the abstract `Dialog` trait</span></span><br><span class="line">    <span class="comment">// which is defined in the `gui` module.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dialog</span> = <span class="title function_ invoke__">initialize</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">render</span>();</span><br><span class="line">    dialog.<span class="title function_ invoke__">refresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Output</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;Test Button&lt;/button&gt;</span><br><span class="line">Click! Button says - <span class="symbol">&#x27;Hello</span> World!&#x27;</span><br><span class="line">Dialog - Refresh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>History of patterns</title>
    <url>/2023/11/14/design-pattern/history-of-patterns/</url>
    <content><![CDATA[<h1 id="History-of-patterns"><a href="#History-of-patterns" class="headerlink" title="History of patterns"></a>History of patterns</h1><h1 id="模式的历史"><a href="#模式的历史" class="headerlink" title="模式的历史"></a>模式的历史</h1><p>Who invented patterns? That’s a good, but not a very accurate, question. Design patterns aren’t obscure, sophisticated concepts—quite the opposite. Patterns are typical solutions to common problems in object-oriented design. When a solution gets repeated over and over in various projects, someone eventually puts a name to it and describes the solution in detail. That’s basically how a pattern gets discovered.<br>谁发明了模式？这是一个很好的问题，但不是很准确。设计模式不是晦涩难懂的复杂概念，恰恰相反。模式是面向对象设计中常见问题的典型解决方案。当一个解决方案在各种项目中一遍又一遍地重复时，最终会有人给它起一个名字并详细描述该解决方案。这基本上就是发现模式的方式。</p>
<p>The concept of patterns was first described by Christopher Alexander in A Pattern Language: Towns, Buildings, Construction. The book describes a “language” for designing the urban environment. The units of this language are patterns. They may describe how high windows should be, how many levels a building should have, how large green areas in a neighborhood are supposed to be, and so on.<br>模式的概念最早由克里斯托弗·亚历山大（Christopher Alexander）在《模式语言：城镇、建筑、建筑》中描述。该书描述了一种设计城市环境的“语言”。这种语言的单位是模式。它们可能会描述窗户应该有多高，建筑物应该有多少层，社区中的绿地应该有多大，等等。</p>
<p>The idea was picked up by four authors: Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm. In 1994, they published Design Patterns: Elements of Reusable Object-Oriented Software, in which they applied the concept of design patterns to programming. The book featured 23 patterns solving various problems of object-oriented design and became a best-seller very quickly. Due to its lengthy name, people started to call it “the book by the gang of four” which was soon shortened to simply “the GoF book”.<br>这个想法被四位作者采纳：Erich Gamma、John Vlissides、Ralph Johnson 和 Richard Helm。1994 年，他们出版了《设计模式：可重用面向对象软件的元素》，其中他们将设计模式的概念应用于编程。该书收录了 23 种模式，解决了面向对象设计的各种问题，并很快成为畅销书。由于名字很长，人们开始称它为“四人团的书”，很快就简称为《The GoF book》。</p>
<p>Since then, dozens of other object-oriented patterns have been discovered. The “pattern approach” became very popular in other programming fields, so lots of other patterns now exist outside of object-oriented design as well.<br>从那时起，已经发现了许多其他面向对象的模式。“模式方法”在其他编程领域变得非常流行，因此在面向对象设计之外也存在许多其他模式。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Builder</title>
    <url>/2023/11/21/design-pattern/builder/</url>
    <content><![CDATA[<h1 id="Builder-建造者"><a href="#Builder-建造者" class="headerlink" title="Builder 建造者"></a>Builder 建造者</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Builder</strong> is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.<br><strong>Builder</strong> 是一种创建性设计模式，可让您逐步构建复杂的对象。该模式允许您使用相同的构造代码生成对象的不同类型和表示形式。</p>
<div align="center"> <img src="/images/builder-en.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.<br>想象一个复杂的对象，需要费力地逐步初始化许多字段和嵌套对象。这种初始化代码通常隐藏在具有大量参数的可怕构造函数中。或者更糟糕的是：分散在客户端代码中。</p>
<div align="center"> <img src="/images/builder-problem1.png"/>You might make the program too complex by creating a subclass for every possible configuration of an object.</通过为对象的每个可能配置创建一个子类，可能会使程序过于复杂。></div>

<p>For example, let’s think about how to create a <code>House</code> object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?<br>例如，让我们考虑如何创建一个 <code>House</code> 对象。要建造一个简单的房子，你需要建造四面墙和一个地板，安装一扇门，安装一对窗户，并建造一个屋顶。但是，如果您想要一个更大、更明亮的房子，有后院和其他好东西（如供暖系统、管道和电线）怎么办？</p>
<p>The simplest solution is to extend the base <code>House</code> class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.<br>最简单的解决方案是扩展基 <code>House</code> 类并创建一组子类以涵盖参数的所有组合。但最终你会得到相当多的子类。任何新参数（例如门廊样式）都需要进一步扩展此层次结构。</p>
<p>There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base <code>House</code> class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.<br>还有另一种方法不涉及育种子类。您可以直接在基 <code>House</code> 类中创建一个巨大的构造函数，其中包含控制 house 对象的所有可能参数。虽然这种方法确实消除了对子类的需求，但它产生了另一个问题。</p>
<div align="center"> <img src="/images/builder-problem2.png"/>The constructor with lots of parameters has its downside: not all the parameters are needed at all times.</br>具有大量参数的构造函数有其缺点：并非所有参数都是必需的。</div>

<p>In most cases most of the parameters will be unused, making <strong>the constructor calls pretty ugly</strong>. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.<br>在大多数情况下，大多数参数将处于未使用状态，这使得构造函数调用非常丑陋。例如，只有一小部分房屋有游泳池，因此与游泳池相关的参数十有八九将毫无用处。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called builders.<br>Builder 模式建议您将对象构造代码从其自己的类中提取出来，并将其移动到称为生成器的单独对象中。</p>
<div align="center"> <img src="/images/builder-solution1.png"/>The Builder pattern lets you construct complex objects step by step. The Builder doesn’t allow other objects to access the product while it’s being built.</br>Builder 模式允许您逐步构建复杂的对象。Builder 不允许其他对象在构建产品时访问产品。</div>

<p>The pattern organizes object construction into a set of steps (<code>buildWalls</code>, <code>buildDoor</code>, etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.<br>该模式将对象构造组织为一组步骤（<code>buildWalls</code>, <code>buildDoor</code> 等）。要创建对象，请在生成器对象上执行一系列这些步骤。重要的是，您不需要调用所有步骤。您只能调用生成对象的特定配置所需的那些步骤。</p>
<p>Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.<br>当您需要构建产品的各种表示形式时，某些构造步骤可能需要不同的实现。例如，小屋的墙壁可以用木头建造，但城堡的墙壁必须用石头建造。</p>
<p>In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.<br>在这种情况下，您可以创建多个不同的生成器类，这些类以不同的方式实现同一组生成步骤。然后，您可以在构造过程中使用这些构建器（即，对构建步骤的一组有序调用）来生成不同类型的对象。</p>
<div align="center"> <img src="/images/builder-comic-1-en.png"/>Different builders execute the same task in various ways.</br>不同的构建器以不同的方式执行相同的任务。</div>

<p>For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.<br>例如，想象一个建筑商用木头和玻璃建造所有东西，第二个建筑商用石头和铁建造所有东西，第三个建筑商使用黄金和钻石建造所有东西。通过调用相同的步骤，您可以从第一个建筑商那里获得普通房屋，从第二个建造者那里获得一座小城堡，从第三个建造者那里获得一座宫殿。但是，仅当调用生成步骤的客户端代码能够使用通用接口与构建器交互时，这才有效。</p>
<h2 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h2><p>You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.<br>您可以更进一步，将对用于将产品构造到称为 director 的单独类的构建器步骤的一系列调用中提取出来。director 类定义执行生成步骤的顺序，而生成器则提供这些步骤的实现。</p>
<div align="center"> <img src="/images/builder-comic-2-en.png"/>The director knows which building steps to execute to get a working product.</br>主管知道要执行哪些构建步骤才能获得工作产品。</div>

<p>Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.<br>在您的课程中开设director类并不是绝对必要的。您始终可以直接从客户端代码按特定顺序调用生成步骤。但是，director 类可能是放置各种构造例程的好地方，以便您可以在程序中重用它们。</p>
<p>In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.<br>此外，director 类在客户端代码中完全隐藏了产品构造的细节。客户端只需将构建器与控制器关联，与控制器一起启动构造，并从构建器获取结果。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/builder-structure.png"/></div>

<ol>
<li><p>The <strong>Builder</strong> interface declares product construction steps that are common to all types of builders.<br>Builder 界面声明了所有类型的构建器通用的产品构建步</p>
</li>
<li><p><strong>Concrete</strong> Builders provide different implementations of the construction steps. Concrete builders may produce products that don’t follow the common interface.<br>混凝土建造者提供施工步骤的不同实施。混凝土建筑商可能会生产不遵循通用接口的产品。</p>
</li>
<li><p><strong>Products</strong> are resulting objects. Products constructed by different builders don’t have to belong to the same class hierarchy or interface.<br>产品是结果对象。由不同构建器构建的产品不必属于相同的类层次结构或接口。</p>
</li>
<li><p>The <strong>Director</strong> class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.<br>Director 类定义调用构造步骤的顺序，以便您可以创建和重用产品的特定配置。</p>
</li>
<li><p>The <strong>Client</strong> must associate one of the builder objects with the director. Usually, it’s done just once, via parameters of the director’s constructor. Then the director uses that builder object for all further construction. However, there’s an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.<br>客户端必须将其中一个构建器对象与控制器相关联。通常，它只通过控制器构造函数的参数完成一次。然后，director 使用该构建器对象进行所有进一步的构造。但是，当客户端将生成器对象传递给控制器的生产方法时，还有另一种方法。在这种情况下，每次与director一起制作内容时，都可以使用不同的构建器。</p>
</li>
</ol>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>This example of the <strong>Builder</strong> pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them.<br>此 Builder 模式示例说明了如何在构建不同类型的产品（如汽车）时重用相同的对象构造代码，并为它们创建相应的手册。</p>
<div align="center"> <img src="/images/builder-example-en.png"/>The example of step-by-step construction of cars and the user guides that fit those car models.</br>汽车的分步构造示例以及适合这些汽车型号的用户指南。</div>

<p>A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the <code>Car</code> class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.<br>汽车是一个复杂的物体，可以用一百种不同的方式建造。我们没有使用庞大的构造函数来膨胀类 <code>Car</code> ，而是将汽车装配代码提取到一个单独的 car builder 类中。此类具有一组用于配置汽车各个部分的方法。</p>
<p>If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.<br>如果客户端代码需要组装一个特殊的、微调的汽车模型，它可以直接与构建器一起使用。另一方面，客户端可以将程序集委托给 director 类，该类知道如何使用构建器来构造几种最流行的汽车模型。</p>
<p>You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That’s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn’t the same as building a car, and that’s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.<br>您可能会感到震惊，但每辆车都需要一本手册（说真的，谁会读它们？手册描述了汽车的每个功能，因此手册中的细节因不同车型而异。这就是为什么在真实汽车及其各自的手册中重复使用现有的制造过程是有意义的。当然，构建手册与构建汽车不同，这就是为什么我们必须提供另一个专门编写手册的构建者类。该类实现了与其汽车制造同级相同的构建方法，但不是制作汽车零件，而是描述它们。通过将这些构建器传递给同一个 director 对象，我们可以构造汽车或手册。</p>
<p>The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can’t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.<br>最后一部分是获取生成的对象。金属汽车和纸质手册虽然相关，但仍然是非常不同的东西。如果不将控制器与具体的产品类耦合，我们就无法在控制器中放置获取结果的方法。因此，我们从执行工作的建筑商那里获得施工结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the Builder pattern makes sense only when your products</span></span><br><span class="line"><span class="comment">// are quite complex and require extensive configuration. The</span></span><br><span class="line"><span class="comment">// following two products are related, although they don&#x27;t have</span></span><br><span class="line"><span class="comment">// a common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line">    <span class="comment">// A car can have a GPS, trip computer and some number of</span></span><br><span class="line">    <span class="comment">// seats. Different models of cars (sports car, SUV,</span></span><br><span class="line">    <span class="comment">// cabriolet) might have different features installed or</span></span><br><span class="line">    <span class="comment">// enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">    <span class="comment">// Each car should have a user manual that corresponds to</span></span><br><span class="line">    <span class="comment">// the car&#x27;s configuration and describes all its features.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The builder interface specifies methods for creating the</span></span><br><span class="line"><span class="comment">// different parts of the product objects.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The concrete builder classes follow the builder interface and</span></span><br><span class="line"><span class="comment">// provide specific implementations of the building steps. Your</span></span><br><span class="line"><span class="comment">// program may have several variations of builders, each</span></span><br><span class="line"><span class="comment">// implemented differently.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field car:Car</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A fresh builder instance should contain a blank product</span></span><br><span class="line">    <span class="comment">// object which it uses in further assembly.</span></span><br><span class="line">    constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The reset method clears the object being built.</span></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All production steps work with the same product instance.</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Set the number of seats in the car.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a given engine.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a trip computer.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Install a global positioning system.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concrete builders are supposed to provide their own</span></span><br><span class="line">    <span class="comment">// methods for retrieving results. That&#x27;s because various</span></span><br><span class="line">    <span class="comment">// types of builders may create entirely different products</span></span><br><span class="line">    <span class="comment">// that don&#x27;t all follow the same interface. Therefore such</span></span><br><span class="line">    <span class="comment">// methods can&#x27;t be declared in the builder interface (at</span></span><br><span class="line">    <span class="comment">// least not in a statically-typed programming language).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Usually, after returning the end result to the client, a</span></span><br><span class="line">    <span class="comment">// builder instance is expected to be ready to start</span></span><br><span class="line">    <span class="comment">// producing another product. That&#x27;s why it&#x27;s a usual</span></span><br><span class="line">    <span class="comment">// practice to call the reset method at the end of the</span></span><br><span class="line">    <span class="comment">// `getProduct` method body. However, this behavior isn&#x27;t</span></span><br><span class="line">    <span class="comment">// mandatory, and you can make your builder wait for an</span></span><br><span class="line">    <span class="comment">// explicit reset call from the client code before disposing</span></span><br><span class="line">    <span class="comment">// of the previous result.</span></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">        <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlike other creational patterns, builder lets you construct</span></span><br><span class="line"><span class="comment">// products that don&#x27;t follow the common interface.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field manual:Manual</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Document car seat features.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add engine instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add trip computer instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">        <span class="comment">// Add GPS instructions.</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">        <span class="comment">// Return the manual and reset the builder.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The director is only responsible for executing the building</span></span><br><span class="line"><span class="comment">// steps in a particular sequence. It&#x27;s helpful when producing</span></span><br><span class="line"><span class="comment">// products according to a specific order or configuration.</span></span><br><span class="line"><span class="comment">// Strictly speaking, the director class is optional, since the</span></span><br><span class="line"><span class="comment">// client can control builders directly.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">    <span class="comment">// The director works with any builder instance that the</span></span><br><span class="line">    <span class="comment">// client code passes to it. This way, the client code may</span></span><br><span class="line">    <span class="comment">// alter the final type of the newly assembled product.</span></span><br><span class="line">    <span class="comment">// The director can construct several product variations</span></span><br><span class="line">    <span class="comment">// using the same building steps.</span></span><br><span class="line">    method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        builder.reset()</span><br><span class="line">        builder.setSeats(<span class="number">2</span>)</span><br><span class="line">        builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">        builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">        builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code creates a builder object, passes it to the</span></span><br><span class="line"><span class="comment">// director and then initiates the construction process. The end</span></span><br><span class="line"><span class="comment">// result is retrieved from the builder object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The final product is often retrieved from a builder</span></span><br><span class="line">        <span class="comment">// object since the director isn&#x27;t aware of and not</span></span><br><span class="line">        <span class="comment">// dependent on concrete builders and products.</span></span><br><span class="line">        <span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure>

<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Builder pattern to get rid of a “telescoping constructor”. 使用 Builder 模式来摆脱“伸缩构造函数”。</strong></p>
</li>
<li><p>Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters.<br>假设您有一个包含十个可选参数的构造函数。召唤这样的野兽是很不方便的;因此，重载构造函数，并使用较少的参数创建多个较短的版本。这些构造函数仍然引用主构造函数，将一些默认值传递到任何省略的参数中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    Pizza(<span class="type">int</span> size) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese) &#123; ... &#125;</span><br><span class="line">    Pizza(<span class="type">int</span> size, <span class="type">boolean</span> cheese, <span class="type">boolean</span> pepperoni) &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>Creating such a monster is only possible in languages that support method overloading, such as C# or Java.只有在支持方法重载的语言（如 C# 或 Java）中才能创建这样的怪物。</p>
<p>The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore.<br>Builder 模式允许您逐步构建对象，仅使用您真正需要的那些步骤。实现该模式后，您不必再将数十个参数塞入构造函数中。</p>
<ul>
<li><p><strong>Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).当您希望代码能够创建某些产品（例如，石头和木屋）的不同表示形式时，请使用 Builder 模式。</strong></p>
</li>
<li><p>The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.<br>当构建产品的各种表示形式涉及仅在细节上有所不同的类似步骤时，可以应用构建器模式。</p>
</li>
</ul>
<p>The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.<br>基础构建器界面定义了所有可能的构建步骤，具体构建器实现这些步骤来构建产品的特定表示。同时，director类指导施工顺序。</p>
<ul>
<li><p><strong>Use the Builder to construct Composite trees or other complex objects.使用构建器构建复合树或其他复杂对象。</strong></p>
</li>
<li><p>The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.<br>Builder 模式允许您逐步构建产品。您可以在不破坏最终产品的情况下延迟某些步骤的执行。您甚至可以递归调用步骤，这在需要构建对象树时会派上用场。</p>
</li>
</ul>
<p>A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.<br>构建器在运行构造步骤时不会暴露未完成的产品。这样可以防止客户端代码提取不完整的结果。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won’t be able to proceed with implementing the pattern.<br>确保您可以清楚地定义用于构建所有可用产品表示的常见构造步骤。否则，您将无法继续实现该模式。</p>
</li>
<li><p>Declare these steps in the base builder interface.<br>在基础构建器界面中声明这些步骤。</p>
</li>
<li><p>Create a concrete builder class for each of the product representations and implement their construction steps.<br>为每个产品表示形式创建一个具体的构建器类，并实现其构造步骤。</p>
</li>
</ol>
<p>Don’t forget about implementing a method for fetching the result of the construction. The reason why this method can’t be declared inside the builder interface is that various builders may construct products that don’t have a common interface. Therefore, you don’t know what would be the return type for such a method. However, if you’re dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.<br>不要忘记实现一个获取构造结果的方法。无法在生成器接口中声明此方法的原因是，各种生成器可能会构造没有通用接口的产品。因此，您不知道这种方法的返回类型是什么。但是，如果您要处理来自单个层次结构的产品，则可以安全地将提取方法添加到基本界面。</p>
<ol start="4">
<li><p>Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.<br>考虑创建一个director类。它可以封装使用相同的构建器对象构建产品的各种方法。</p>
</li>
<li><p>The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director’s class constructor. The director uses the builder object in all further construction. There’s an alternative approach, where the builder is passed to a specific product construction method of the director.<br>客户端代码创建生成器和控制器对象。在构造开始之前，客户端必须将生成器对象传递给控制器。通常，客户端仅通过 director 类构造函数的参数执行此操作一次。director 在所有进一步的构造中使用 builder 对象。还有另一种方法，将构建器传递给主管的特定产品构建方法。</p>
</li>
<li><p>The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.<br>只有当所有产品都遵循相同的接口时，才能直接从director那里获得施工结果。否则，客户端应从构建器获取结果。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><h3 id="Pros-优点"><a href="#Pros-优点" class="headerlink" title="Pros 优点"></a>Pros 优点</h3><ul>
<li><p>You can construct objects step-by-step, defer construction steps or run steps recursively.<br>您可以逐步构造对象、延迟构造步骤或递归运行步骤。</p>
</li>
<li><p>You can reuse the same construction code when building various representations of products.<br>在构建产品的各种表示形式时，您可以重复使用相同的构造代码。</p>
</li>
<li><p>Single Responsibility Principle. You can isolate complex construction code from the business logic of the product.<br>单一责任原则。您可以将复杂的构造代码与产品的业务逻辑隔离开来。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>The overall complexity of the code increases since the pattern requires creating multiple new classes.<br>代码的整体复杂性增加，因为该模式需要创建多个新类。</li>
</ul>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using **Factory Method **(less complicated and more customizable via subclasses) and evolve toward <strong>Abstract Factory</strong>, <strong>Prototype</strong>, or <strong>Builder</strong> (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><strong>Builder</strong> focuses on constructing complex objects step by step. <strong>Abstract Factory</strong> specializes in creating families of related objects. <strong>Abstract Factory</strong> returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.<br>Builder 专注于逐步构建复杂的对象。Abstract Factory专门用于创建相关对象的族。Abstract Factory 会立即返回产品，而 Builder 允许您在获取产品之前运行一些额外的构造步骤。</p>
</li>
<li><p>You can use <strong>Builder</strong> when creating complex <strong>Composite</strong> trees because you can program its construction steps to work recursively.<br>在创建复杂的复合树时，可以使用 Builder，因为您可以对其构造步骤进行编程以递归方式工作。</p>
</li>
<li><p>You can combine <strong>Builder</strong> with <strong>Bridge</strong>: the director class plays the role of the abstraction, while different builders act as implementations.<br>您可以将 Builder 与 Bridge 结合使用：director 类扮演抽象的角色，而不同的构建器充当实现。</p>
</li>
<li><p><strong>Abstract Factories</strong>, <strong>Builders</strong> and <strong>Prototypes</strong> can all be implemented as <strong>Singletons</strong>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="python-Conceptual-Example-概念示例"><a href="#python-Conceptual-Example-概念示例" class="headerlink" title="python Conceptual Example 概念示例"></a>python Conceptual Example 概念示例</h3><p>This example illustrates the structure of the Builder design pattern. It focuses on answering these questions:<br>此示例说明了 Builder 设计模式的结构。它侧重于回答以下问题：</p>
<ul>
<li>What classes does it consist of?<br>它由哪些类组成？</li>
<li>What roles do these classes play?<br>这些课程扮演什么角色？</li>
<li>In what way the elements of the pattern are related?<br>模式的元素以何种方式相关？</li>
</ul>
<p>main.py: 概念示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Builder interface specifies methods for creating the different parts of</span></span><br><span class="line"><span class="string">    the Product objects.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span>(<span class="title class_ inherited__">Builder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Concrete Builder classes follow the Builder interface and provide</span></span><br><span class="line"><span class="string">    specific implementations of the building steps. Your program may have</span></span><br><span class="line"><span class="string">    several variations of Builders, implemented differently.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A fresh builder instance should contain a blank product object, which is</span></span><br><span class="line"><span class="string">        used in further assembly.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product = Product1()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">self</span>) -&gt; Product1:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Concrete Builders are supposed to provide their own methods for</span></span><br><span class="line"><span class="string">        retrieving results. That&#x27;s because various types of builders may create</span></span><br><span class="line"><span class="string">        entirely different products that don&#x27;t follow the same interface.</span></span><br><span class="line"><span class="string">        Therefore, such methods cannot be declared in the base Builder interface</span></span><br><span class="line"><span class="string">        (at least in a statically typed programming language).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Usually, after returning the end result to the client, a builder</span></span><br><span class="line"><span class="string">        instance is expected to be ready to start producing another product.</span></span><br><span class="line"><span class="string">        That&#x27;s why it&#x27;s a usual practice to call the reset method at the end of</span></span><br><span class="line"><span class="string">        the `getProduct` method body. However, this behavior is not mandatory,</span></span><br><span class="line"><span class="string">        and you can make your builders wait for an explicit reset call from the</span></span><br><span class="line"><span class="string">        client code before disposing of the previous result.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        product = self._product</span><br><span class="line">        self.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_a</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartA1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_b</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartB1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_part_c</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._product.add(<span class="string">&quot;PartC1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    It makes sense to use the Builder pattern only when your products are quite</span></span><br><span class="line"><span class="string">    complex and require extensive configuration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Unlike in other creational patterns, different concrete builders can produce</span></span><br><span class="line"><span class="string">    unrelated products. In other words, results of various builders may not</span></span><br><span class="line"><span class="string">    always follow the same interface.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, part: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.parts.append(part)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_parts</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Product parts: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(self.parts)&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director is only responsible for executing the building steps in a</span></span><br><span class="line"><span class="string">    particular sequence. It is helpful when producing products according to a</span></span><br><span class="line"><span class="string">    specific order or configuration. Strictly speaking, the Director class is</span></span><br><span class="line"><span class="string">    optional, since the client can control builders directly.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._builder = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self</span>) -&gt; Builder:</span><br><span class="line">        <span class="keyword">return</span> self._builder</span><br><span class="line"></span><br><span class="line"><span class="meta">    @builder.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">builder</span>(<span class="params">self, builder: Builder</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The Director works with any builder instance that the client code passes</span></span><br><span class="line"><span class="string">        to it. This way, the client code may alter the final type of the newly</span></span><br><span class="line"><span class="string">        assembled product.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Director can construct several product variations using the same</span></span><br><span class="line"><span class="string">    building steps.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_minimal_viable_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_full_featured_product</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.builder.produce_part_a()</span><br><span class="line">        self.builder.produce_part_b()</span><br><span class="line">        self.builder.produce_part_c()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code creates a builder object, passes it to the director and then</span></span><br><span class="line"><span class="string">    initiates the construction process. The end result is retrieved from the</span></span><br><span class="line"><span class="string">    builder object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    director = Director()</span><br><span class="line">    builder = ConcreteBuilder1()</span><br><span class="line">    director.builder = builder</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard basic product: &quot;</span>)</span><br><span class="line">    director.build_minimal_viable_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Standard full featured product: &quot;</span>)</span><br><span class="line">    director.build_full_featured_product()</span><br><span class="line">    builder.product.list_parts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remember, the Builder pattern can be used without a Director class.</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Custom product: &quot;</span>)</span><br><span class="line">    builder.produce_part_a()</span><br><span class="line">    builder.produce_part_b()</span><br><span class="line">    builder.product.list_parts()</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Standard basic product:</span><br><span class="line">Product parts: PartA1</span><br><span class="line"></span><br><span class="line">Standard full featured product:</span><br><span class="line">Product parts: PartA1, PartB1, PartC1</span><br><span class="line"></span><br><span class="line">Custom product:</span><br><span class="line">Product parts: PartA1, PartB1</span><br></pre></td></tr></table></figure>

<h3 id="Rust-示例：Car-car-manual-builders"><a href="#Rust-示例：Car-car-manual-builders" class="headerlink" title="Rust 示例：Car &amp; car manual builders"></a>Rust 示例：Car &amp; car manual builders</h3><p>This slightly synthetic example illustrates how you can use the <code>Builder</code> pattern to construct totally different products using the same building process. For example, the trait Builder declares steps for assembling a car. However, depending on the builder implementation, a constructed object can be something different, for example, a car manual. The resulting manual will contain instructions from each building step, making it accurate and up-to-date.<br>这个略微合成的示例说明了如何使用 Builder 模式，通过相同的构建过程来构建完全不同的产品。例如，该特征 <code>Builder</code> 声明了组装汽车的步骤。但是，根据构建器实现的不同，构造的对象可以是不同的对象，例如汽车手册。由此产生的手册将包含每个构建步骤的说明，使其准确和最新。</p>
<p>The <strong>Builder</strong> design pattern is not the same as the <strong>Fluent Interface</strong> idiom (that relies on method chaining), although Rust developers sometimes use those terms interchangeably.<br>Builder 设计模式与 Fluent Interface 习惯用语（依赖于方法链）不同，尽管 Rust 开发人员有时会互换使用这些术语。</p>
<ol>
<li><p>Fluent Interface is a way to chain methods for constructing or modifying an object using the following approach:<br>Fluent Interface 是一种使用以下方法链接用于构造或修改对象的方法的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">car</span> = Car::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">places</span>(<span class="number">5</span>).<span class="title function_ invoke__">gas</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>It’s pretty elegant way to construct an object. Still, such a code may not be an instance of the Builder pattern.<br>这是构造对象的非常优雅的方式。不过，这样的代码可能不是 Builder 模式的实例。</p>
</li>
<li><p>While the <strong>Builder</strong> pattern also suggests constructing object step by step, it also lets you build different types of products using the same construction process.<br>虽然 <strong>Builder</strong> 模式还建议逐步构建对象，但它也允许您使用相同的构建过程构建不同类型的产品。</p>
</li>
</ol>
<h3 id="builders-Builders-builders"><a href="#builders-Builders-builders" class="headerlink" title="builders: Builders builders"></a>builders: Builders builders</h3><h4 id="builders-mod-rs"><a href="#builders-mod-rs" class="headerlink" title="builders&#x2F;mod.rs"></a>builders&#x2F;mod.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> car_manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builder defines how to assemble a car.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::OutputType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::CarBuilder;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car_manual::CarManualBuilder;</span><br></pre></td></tr></table></figure>
<h4 id="builders-car-rs"><a href="#builders-car-rs" class="headerlink" title="builders&#x2F;car.rs"></a>builders&#x2F;car.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Car,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT_FUEL: <span class="type">f64</span> = <span class="number">5f64</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Car;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Car &#123;</span><br><span class="line">        Car::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">            DEFAULT_FUEL,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="builders-car-manual-rs"><a href="#builders-car-manual-rs" class="headerlink" title="builders&#x2F;car_manual.rs"></a>builders&#x2F;car_manual.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cars::Manual,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    car_type: <span class="type">Option</span>&lt;CarType&gt;,</span><br><span class="line">    engine: <span class="type">Option</span>&lt;Engine&gt;,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    seats: <span class="type">Option</span>&lt;<span class="type">u16</span>&gt;,</span><br><span class="line">    transmission: <span class="type">Option</span>&lt;Transmission&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Builds a car manual instead of an actual car.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> <span class="keyword">for</span> <span class="title class_">CarManualBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">OutputType</span> = Manual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_car_type</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, car_type: CarType) &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type = <span class="title function_ invoke__">Some</span>(car_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_engine</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, engine: Engine) &#123;</span><br><span class="line">        <span class="keyword">self</span>.engine = <span class="title function_ invoke__">Some</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_gsp_navigator</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gps_navigator: GpsNavigator) &#123;</span><br><span class="line">        <span class="keyword">self</span>.gps_navigator = <span class="title function_ invoke__">Some</span>(gps_navigator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_seats</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, seats: <span class="type">u16</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats = <span class="title function_ invoke__">Some</span>(seats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_transmission</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, transmission: Transmission) &#123;</span><br><span class="line">        <span class="keyword">self</span>.transmission = <span class="title function_ invoke__">Some</span>(transmission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Manual &#123;</span><br><span class="line">        Manual::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            <span class="keyword">self</span>.car_type.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a car type&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.seats.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set a number of seats&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set an engine configuration&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.transmission.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please, set up transmission&quot;</span>),</span><br><span class="line">            <span class="keyword">self</span>.gps_navigator,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cars-Products"><a href="#cars-Products" class="headerlink" title="cars: Products"></a>cars: Products</h4><h5 id="cars-mod-rs"><a href="#cars-mod-rs" class="headerlink" title="cars&#x2F;mod.rs"></a>cars&#x2F;mod.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> car;</span><br><span class="line"><span class="keyword">mod</span> manual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> car::Car;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> manual::Manual;</span><br></pre></td></tr></table></figure>

<h5 id="cars-car-rs"><a href="#cars-car-rs" class="headerlink" title="cars&#x2F;car.rs"></a>cars&#x2F;car.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    fuel: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">        fuel: <span class="type">f64</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">            fuel,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">car_type</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> CarType &#123;</span><br><span class="line">        <span class="keyword">self</span>.car_type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fuel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_fuel</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fuel: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fuel = fuel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">seats</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.seats</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">engine</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Engine &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.engine</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transmission</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;Transmission &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.transmission</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">gps_navigator</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">Option</span>&lt;GpsNavigator&gt; &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.gps_navigator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="cars-manual-rs"><a href="#cars-manual-rs" class="headerlink" title="cars&#x2F;manual.rs"></a>cars&#x2F;manual.rs</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    car_type: CarType,</span><br><span class="line">    seats: <span class="type">u16</span>,</span><br><span class="line">    engine: Engine,</span><br><span class="line">    transmission: Transmission,</span><br><span class="line">    gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        car_type: CarType,</span><br><span class="line">        seats: <span class="type">u16</span>,</span><br><span class="line">        engine: Engine,</span><br><span class="line">        transmission: Transmission,</span><br><span class="line">        gps_navigator: <span class="type">Option</span>&lt;GpsNavigator&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            car_type,</span><br><span class="line">            seats,</span><br><span class="line">            engine,</span><br><span class="line">            transmission,</span><br><span class="line">            gps_navigator,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Type of car: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.car_type)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Count of seats: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.seats)?;</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;Engine: volume - &#123;&#125;; mileage - &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">volume</span>(),</span><br><span class="line">            <span class="keyword">self</span>.engine.<span class="title function_ invoke__">mileage</span>()</span><br><span class="line">        )?;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">&quot;Transmission: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.transmission)?;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.gps_navigator &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: Functional&quot;</span>)?,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">writeln!</span>(f, <span class="string">&quot;GPS Navigator: N/A&quot;</span>)?,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="components-rs-Product-components"><a href="#components-rs-Product-components" class="headerlink" title="components.rs: Product components"></a>components.rs: Product components</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">CarType</span> &#123;</span><br><span class="line">    CityCar,</span><br><span class="line">    SportsCar,</span><br><span class="line">    Suv,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Transmission</span> &#123;</span><br><span class="line">    SingleSpeed,</span><br><span class="line">    Manual,</span><br><span class="line">    Automatic,</span><br><span class="line">    SemiAutomatic,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    volume: <span class="type">f64</span>,</span><br><span class="line">    mileage: <span class="type">f64</span>,</span><br><span class="line">    started: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(volume: <span class="type">f64</span>, mileage: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            volume,</span><br><span class="line">            mileage,</span><br><span class="line">            started: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">on</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">off</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">started</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.started</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">volume</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.volume</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mileage</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.mileage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">go</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, mileage: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">started</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.mileage += mileage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Cannot go(), you must start engine first!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    route: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GpsNavigator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">from_route</span>(</span><br><span class="line">            <span class="string">&quot;221b, Baker Street, London  to Scotland Yard, 8-10 Broadway, London&quot;</span>.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_route</span>(route: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; route &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">route</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.route</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="director-rs-Directors"><a href="#director-rs-Directors" class="headerlink" title="director.rs: Directors"></a>director.rs: Directors</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    builders::Builder,</span><br><span class="line">    components::&#123;CarType, Engine, GpsNavigator, Transmission&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Director knows how to build a car.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// However, a builder can build a car manual instead of an actual car,</span></span><br><span class="line"><span class="comment">/// everything depends on the concrete builder.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Director</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_sports_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::SportsCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::SemiAutomatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_city_car</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::CityCar);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">2</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">1.2</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Automatic);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">construct_suv</span>(builder: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">set_car_type</span>(CarType::Suv);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_seats</span>(<span class="number">4</span>);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_engine</span>(Engine::<span class="title function_ invoke__">new</span>(<span class="number">2.5</span>, <span class="number">0.0</span>));</span><br><span class="line">        builder.<span class="title function_ invoke__">set_transmission</span>(Transmission::Manual);</span><br><span class="line">        builder.<span class="title function_ invoke__">set_gsp_navigator</span>(GpsNavigator::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main-rs-Client-code"><a href="#main-rs-Client-code" class="headerlink" title="main.rs: Client code"></a>main.rs: Client code</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> builders;</span><br><span class="line"><span class="keyword">mod</span> cars;</span><br><span class="line"><span class="keyword">mod</span> components;</span><br><span class="line"><span class="keyword">mod</span> director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> builders::&#123;Builder, CarBuilder, CarManualBuilder&#125;;</span><br><span class="line"><span class="keyword">use</span> cars::&#123;Car, Manual&#125;;</span><br><span class="line"><span class="keyword">use</span> director::Director;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">car_builder</span> = CarBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director gets the concrete builder object from the client</span></span><br><span class="line">    <span class="comment">// (application code). That&#x27;s because application knows better which</span></span><br><span class="line">    <span class="comment">// builder to use to get a specific product.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_sports_car</span>(&amp;<span class="keyword">mut</span> car_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final product is often retrieved from a builder object, since</span></span><br><span class="line">    <span class="comment">// Director is not aware and not dependent on concrete builders and</span></span><br><span class="line">    <span class="comment">// products.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">car</span>: Car = car_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car built: &#123;:?&#125;\n&quot;</span>, car.<span class="title function_ invoke__">car_type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">manual_builder</span> = CarManualBuilder::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Director may know several building recipes.</span></span><br><span class="line">    Director::<span class="title function_ invoke__">construct_city_car</span>(&amp;<span class="keyword">mut</span> manual_builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The final car manual.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manual</span>: Manual = manual_builder.<span class="title function_ invoke__">build</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Car manual built:\n&#123;&#125;&quot;</span>, manual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Car built: SportsCar</span><br><span class="line"></span><br><span class="line">Car manual built:</span><br><span class="line">Type of car: CityCar</span><br><span class="line">Count of seats: 2</span><br><span class="line">Engine: volume - 1.2; mileage - 0</span><br><span class="line">Transmission: Automatic</span><br><span class="line">GPS Navigator: Functional</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Prototype</title>
    <url>/2023/11/22/design-pattern/prototype/</url>
    <content><![CDATA[<h1 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype 原型"></a>Prototype 原型</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Prototype</strong> is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.<br>原型是一种创建性设计模式，它允许您复制现有对象，而不会使代码依赖于它们的类。</p>
<div align="center"> <img src="/images/prototype-head.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.<br>假设你有一个对象，并且你想创建一个精确的副本。你会怎么做？首先，您必须创建同一类的新对象。然后，您必须遍历原始对象的所有字段，并将其值复制到新对象。</p>
<p>Nice! But there’s a catch. Not all objects can be copied that way because some of the object’s fields may be private and not visible from outside of the object itself.<br>好！但有一个问题。并非所有对象都可以以这种方式复制，因为对象的某些字段可能是私有的，并且从对象本身外部不可见。</p>
<div align="center"> <img src="/images/prototype-comic-1-en.png"/>Copying an object “from the outside” isn’t always possible.</br>“从外部”复制对象并不总是可行的。</div>
There’s one more problem with the direct approach. Since you have to know the object’s class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn’t scare you, there’s another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.
直接方法还有一个问题。由于您必须知道对象的类才能创建副本，因此您的代码将依赖于该类。如果额外的依赖关系没有吓到你，还有另一个问题。有时，您只知道对象所遵循的接口，而不知道其具体类，例如，当方法中的参数接受某个接口所遵循的任何对象时。

<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single <code>clone</code> method.<br>Prototype 模式将克隆过程委托给正在克隆的实际对象。该模式为支持克隆的所有对象声明一个通用接口。此接口允许您克隆对象，而无需将代码耦合到该对象的类。通常，这样的接口只包含一个 <code>clone</code> 方法。</p>
<p>The implementation of the clone method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.<br>该 <code>clone</code> 方法的实现在所有类中都非常相似。该方法创建当前类的对象，并将旧对象的所有字段值转移到新对象中。您甚至可以复制私有字段，因为大多数编程语言允许对象访问属于同一类的其他对象的私有字段。</p>
<p>An object that supports cloning is called a prototype. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.<br>支持克隆的对象称为原型。当您的对象具有数十个字段和数百种可能的配置时，克隆它们可以作为子类化的替代方法。</p>
<div align="center"> <img src="/images/prototype-comic-2-en.png"/>Pre-built prototypes can be an alternative to subclassing.</br>预构建的原型可以替代子类化。</div>
Here’s how it works: you create a set of objects, configured in various ways. When you need an object like the one you’ve configured, you just clone a prototype instead of constructing a new object from scratch.
它是这样工作的：创建一组对象，以各种方式进行配置。当您需要像您配置的对象一样的对象时，您只需克隆一个原型，而不是从头开始构建一个新对象。

<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don’t participate in any actual production, playing a passive role instead.<br>在现实生活中，原型用于在开始批量生产产品之前进行各种测试。然而，在这种情况下，原型不参与任何实际生产，而是扮演被动角色。</p>
<div align="center"> <img src="/images/prototype-comic-3-en.png"/>The division of a cell.</br>细胞的分裂。</div>
Since industrial prototypes don’t really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.
由于工业原型并不能真正复制自己，因此与该模式更接近的类比是有丝分裂细胞分裂的过程（生物学，还记得吗？有丝分裂后，形成一对相同的细胞。原始单元充当原型，并在创建副本中发挥积极作用。

<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><h3 id="Basic-implementation-基本实现"><a href="#Basic-implementation-基本实现" class="headerlink" title="Basic implementation 基本实现"></a>Basic implementation 基本实现</h3><div align="center"> <img src="/images/prototyp-structure.png"/></div>

<ol>
<li><p>The <strong>Prototype</strong> interface declares the cloning methods. In most cases, it’s a single clone method.<br>Prototype 接口声明克隆方法。在大多数情况下，它是一种单一 clone 方法。</p>
</li>
<li><p>The <code>Concrete Prototype</code> class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.<br>Concrete Prototype 类实现克隆方法。除了将原始对象的数据复制到克隆中外，该方法还可以处理克隆过程中与克隆链接对象、解开递归依赖关系等相关的一些边缘情况。</p>
</li>
<li><p>The <code>Client</code> can produce a copy of any object that follows the prototype interface.<br>客户端可以生成遵循原型接口的任何对象的副本。</p>
</li>
</ol>
<h3 id="Prototype-registry-implementation-原型注册表实现"><a href="#Prototype-registry-implementation-原型注册表实现" class="headerlink" title="Prototype registry implementation 原型注册表实现"></a>Prototype registry implementation 原型注册表实现</h3><div align="center"> <img src="/images/structure-prototype-cache.png"/></div>
1. The `Prototype Registry` provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name → prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.
Prototype Registry 提供了一种访问常用原型的简单方法。它存储一组准备复制的预构建对象。最简单的原型注册表是 name → prototype 哈希映射。但是，如果您需要比简单名称更好的搜索条件，则可以构建更可靠的注册表版本。

<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the Prototype pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.<br>在此示例中，Prototype 模式允许您生成几何对象的精确副本，而无需将代码耦合到其类。</p>
<div align="center"> <img src="/images/prototype-example1.png"/>Cloning a set of objects that belong to a class hierarchy.</br>克隆属于类层次结构的一组对象。</div>

<p>All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent’s cloning method before copying its own field values to the resulting object.<br>所有形状类都遵循相同的接口，该接口提供克隆方法。子类可以在将其自己的字段值复制到生成的对象之前调用父类的克隆方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base prototype.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field X: <span class="type">int</span></span><br><span class="line">    field Y: <span class="type">int</span></span><br><span class="line">    field color: string</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A regular constructor.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The prototype constructor. A fresh object is initialized</span></span><br><span class="line">    <span class="comment">// with values from the existing object.</span></span><br><span class="line">    constructor <span class="title function_">Shape</span><span class="params">(source: Shape)</span> is</span><br><span class="line">        <span class="title function_">this</span><span class="params">()</span></span><br><span class="line">        <span class="built_in">this</span>.X = source.X</span><br><span class="line">        <span class="built_in">this</span>.Y = source.Y</span><br><span class="line">        <span class="built_in">this</span>.color = source.color</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The clone operation returns one of the Shape subclasses.</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete prototype. The cloning method creates a new object</span></span><br><span class="line"><span class="comment">// in one go by calling the constructor of the current class and</span></span><br><span class="line"><span class="comment">// passing the current object as the constructor&#x27;s argument.</span></span><br><span class="line"><span class="comment">// Performing all the actual copying in the constructor helps to</span></span><br><span class="line"><span class="comment">// keep the result consistent: the constructor will not return a</span></span><br><span class="line"><span class="comment">// result until the new object is fully built; thus, no object</span></span><br><span class="line"><span class="comment">// can have a reference to a partially-built clone.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field width: <span class="type">int</span></span><br><span class="line">    field height: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Rectangle</span><span class="params">(source: Rectangle)</span> is</span><br><span class="line">        <span class="comment">// A parent constructor call is needed to copy private</span></span><br><span class="line">        <span class="comment">// fields defined in the parent class.</span></span><br><span class="line">        <span class="built_in">super</span>(source)</span><br><span class="line">        <span class="built_in">this</span>.width = source.width</span><br><span class="line">        <span class="built_in">this</span>.height = source.height</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">    field radius: <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Circle</span><span class="params">(source: Circle)</span> is</span><br><span class="line">        <span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">        <span class="built_in">this</span>.radius = source.radius</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in the client code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field shapes: array of Shape</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">        circle.X = <span class="number">10</span></span><br><span class="line">        circle.Y = <span class="number">10</span></span><br><span class="line">        circle.radius = <span class="number">20</span></span><br><span class="line">        shapes.add(circle)</span><br><span class="line"></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">anotherCircle</span> <span class="operator">=</span> circle.clone()</span><br><span class="line">        shapes.add(anotherCircle)</span><br><span class="line">        <span class="comment">// The `anotherCircle` variable contains an exact copy</span></span><br><span class="line">        <span class="comment">// of the `circle` object.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>()</span><br><span class="line">        rectangle.width = <span class="number">10</span></span><br><span class="line">        rectangle.height = <span class="number">20</span></span><br><span class="line">        shapes.add(rectangle)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">businessLogic</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Prototype rocks because it lets you produce a copy of</span></span><br><span class="line">        <span class="comment">// an object without knowing anything about its type.</span></span><br><span class="line">        <span class="type">Array</span> <span class="variable">shapesCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span> of Shapes.</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For instance, we don&#x27;t know the exact elements in the</span></span><br><span class="line">        <span class="comment">// shapes array. All we know is that they are all</span></span><br><span class="line">        <span class="comment">// shapes. But thanks to polymorphism, when we call the</span></span><br><span class="line">        <span class="comment">// `clone` method on a shape the program checks its real</span></span><br><span class="line">        <span class="comment">// class and runs the appropriate clone method defined</span></span><br><span class="line">        <span class="comment">// in that class. That&#x27;s why we get proper clones</span></span><br><span class="line">        <span class="comment">// instead of a set of simple Shape objects.</span></span><br><span class="line">        foreach (s in shapes) <span class="keyword">do</span></span><br><span class="line">            shapesCopy.add(s.clone())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The `shapesCopy` array contains exact copies of the</span></span><br><span class="line">        <span class="comment">// `shape` array&#x27;s children.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.当代码不应依赖于需要复制的具体对象类时，请使用 Prototype 模式。</strong></p>
</li>
<li><p>This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.<br>当您的代码使用通过某些接口从第三方代码传递给您的对象时，这种情况经常发生。这些对象的具体类别是未知的，即使你愿意，你也不能依赖它们。</p>
</li>
</ul>
<p>The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.<br>Prototype 模式为客户端代码提供了一个通用接口，用于处理支持克隆的所有对象。此接口使客户端代码独立于它克隆的对象的具体类。</p>
<ul>
<li><p><strong>Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects.<br>如果要减少子类的数量，这些子类仅在初始化各自对象的方式上有所不同，请使用该模式。</strong></p>
</li>
<li><p>Suppose you have a complex class that requires a laborious configuration before it can be used. There are several common ways to configure this class, and this code is scattered through your app. To reduce the duplication, you create several subclasses and put every common configuration code into their constructors. You solved the duplication problem, but now you have lots of dummy subclasses.<br>假设您有一个复杂的类，需要费力的配置才能使用它。有几种常用方法可以配置此类，并且此代码分散在应用中。为了减少重复，您可以创建多个子类，并将每个通用配置代码放入其构造函数中。您解决了重复问题，但现在您有很多虚拟子类。</p>
</li>
</ul>
<p>The Prototype pattern lets you use a set of pre-built objects configured in various ways as prototypes. Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.<br>Prototype模式允许您使用一组以各种方式配置的预构建对象作为原型。客户端可以简单地寻找一个合适的原型并克隆它，而不是实例化一个匹配某些配置的子类。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Create the prototype interface and declare the <code>clone</code> method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.<br>创建原型接口并在其中声明 <code>clone</code> 方法。或者，只需将该方法添加到现有类层次结构的所有类（如果有）。</p>
</li>
<li><p>A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you’re changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields.<br>原型类必须定义接受该类的对象作为参数的替代构造函数。构造函数必须将类中定义的所有字段的值从传递的对象复制到新创建的实例中。如果要更改子类，则必须调用父构造函数，让超类处理其私有字段的克隆。</p>
</li>
</ol>
<p>If your programming language doesn’t support method overloading, you won’t be able to create a separate “prototype” constructor. Thus, copying the object’s data into the newly created clone will have to be performed within the <code>clone</code> method. Still, having this code in a regular constructor is safer because the resulting object is returned fully configured right after you call the <code>new</code> operator.<br>如果你的编程语言不支持方法重载，你将无法创建单独的“原型”构造函数。因此，必须在 <code>clone</code> 该方法中将对象的数据复制到新创建的克隆中。不过，在常规构造函数中使用此代码更安全，因为在调用 <code>new</code> 运算符后立即返回完全配置的结果对象。</p>
<ol start="3">
<li><p>The cloning method usually consists of just one line: running a <code>new</code> operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the <code>new</code> operator. Otherwise, the cloning method may produce an object of a parent class.<br>克隆方法通常只包含一行：使用构造函数的原型版本运行运 <code>new</code> 算符。请注意，每个类都必须显式覆盖克隆方法，并使用自己的类名和 <code>new</code> 运算符。否则，克隆方法可能会生成父类的对象。</p>
</li>
<li><p>Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.<br>（可选）创建一个集中式原型注册表来存储常用原型的目录。</p>
</li>
</ol>
<p>You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.<br>您可以将注册表实现为新的工厂类，也可以使用用于获取原型的静态方法将其放在基原型类中。此方法应根据客户端代码传递给该方法的搜索条件搜索原型。条件可以是简单的字符串标记，也可以是一组复杂的搜索参数。找到适当的原型后，注册表应克隆它并将副本返回给客户端。</p>
<p>Finally, replace the direct calls to the subclasses’ constructors with calls to the factory method of the prototype registry.<br>最后，将对子类构造函数的直接调用替换为对原型注册表的工厂方法的调用。</p>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><ul>
<li>You can clone objects without coupling to their concrete classes.<br>您可以克隆对象，而无需耦合到其具体类。</li>
</ul>
<table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can clone objects without coupling to their concrete classes.您可以克隆对象，而无需耦合到其具体类。</td>
<td>Cloning complex objects that have circular references might be very tricky.克隆具有循环引用的复杂对象可能非常棘手。</td>
</tr>
<tr>
<td>You can get rid of repeated initialization code in favor of cloning pre-built prototypes.您可以摆脱重复的初始化代码，转而克隆预构建的原型。</td>
<td></td>
</tr>
<tr>
<td>You can produce complex objects more conveniently.您可以更方便地生成复杂的对象。</td>
<td></td>
</tr>
<tr>
<td>You get an alternative to inheritance when dealing with configuration presets for complex objects.在处理复杂对象的配置预设时，您可以获得继承的替代方法。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>Many designs start by using <code>Factory Method</code> (less complicated and more customizable via subclasses) and evolve toward <code>Abstract Factory</code>, Prototype, or Builder (more flexible, but more complicated).<br>许多设计从使用工厂方法（不那么复杂，通过子类更可定制）开始，然后发展到抽象工厂、原型或构建器（更灵活，但更复杂）。</p>
</li>
<li><p><code>Abstract Factory</code> classes are often based on a set of <code>Factory Methods</code>, but you can also use <code>Prototype</code> to compose the methods on these classes.<br>抽象工厂类通常基于一组工厂方法，但您也可以使用 Prototype 来组合这些类的方法。</p>
</li>
<li><p><code>Prototype</code> can help when you need to save copies of <code>Commands</code> into history.<br>当您需要将命令的副本保存到历史记录中时，Prototype 可以提供帮助。</p>
</li>
<li><p>Designs that make heavy use of <code>Composite</code> and <code>Decorator</code> can often benefit from using <code>Prototype</code>. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.<br>大量使用 Composite 和 Decorator 的设计通常可以从使用 Prototype 中受益。通过应用该模式，您可以克隆复杂的结构，而不是从头开始重新构建它们。</p>
</li>
<li><p><code>Prototype</code> isn’t based on inheritance, so it doesn’t have its drawbacks. On the other hand, Prototype requires a complicated initialization of the cloned object. <code>Factory Method</code> is based on inheritance but doesn’t require an initialization step.<br>原型不是基于继承的，所以它没有缺点。另一方面，Prototype 需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。</p>
</li>
<li><p>Sometimes <code>Prototype</code> can be a simpler alternative to <code>Memento</code>. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn’t have links to external resources, or the links are easy to re-establish.<br>有时，Prototype 可以成为 Memento 的更简单替代品。如果要存储在历史记录中的对象的状态相当简单，并且没有指向外部资源的链接，或者链接易于重新建立，则此方法有效。</p>
</li>
<li><p><code>Abstract Factories</code>, <code>Builders</code> and <code>Prototypes</code> can all be implemented as <code>Singletons</code>.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Conceptual-example"><a href="#Python-Conceptual-example" class="headerlink" title="Python Conceptual example"></a>Python Conceptual example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelfReferencingEntity</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_parent</span>(<span class="params">self, parent</span>):</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComponent</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Python provides its own interface of Prototype via `copy.copy` and</span></span><br><span class="line"><span class="string">    `copy.deepcopy` functions. And any class that wants to implement custom</span></span><br><span class="line"><span class="string">    implementations have to override `__copy__` and `__deepcopy__` member</span></span><br><span class="line"><span class="string">    functions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, some_int, some_list_of_objects, some_circular_ref</span>):</span><br><span class="line">        self.some_int = some_int</span><br><span class="line">        self.some_list_of_objects = some_list_of_objects</span><br><span class="line">        self.some_circular_ref = some_circular_ref</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__copy__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a shallow copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.copy` with this object and the returned value is returned as the</span></span><br><span class="line"><span class="string">        new shallow copy.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.copy(self.some_list_of_objects)</span><br><span class="line">        some_circular_ref = copy.copy(self.some_circular_ref)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__.update(self.__dict__)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deepcopy__</span>(<span class="params">self, memo=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create a deep copy. This method will be called whenever someone calls</span></span><br><span class="line"><span class="string">        `copy.deepcopy` with this object and the returned value is returned as</span></span><br><span class="line"><span class="string">        the new deep copy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        What is the use of the argument `memo`? Memo is the dictionary that is</span></span><br><span class="line"><span class="string">        used by the `deepcopy` library to prevent infinite recursive copies in</span></span><br><span class="line"><span class="string">        instances of circular references. Pass it to all the `deepcopy` calls</span></span><br><span class="line"><span class="string">        you make in the `__deepcopy__` implementation to prevent infinite</span></span><br><span class="line"><span class="string">        recursions.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># First, let&#x27;s create copies of the nested objects.</span></span><br><span class="line">        some_list_of_objects = copy.deepcopy(self.some_list_of_objects, memo)</span><br><span class="line">        some_circular_ref = copy.deepcopy(self.some_circular_ref, memo)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Then, let&#x27;s clone the object itself, using the prepared clones of the</span></span><br><span class="line">        <span class="comment"># nested objects.</span></span><br><span class="line">        new = self.__class__(</span><br><span class="line">            self.some_int, some_list_of_objects, some_circular_ref</span><br><span class="line">        )</span><br><span class="line">        new.__dict__ = copy.deepcopy(self.__dict__, memo)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    list_of_objects = [<span class="number">1</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">    circular_ref = SelfReferencingEntity()</span><br><span class="line">    component = SomeComponent(<span class="number">23</span>, list_of_objects, circular_ref)</span><br><span class="line">    circular_ref.set_parent(component)</span><br><span class="line"></span><br><span class="line">    shallow_copied_component = copy.copy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in shallow_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    shallow_copied_component.some_list_of_objects.append(<span class="string">&quot;another object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;another object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">4</span> <span class="keyword">in</span> shallow_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `shallow_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    deep_copied_component = copy.deepcopy(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the list in deep_copied_component and see if it changes in</span></span><br><span class="line">    <span class="comment"># component.</span></span><br><span class="line">    deep_copied_component.some_list_of_objects.append(<span class="string">&quot;one more object&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> component.some_list_of_objects[-<span class="number">1</span>] == <span class="string">&quot;one more object&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects adds it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Adding elements to `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects doesn&#x27;t add it to `component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let&#x27;s change the set in the list of objects.</span></span><br><span class="line">    component.some_list_of_objects[<span class="number">1</span>].add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> deep_copied_component.some_list_of_objects[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;changes that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Changing objects in the `component`&#x27;s some_list_of_objects &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t change that object in `deep_copied_component`&#x27;s &quot;</span></span><br><span class="line">            <span class="string">&quot;some_list_of_objects.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): &quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">id</span>(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;^^ This shows that deepcopied objects contain same reference, they &quot;</span></span><br><span class="line">        <span class="string">&quot;are not cloned repeatedly.&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adding elements to `shallow_copied_component`&#x27;s some_list_of_objects adds it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects changes that object in `shallow_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">Adding elements to `deep_copied_component`&#x27;s some_list_of_objects doesn&#x27;t add it to `component`&#x27;s some_list_of_objects.</span><br><span class="line">Changing objects in the `component`&#x27;s some_list_of_objects doesn&#x27;t change that object in `deep_copied_component`&#x27;s some_list_of_objects.</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent): 4429472784</span><br><span class="line">id(deep_copied_component.some_circular_ref.parent.some_circular_ref.parent): 4429472784</span><br><span class="line">^^ This shows that deepcopied objects contain same reference, they are not cloned repeatedly.</span><br></pre></td></tr></table></figure>

<h3 id="Rust-Built-in-Clone-trait-内置克隆特征"><a href="#Rust-Built-in-Clone-trait-内置克隆特征" class="headerlink" title="Rust Built-in Clone trait 内置克隆特征"></a>Rust Built-in Clone trait 内置克隆特征</h3><p>Rust has a built-in <code>std::clone::Clone</code> trait with many implementations for various types (via <code>#[derive(Clone)]</code>). Thus, the Prototype pattern is ready to use out of the box.<br>Rust 有一个内置 <code>std::clone::Clone</code> 的特性，具有许多针对各种类型的实现（通过 <code>#[derive(Clone)]</code> ）。因此，原型模式可以开箱即用。</p>
<h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> y: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> radius: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle1</span> = Circle &#123;</span><br><span class="line">        x: <span class="number">10</span>,</span><br><span class="line">        y: <span class="number">15</span>,</span><br><span class="line">        radius: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prototype in action.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">circle2</span> = circle1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    circle2.radius = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 1: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle1.x, circle1.y, circle1.radius);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle 2: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, circle2.x, circle2.y, circle2.radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Circle 1: 10, 15, 10</span><br><span class="line">Circle 2: 10, 15, 77</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
  <entry>
    <title>Singleton</title>
    <url>/2023/11/23/design-pattern/singleton/</url>
    <content><![CDATA[<h1 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h1><h2 id="Intent-意图"><a href="#Intent-意图" class="headerlink" title="Intent 意图"></a>Intent 意图</h2><p><strong>Singleton</strong> is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.<br>Singleton 是一种创建性设计模式，它允许您确保一个类只有一个实例，同时提供此实例的全局访问点。</p>
<div align="center"> <img src="/images/singleton-header.png"/></div>

<h2 id="Problem-问题"><a href="#Problem-问题" class="headerlink" title="Problem 问题"></a>Problem 问题</h2><p>The Singleton pattern solves two problems at the same time, violating the Single Responsibility Principle:<br>Singleton 模式同时解决了两个问题，违反了单一责任原则：</p>
<ol>
<li><strong>Ensure that a class has just a single instance</strong>. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.<br>确保一个类只有一个实例。为什么有人想要控制一个类有多少个实例？最常见的原因是控制对某些共享资源（例如数据库或文件）的访问。</li>
</ol>
<p>Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.<br>它是这样工作的：假设你创建了一个对象，但过了一段时间决定创建一个新对象。您将获得已创建的对象，而不是接收新对象。</p>
<p>Note that this behavior is impossible to implement with a regular constructor since a constructor call must always return a new object by design.<br>请注意，此行为无法使用常规构造函数实现，因为构造函数调用必须始终返回新对象。</p>
<div align="center"> <img src="/images/singleton-comic-1-en.png"/>Clients may not even realize that they’re working with the same object all the time.</br>客户甚至可能没有意识到他们一直在使用同一个对象。</div>

<ol start="2">
<li><strong>Provide a global access point to that instance</strong>.Remember those global variables that you (all right, me) used to store some essential objects? While they’re very handy, they’re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.<br>为该实例提供全局访问点。还记得你（好吧，我）用来存储一些基本对象的那些全局变量吗？虽然它们非常方便，但它们也非常不安全，因为任何代码都可能覆盖这些变量的内容并使应用程序崩溃。<br>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.<br>就像全局变量一样，Singleton 模式允许您从程序中的任何位置访问某些对象。但是，它还可以保护该实例不被其他代码覆盖。<br>There’s another side to this problem: you don’t want the code that solves problem #1 to be scattered all over your program. It’s much better to have it within one class, especially if the rest of your code already depends on it.<br>这个问题还有另一面：你不希望解决问题 #1 的代码分散在你的程序中。最好将它放在一个类中，特别是如果您的其余代码已经依赖于它。</li>
</ol>
<p>Nowadays, the Singleton pattern has become so popular that people may call something a singleton even if it solves just one of the listed problems.<br>如今，单例模式已经变得如此流行，以至于人们可能会称某物为单例，即使它只解决了列出的问题之一。</p>
<h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution 解决方案"></a>Solution 解决方案</h2><p>All implementations of the Singleton have these two steps in common:<br>Singleton 的所有实现都具有以下两个共同步骤：</p>
<ul>
<li>Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.<br>将默认构造函数设为私有，以防止其他对象将运 new 算符与 Singleton 类一起使用。</li>
<li>Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the cached object.<br>创建一个充当构造函数的静态创建方法。在后台，此方法调用私有构造函数来创建对象并将其保存在静态字段中。对此方法的所有后续调用都将返回缓存的对象。</li>
</ul>
<p>If your code has access to the Singleton class, then it’s able to call the Singleton’s static method. So whenever that method is called, the same object is always returned.<br>如果您的代码有权访问 Singleton 类，则它能够调用 Singleton 的静态方法。因此，每当调用该方法时，始终返回相同的对象。</p>
<h2 id="Real-World-Analogy-真实世界的类比"><a href="#Real-World-Analogy-真实世界的类比" class="headerlink" title="Real-World Analogy 真实世界的类比"></a>Real-World Analogy 真实世界的类比</h2><p>The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, “The Government of X”, is a global point of access that identifies the group of people in charge.<br>政府是辛格尔顿模式的一个很好的例子。一个国家只能有一个官方政府。无论组成政府的个人的个人身份如何，“X政府”这个头衔都是一个全球访问点，用于识别负责人群体。</p>
<h2 id="Structure-结构"><a href="#Structure-结构" class="headerlink" title="Structure 结构"></a>Structure 结构</h2><div align="center"> <img src="/images/singleton-structure-en.png"/></div>
The **Singleton** class declares the static method getInstance that returns the same instance of its own class.
**Singleton** 类声明返回其自身类的相同实例的静态方法 getInstance 。

<p>The Singleton’s constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.<br>Singleton 的构造函数应在客户端代码中隐藏。调用该 getInstance 方法应该是获取 Singleton 对象的唯一方法。</p>
<h2 id="Pseudocode-伪代码"><a href="#Pseudocode-伪代码" class="headerlink" title="Pseudocode 伪代码"></a>Pseudocode 伪代码</h2><p>In this example, the database connection class acts as a <strong>Singleton</strong>. This class doesn’t have a public constructor, so the only way to get its object is to call the <code>getInstance</code> method. This method caches the first created object and returns it in all subsequent calls.<br>在此示例中，数据库连接类充当 Singleton。此类没有公共构造函数，因此获取其对象的唯一方法是调用该 <code>getInstance</code> 方法。此方法缓存第一个创建的对象，并在所有后续调用中返回该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Database class defines the `getInstance` method that lets</span></span><br><span class="line"><span class="comment">// clients access the same instance of a database connection</span></span><br><span class="line"><span class="comment">// throughout the program.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">    <span class="comment">// The field for storing the singleton instance should be</span></span><br><span class="line">    <span class="comment">// declared static.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The singleton&#x27;s constructor should always be private to</span></span><br><span class="line">    <span class="comment">// prevent direct construction calls with the `new`</span></span><br><span class="line">    <span class="comment">// operator.</span></span><br><span class="line">    <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// Some initialization code, such as the actual</span></span><br><span class="line">        <span class="comment">// connection to a database server.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The static method that controls access to the singleton</span></span><br><span class="line">    <span class="comment">// instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">            <span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line">                <span class="comment">// Ensure that the instance hasn&#x27;t yet been</span></span><br><span class="line">                <span class="comment">// initialized by another thread while this one</span></span><br><span class="line">                <span class="comment">// has been waiting for the lock&#x27;s release.</span></span><br><span class="line">                <span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line">                    Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line">        <span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, any singleton should define some business logic</span></span><br><span class="line">    <span class="comment">// which can be executed on its instance.</span></span><br><span class="line">    <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">        <span class="comment">// For instance, all database queries of an app go</span></span><br><span class="line">        <span class="comment">// through this method. Therefore, you can place</span></span><br><span class="line">        <span class="comment">// throttling or caching logic here.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// The variable `bar` will contain the same object as</span></span><br><span class="line">        <span class="comment">// the variable `foo`.</span></span><br></pre></td></tr></table></figure>
<h2 id="Applicability-适用性"><a href="#Applicability-适用性" class="headerlink" title="Applicability 适用性"></a>Applicability 适用性</h2><ul>
<li><p><strong>Use the Singleton pattern when a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program.当程序中的类应该只有一个实例可供所有客户端使用时，请使用单例模式;例如，由程序的不同部分共享的单个数据库对象。</strong></p>
</li>
<li><p>The Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created.<br>Singleton 模式禁用除特殊创建方法之外的所有其他创建类对象的方法。此方法要么创建一个新对象，要么返回一个现有对象（如果已创建）。</p>
</li>
<li><p><strong>Use the Singleton pattern when you need stricter control over global variables.当您需要对全局变量进行更严格的控制时，请使用单例模式。</strong></p>
</li>
<li><p>Unlike global variables, the Singleton pattern guarantees that there’s just one instance of a class. Nothing, except for the Singleton class itself, can replace the cached instance.<br>与全局变量不同，单例模式保证一个类只有一个实例。除了 Singleton 类本身之外，没有任何内容可以替换缓存的实例。</p>
</li>
</ul>
<p>Note that you can always adjust this limitation and allow creating any number of Singleton instances. The only piece of code that needs changing is the body of the <code>getInstance</code> method.<br>请注意，您始终可以调整此限制，并允许创建任意数量的单例实例。唯一需要更改的代码段是 <code>getInstance</code> 方法的主体。</p>
<h2 id="How-to-Implement-如何实现"><a href="#How-to-Implement-如何实现" class="headerlink" title="How to Implement 如何实现"></a>How to Implement 如何实现</h2><ol>
<li><p>Add a private static field to the class for storing the singleton instance.<br>在类中添加一个私有静态字段，用于存储单例实例。</p>
</li>
<li><p>Declare a public static creation method for getting the singleton instance.<br>声明用于获取单例实例的公共静态创建方法。</p>
</li>
<li><p>Implement “lazy initialization” inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.<br>在静态方法中实现“延迟初始化”。它应该在第一次调用时创建一个新对象，并将其放入静态字段中。该方法应始终在所有后续调用中返回该实例。</p>
</li>
<li><p>Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.<br>将类的构造函数设为私有。类的静态方法仍然能够调用构造函数，但不能调用其他对象。</p>
</li>
<li><p>Go over the client code and replace all direct calls to the singleton’s constructor with calls to its static creation method.<br>遍历客户端代码，并将对单例构造函数的所有直接调用替换为对其静态创建方法的调用。</p>
</li>
</ol>
<h2 id="Pros-and-Cons-优点和缺点"><a href="#Pros-and-Cons-优点和缺点" class="headerlink" title="Pros and Cons 优点和缺点"></a>Pros and Cons 优点和缺点</h2><table>
<thead>
<tr>
<th>Pros 优点</th>
<th>Cons 缺点</th>
</tr>
</thead>
<tbody><tr>
<td>You can be sure that a class has only a single instance.可以确定一个类只有一个实例。</td>
<td>Violates the Single Responsibility Principle. The pattern solves two problems at the time.违反了单一责任原则。该模式解决了当时的两个问题。</td>
</tr>
<tr>
<td>You gain a global access point to that instance.您将获得该实例的全局访问点。</td>
<td>The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.单例模式可以掩盖糟糕的设计，例如，当程序的组件彼此了解太多时。</td>
</tr>
<tr>
<td>The singleton object is initialized only when it’s requested for the first time.仅当首次请求单一实例对象时，才会对其进行初始化。</td>
<td>The pattern requires special treatment in a multithreaded environment so that multiple threads won’t create a singleton object several times.</td>
</tr>
<tr>
<td>该模式需要在多线程环境中进行特殊处理，以便多个线程不会多次创建单一实例对象。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.对 Singleton 的客户端代码进行单元测试可能很困难，因为许多测试框架在生成模拟对象时依赖于继承。由于单例类的构造函数是私有的，并且在大多数语言中不可能重写静态方法，因此您需要想出一种创造性的方法来模拟单例。或者干脆不写测试。或者不要使用单一实例模式。</td>
</tr>
</tbody></table>
<h2 id="Relations-with-Other-Patterns-与其他模式的关系"><a href="#Relations-with-Other-Patterns-与其他模式的关系" class="headerlink" title="Relations with Other Patterns 与其他模式的关系"></a>Relations with Other Patterns 与其他模式的关系</h2><ul>
<li><p>A <strong>Facade</strong> class can often be transformed into a <strong>Singleton</strong> since a single facade object is sufficient in most cases.<br>Facade 类通常可以转换为 Singleton，因为在大多数情况下，单个 Facade 对象就足够了。</p>
</li>
<li><p><strong>Flyweight</strong> would resemble <strong>Singleton</strong> if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:<br>如果你以某种方式设法将对象的所有共享状态减少到一个蝇量级对象，那么 Flyweight 将类似于 Singleton。但这些模式之间有两个根本区别：</p>
<ol>
<li>There should be only one Singleton instance, whereas a Flyweight class can have multiple instances with different intrinsic states.<br>应该只有一个 Singleton 实例，而 Flyweight 类可以有多个具有不同内部状态的实例。</li>
<li>The Singleton object can be mutable. Flyweight objects are immutable.<br>Singleton 对象可以是可变的。轻量级对象是不可变的。</li>
</ol>
</li>
<li><p>Abstract Factories, Builders and Prototypes can all be implemented as Singletons.<br>抽象工厂、构建器和原型都可以作为单例实现。</p>
</li>
</ul>
<h2 id="Code-Examples-代码示例"><a href="#Code-Examples-代码示例" class="headerlink" title="Code Examples 代码示例"></a>Code Examples 代码示例</h2><h3 id="Python-Navie-Singleton-简单版"><a href="#Python-Navie-Singleton-简单版" class="headerlink" title="Python: Navie Singleton 简单版"></a>Python: Navie Singleton 简单版</h3><p>It’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method.<br>实现一个草率的 Singleton 非常容易。你只需要隐藏构造函数并实现一个静态创建方法。</p>
<p>The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class.<br>同一类在多线程环境中的行为不正确。多个线程可以同时调用创建方法，并获取 Singleton 类的多个实例。</p>
<h4 id="main-py-Conceptual-example"><a href="#main-py-Conceptual-example" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Singleton class can be implemented in different ways in Python. Some</span></span><br><span class="line"><span class="string">    possible methods include: base class, decorator, metaclass. We will use the</span></span><br><span class="line"><span class="string">    metaclass because it is best suited for this purpose.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">            cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    s1 = Singleton()</span><br><span class="line">    s2 = Singleton()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">id</span>(s1) == <span class="built_in">id</span>(s2):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton works, both variables contain the same instance.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Singleton failed, variables contain different instances.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result"><a href="#Output-txt-Execution-result" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Singleton works, both variables contain the same instance.</span><br></pre></td></tr></table></figure>

<h3 id="Python-Thread-safe-Singleton-线程安全单例"><a href="#Python-Thread-safe-Singleton-线程安全单例" class="headerlink" title="Python: Thread-safe Singleton 线程安全单例"></a>Python: Thread-safe Singleton 线程安全单例</h3><p>To fix the problem, you have to synchronize threads during the first creation of the Singleton object.<br>若要解决此问题，必须在首次创建 Singleton 对象期间同步线程。</p>
<h4 id="main-py-Conceptual-example-1"><a href="#main-py-Conceptual-example-1" class="headerlink" title="main.py: Conceptual example"></a>main.py: Conceptual example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is a thread-safe implementation of Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    _lock: Lock = Lock()</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We now have a lock object that will be used to synchronize threads during</span></span><br><span class="line"><span class="string">    first access to the Singleton.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Possible changes to the value of the `__init__` argument do not affect</span></span><br><span class="line"><span class="string">        the returned instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Now, imagine that the program has just been launched. Since there&#x27;s no</span></span><br><span class="line">        <span class="comment"># Singleton instance yet, multiple threads can simultaneously pass the</span></span><br><span class="line">        <span class="comment"># previous conditional and reach this point almost at the same time. The</span></span><br><span class="line">        <span class="comment"># first of them will acquire lock and will proceed further, while the</span></span><br><span class="line">        <span class="comment"># rest will wait here.</span></span><br><span class="line">        <span class="keyword">with</span> cls._lock:</span><br><span class="line">            <span class="comment"># The first thread to acquire the lock, reaches this conditional,</span></span><br><span class="line">            <span class="comment"># goes inside and creates the Singleton instance. Once it leaves the</span></span><br><span class="line">            <span class="comment"># lock block, a thread that might have been waiting for the lock</span></span><br><span class="line">            <span class="comment"># release may then enter this section. But since the Singleton field</span></span><br><span class="line">            <span class="comment"># is already initialized, the thread won&#x27;t create a new object.</span></span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">                instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">                cls._instances[cls] = instance</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    value: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We&#x27;ll use this property to prove that our Singleton really works.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_business_logic</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Finally, any singleton should define some business logic, which can be</span></span><br><span class="line"><span class="string">        executed on its instance.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_singleton</span>(<span class="params">value: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    singleton = Singleton(value)</span><br><span class="line">    <span class="built_in">print</span>(singleton.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If you see the same value, then singleton was reused (yay!)\n&quot;</span></span><br><span class="line">          <span class="string">&quot;If you see different values, &quot;</span></span><br><span class="line">          <span class="string">&quot;then 2 singletons were created (booo!!)\n\n&quot;</span></span><br><span class="line">          <span class="string">&quot;RESULT:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    process1 = Thread(target=test_singleton, args=(<span class="string">&quot;FOO&quot;</span>,))</span><br><span class="line">    process2 = Thread(target=test_singleton, args=(<span class="string">&quot;BAR&quot;</span>,))</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br></pre></td></tr></table></figure>
<h4 id="Output-txt-Execution-result-1"><a href="#Output-txt-Execution-result-1" class="headerlink" title="Output.txt: Execution result"></a>Output.txt: Execution result</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you see the same value, then singleton was reused (yay!)</span><br><span class="line">If you see different values, then 2 singletons were created (booo!!)</span><br><span class="line"></span><br><span class="line">RESULT:</span><br><span class="line"></span><br><span class="line">FOO</span><br><span class="line">FOO</span><br></pre></td></tr></table></figure>

<h3 id="Rust-specifics"><a href="#Rust-specifics" class="headerlink" title="Rust specifics"></a>Rust specifics</h3><p>By definition, Singleton is a global mutable object. In Rust this is a <code>static mut</code> item. Thus, to avoid all sorts of concurrency issues, the function or block that is either reading or writing to a mutable static variable should be marked as an <code>unsafe</code> block.<br>根据定义，Singleton 是一个全局可变对象。在 Rust 中， static mut 这是一个项目。因此，为了避免各种并发问题，应将读取或写入可变静态变量的函数或块标记为 <code>unsafe</code> 块。</p>
<p>For this reason, the Singleton pattern can be percieved as unsafe. However, the pattern is still widely used in practice. A good read-world example of Singleton is a <code>log</code> crate that introduces <code>log!</code>, <code>debug!</code> and other logging macros, which you can use throughout your code after setting up a concrete logger instance, such as <code>env_logger</code>. As we can see, <code>env_logger</code> uses log::set_boxed_logger under the hood, which has an <code>unsafe</code> block to set up a global logger object.<br>因此，Singleton 模式可能被认为是不安全的。然而，该模式在实践中仍然被广泛使用。Singleton 的一个很好的读取世界示例是一个 log crate，它引入了 log! 和其他 debug! 日志记录宏，在设置具体的记录器实例（如 <code>env_logger</code>）后，您可以在整个代码中使用这些宏。正如我们所看到的， <code>env_logger</code> 在后台使用 log：：set_boxed_logger，它有一个 unsafe 用于设置全局记录器对象的块。</p>
<ul>
<li><p>In order to provide safe and usable access to a singleton object, introduce an API hiding unsafe blocks under the hood.<br>为了提供对单例对象的安全且可用的访问，请在后台引入一个隐藏 <code>unsafe</code> 块的 API。</p>
</li>
<li><p>See the thread about a mutable Singleton on Stackoverflow for more information.<br>有关更多信息，请参阅 Stackoverflow 上有关可变 Singleton 的线程。</p>
</li>
</ul>
<p>Starting with Rust 1.63, <code>Mutex::new</code> is <code>const</code>, you can use global static Mutex locks without needing lazy initialization. See the Singleton using <code>Mutex</code> example below.<br>从 Rust 1.63 开始，您可以使用全局静态 Mutex 锁， <code>Mutex::new</code> <code>const</code> 而无需延迟初始化。请参阅下面的使用互斥锁的单例示例。</p>
<h4 id="Safe-Singleton-安全单例"><a href="#Safe-Singleton-安全单例" class="headerlink" title="Safe Singleton 安全单例"></a>Safe Singleton 安全单例</h4><p>A pure safe way to implement Singleton in Rust is using no global variables at all and passing everything around through function arguments. The oldest living variable is an object created at the start of the <code>main()</code>.<br>在 Rust 中实现 Singleton 的一个纯粹安全的方法是完全不使用全局变量，并通过函数参数传递所有内容。最早的活变量是在 的开头创建的对象 <code>main()</code> 。</p>
<h4 id="safe-rs"><a href="#safe-rs" class="headerlink" title="safe.rs"></a>safe.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! A pure safe way to implement Singleton in Rust is using no static variables</span></span><br><span class="line"><span class="comment">//! and passing everything around through function arguments.</span></span><br><span class="line"><span class="comment">//! The oldest living variable is an object created at the start of the `main()`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(global_state: &amp;<span class="keyword">mut</span> <span class="type">u32</span>) &#123;</span><br><span class="line">    *global_state += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">global_state</span> = <span class="number">0u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> global_state);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Final state: &#123;&#125;&quot;</span>, global_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Final state: 1</span><br></pre></td></tr></table></figure>

<h4 id="Lazy-Singleton-惰性单例模式"><a href="#Lazy-Singleton-惰性单例模式" class="headerlink" title="Lazy Singleton 惰性单例模式"></a>Lazy Singleton 惰性单例模式</h4><p>This is a singleton implementation via <code>lazy_static!</code>, which allows declaring a static variable with lazy initialization at first access. It is actually implemented via <code>unsafe</code> with <code>static mut</code> manipulation, however, it keeps your code clear of <code>unsafe</code> blocks.<br>这是一个单例实现，它 lazy_static! 允许在首次访问时使用延迟初始化声明静态变量。它实际上 <code>unsafe</code> 是通过 <code>static mut</code> 操作实现的，但是，它使您的代码没有 <code>unsafe</code> 块。</p>
<h4 id="lazy-rs"><a href="#lazy-rs" class="headerlink" title="lazy.rs"></a>lazy.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Taken from: https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Rust doesn&#x27;t really allow a singleton pattern without `unsafe` because it</span></span><br><span class="line"><span class="comment">//! doesn&#x27;t have a safe mutable global state.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `lazy-static` allows declaring a static variable with lazy initialization</span></span><br><span class="line"><span class="comment">//! at first access. It is actually implemented via `unsafe` with `static mut`</span></span><br><span class="line"><span class="comment">//! manipulation, however, it keeps your code clear of `unsafe` blocks.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `Mutex` provides safe access to a single object.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125;&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3</span><br></pre></td></tr></table></figure>

<h4 id="Singleton-using-Mutex-使用互斥锁的单例"><a href="#Singleton-using-Mutex-使用互斥锁的单例" class="headerlink" title="Singleton using Mutex 使用互斥锁的单例"></a>Singleton using Mutex 使用互斥锁的单例</h4><p>Starting with <code>Rust 1.63</code>, it can be easier to work with global mutable singletons, although it’s still preferable to avoid global variables in mostcases.<br>从 开始 <code>Rust 1.63</code> ，使用全局可变单例会更容易，尽管在大多数情况下仍然最好避免全局变量。</p>
<p>Now that <code>Mutex::new</code> is <code>const</code>, you can use global static <code>Mutex</code> locks without needing lazy initialization.<br>现在 <code>Mutex::new</code> ，您可以使用全局静态 <code>Mutex </code>锁 <code>const</code> ，而无需延迟初始化。</p>
<h4 id="mutex-rs"><a href="#mutex-rs" class="headerlink" title="mutex.rs"></a>mutex.rs</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! ructc 1.63</span></span><br><span class="line"><span class="comment">//! https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Starting with Rust 1.63, it can be easier to work with global mutable</span></span><br><span class="line"><span class="comment">//! singletons, although it&#x27;s still preferable to avoid global variables in most</span></span><br><span class="line"><span class="comment">//! cases.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! Now that `Mutex::new` is `const`, you can use global static `Mutex` locks</span></span><br><span class="line"><span class="comment">//! without needing lazy initialization.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ARRAY: Mutex&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_a_call</span>() &#123;</span><br><span class="line">    ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line">    <span class="title function_ invoke__">do_a_call</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Called &#123;&#125; times&quot;</span>, ARRAY.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called 3 times</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>What&#39;s a design pattern?</title>
    <url>/2023/11/09/design-pattern/what-is-a-design-pattern/</url>
    <content><![CDATA[<h1 id="What’s-a-design-pattern"><a href="#What’s-a-design-pattern" class="headerlink" title="What’s a design pattern?"></a>What’s a design pattern?</h1><h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p>Design patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.</p>
<p>设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，您可以自定义这些蓝图来解决代码中反复出现的设计问题。</p>
<p>You can’t just find a pattern and copy it into your program, the way you can with off-the-shelf functions or libraries. The pattern is not a specific piece of code, but a general concept for solving a particular problem. You can follow the pattern details and implement a solution that suits the realities of your own program.</p>
<p>你不能只是找到一个模式并将其复制到你的程序中，就像你使用现成的函数或库一样。模式不是一段特定的代码，而是解决特定问题的一般概念。您可以遵循模式详细信息，并实现适合您自己程序实际情况的解决方案。</p>
<p>Patterns are often confused with algorithms, because both concepts describe typical solutions to some known problems. While an algorithm always defines a clear set of actions that can achieve some goal, a pattern is a more high-level description of a solution. The code of the same pattern applied to two different programs may be different.</p>
<p>模式经常与算法混淆，因为这两个概念都描述了一些已知问题的典型解决方案。虽然算法始终定义一组可以实现某些目标的明确操作，但模式是对解决方案的更高级描述。应用于两个不同程序的相同模式的代码可能不同。</p>
<p>An analogy to an algorithm is a cooking recipe: both have clear steps to achieve a goal. On the other hand, a pattern is more like a blueprint: you can see what the result and its features are, but the exact order of implementation is up to you.</p>
<p>算法的类比是烹饪食谱：两者都有明确的步骤来实现目标。另一方面，模式更像是一个蓝图：你可以看到结果及其功能是什么，但实现的确切顺序取决于你。</p>
<h1 id="What-does-the-pattern-consist-of"><a href="#What-does-the-pattern-consist-of" class="headerlink" title="What does the pattern consist of?"></a>What does the pattern consist of?</h1><h1 id="模式由什么组成？"><a href="#模式由什么组成？" class="headerlink" title="模式由什么组成？"></a>模式由什么组成？</h1><p>Most patterns are described very formally so people can reproduce them in many contexts. Here are the sections that are usually present in a pattern description:</p>
<p>大多数模式都描述得非常正式，因此人们可以在许多情况下重现它们。以下是模式描述中通常存在的部分：</p>
<ul>
<li>Intent of the pattern briefly describes both the problem and the solution.<br>模式的意图简要描述了问题和解决方案。</li>
<li>Motivation further explains the problem and the solution the pattern makes possible.<br>动机进一步解释了问题和模式使解决方案成为可能。</li>
<li>Structure of classes shows each part of the pattern and how they are related.<br>类的结构显示了模式的每个部分以及它们之间的关系。</li>
<li>Code example in one of the popular programming languages makes it easier to grasp the idea behind the pattern.<br>使用一种流行的编程语言的代码示例可以更容易地掌握模式背后的思想。</li>
</ul>
<p>Some pattern catalogs list other useful details, such as applicability of the pattern, implementation steps and relations with other patterns.</p>
<p>一些模式目录列出了其他有用的细节，例如模式的适用性、实现步骤以及与其他模式的关系。</p>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Why should I learn patterns?</title>
    <url>/2023/11/15/design-pattern/why-should-i-learn-patterns/</url>
    <content><![CDATA[<h1 id="Why-should-I-learn-patterns"><a href="#Why-should-I-learn-patterns" class="headerlink" title="Why should I learn patterns?"></a>Why should I learn patterns?</h1><h1 id="我为什么要学习模式？"><a href="#我为什么要学习模式？" class="headerlink" title="我为什么要学习模式？"></a>我为什么要学习模式？</h1><p>The truth is that you might manage to work as a programmer for many years without knowing about a single pattern. A lot of people do just that. Even in that case, though, you might be implementing some patterns without even knowing it. So why would you spend time learning them?</p>
<p>事实是，你可能在不了解单一模式的情况下设法作为程序员工作多年。很多人就是这样做的。但是，即使在这种情况下，您也可能在不知不觉中实现某些模式。那么，你为什么要花时间学习它们呢？</p>
<ul>
<li><p>Design patterns are a toolkit of tried and tested solutions to common problems in software design. Even if you never encounter these problems, knowing patterns is still useful because it teaches you how to solve all sorts of problems using principles of object-oriented design.<br>设计模式是软件设计中常见问题的久经考验的解决方案工具包。即使你从未遇到过这些问题，了解模式仍然很有用，因为它教会了你如何使用面向对象设计的原则来解决各种问题。</p>
</li>
<li><p>Design patterns define a common language that you and your teammates can use to communicate more efficiently. You can say, “Oh, just use a Singleton for that,” and everyone will understand the idea behind your suggestion. No need to explain what a singleton is if you know the pattern and its name.<br>设计模式定义了一种通用语言，您和您的团队成员可以使用该语言来更有效地进行通信。你可以说，“哦，就用一个单例来做这件事吧”，每个人都会理解你的建议背后的想法。如果您知道模式及其名称，则无需解释什么是单例。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.01:本地文档</title>
    <url>/2022/12/25/rust_docs/ch_01_01_Installation/</url>
    <content><![CDATA[<h4 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h4><p>安装过程包括了将对应Rust版本的文档复制到本地。所以你可以阅读官方文档，也可以通过命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustup doc</span><br></pre></td></tr></table></figure>

<p>会在浏览器里打开本地文档。</p>
<p>标准库里面的任何一个类型或者函数你不确定的时候，或者你不知道怎么用。使用应用程序编程接口(API)文档来找出答案。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 00.00:欢迎来到Rust编程语言世界！</title>
    <url>/2022/12/24/rust_docs/ch_00_00_introducation/</url>
    <content><![CDATA[<h4 id="欢迎来到Rust编程语言世界！"><a href="#欢迎来到Rust编程语言世界！" class="headerlink" title="欢迎来到Rust编程语言世界！"></a>欢迎来到Rust编程语言世界！</h4><p>不管写的好与差，挖坑先，要不然永远不会开始。</p>
<p>Hello, World!</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2022计划开始一系列关于学习Rust入门的学习笔记，主要是根据官方的文档入门学习。</p>
<p>Rust程序设计语言能帮助你编写更快，更可靠的软件。在编程语言的设计中，高层工程学和底层控制常常是冲突的。Rust挑战了这种冲突。通过平衡强大的技术能力（powerful technical capacity）和 极好的开发者体验（great developer experience）,Rust 可以控制底层的细节（比如内存的使用）但不用忍受传统同类型语言那些困扰。</p>
<p>Rust 已经在证明着自己，对于学习过编程知识的不同水平的开发者来说，如果他们开发大型协同项目都是不错的生产工具。底层的代码容易产生各种不易发现的bugs,在其他编程语言中，要发现这些bugs只能通过广泛的测试和团队中经验丰富的大佬们仔细的评审（review）。在Rust设计中，编译器（compiler）扮演着守门员的角色，它会拒绝包含各种bugs代码的编译。通过编译器的帮忙，开发团队将会把更多的时间用在程序的逻辑上，而不是one day day 地在写bugs与修bugs之间疲于奔命。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.02:编译和运行是彼此独立的步骤</title>
    <url>/2022/12/26/rust_docs/ch_01_02_hello_world/</url>
    <content><![CDATA[<h5 id="编译和运行是彼此独立的步骤"><a href="#编译和运行是彼此独立的步骤" class="headerlink" title="编译和运行是彼此独立的步骤"></a>编译和运行是彼此独立的步骤</h5><p>你刚刚运行了一个新的程序，所以让我们来检查一下这个过程的每一个步骤。</p>
<p>在运行Rust程序之前，你必须通过rustc命令，用Rust编译器来编译这个它，并传入你源代码文件的名字，比如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> rustc main.rs</span><br></pre></td></tr></table></figure>

<p>如果你有C或者C++的技术背景，你可以视作像gcc 或者clang。在编译成功之后，Rust 会输出一个二进制可执行文件。</p>
<p>对于Linux,macOS和PowerShell on Windows,执行ls的shell命令之后，你就可以看到这个可执行文件。对于Linux，macOS，你可以看到两个文件。对于PowerShell on Windows,你会看到和使用CMD一样的三个文件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">main main.rs</span><br></pre></td></tr></table></figure>

<p>在Windows的CMD，输入命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">dir</span> /B %= the /B option says to only show the file names =%</span><br><span class="line">main.exe</span><br><span class="line">main.pdb</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>这显示出以.rs为扩展名的源代码文件和可执行文件(main.exe on Windows, but main on all other platforms),并且，当使用Windows，一个文件包括了debugging信息的.pdb扩展名。到此，你可以开始运行main 或者main.exe文件，如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ./main <span class="comment"># or .\main.exe on Windows</span></span><br></pre></td></tr></table></figure>

<p>如果main.rs是你的”Hello,world!”程序，这行将打印出”Hello,world!”到你的屏幕。</p>
<p>如果你更加熟悉动态语言，如Ruby,Python, JavaScript, 你也许不习惯将编译和运行分为两个单独的步骤。Rust是一个预编译(ahead-of-time compiled)语言，代表你可以编译一个程序并且给可执行文件其他人，并且他们可以直接运行，不需要安装Rust。如果你给某人一个a.rb, .py, .js文件，他们需要安装一个Ruby,Python 或者JavaScript 实现(运行环境)。不过这些语言中，只需要一句命令就可以编译和运行程序。所有的事都是语言设计上的取舍。</p>
<p>仅仅使用rustc编译简单程序是没有问题的。但是随着你的项目发展，你会想要管理所有的选项，使得更简单地共享你的代码。接下来，我们将介绍给你一个叫做Cargo的工具，它将帮助你编写真实世界的Rust程序。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 01.03:养成使用Cargo习惯</title>
    <url>/2022/12/27/rust_docs/ch_01_03_hello_cargo/</url>
    <content><![CDATA[<h5 id="养成使用Cargo习惯"><a href="#养成使用Cargo习惯" class="headerlink" title="养成使用Cargo习惯"></a>养成使用Cargo习惯</h5><p>对于简单的项目，和rustc相比，Cargo不能提供多大的价值，但是对于复杂的项目，安装了很多crates, 它将会证明它的价值所在。让Cargo来协调构建工作会变得容易更多。</p>
<p>即使hello_cargo这么简单的项目，它现在使用了很多你之后的Rust生涯将会用到的使用工具。其实，要在任何已存在的项目上工作时，可以使用如下的命令通过Git拿到代码，移动到你的projects目录，并构建：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git clone example.org/someproject</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> someproject</span><br><span class="line"><span class="variable">$</span> cargo build</span><br></pre></td></tr></table></figure>

<p>更多关于Cargo详情，请查看Cargo 文档(<a href="https://doc.rust-lang.org/cargo/">https://doc.rust-lang.org/cargo/</a>)</p>
<p><strong>总结</strong></p>
<p>对于你的Rust之旅，你已经有一个很棒的开始了！本章你已经学会了如何：</p>
<ul>
<li>使用rustup安装最新稳定版Rust</li>
<li>更新到新版的Rust</li>
<li>打开本地安装的文档</li>
<li>直接通过rustc编写并运行”Hello,world!”程序</li>
<li>使用Cargo创建并运行项目</li>
</ul>
<p>是时候通过构建更实质性的程序来熟悉写Rust代码了。所以在Chapter 2,我们将构建一个猜数字的游戏程序。如果你更想从学习Rust常用的编程概念开始，请阅读Chapter 3，接着回来看Chapter 2.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 02.00:猜测正确后退出</title>
    <url>/2022/12/28/rust_docs/ch_02_00_guessing_game_tutorial/</url>
    <content><![CDATA[<h5 id="猜测正确后退出"><a href="#猜测正确后退出" class="headerlink" title="猜测正确后退出"></a>猜测正确后退出</h5><p>让我们增加一个break语句，在用户才对时退出游戏：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在You win!之后增加一行break;，用户猜对了神秘数字之后会退出循环。退出循环也意味着退出程序，因为循环是main最后一部分。</p>
<p><strong>处理无效输入</strong></p>
<p> 为了进一步使得游戏表现更好，而不是当用户输入无效数字就崩溃，需要忽略无效输入，让用户继续猜。可以通过修改guess将String转换为u32那部分代码来实现，如Listing 2-5:</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">    .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>

<p>Listing 2-5 Ignoring a non-number guess and asking for another guess instead of crashing the program</p>
<p>我们将expect调用换成match语句，以从遇到错误就崩溃变为处理错误。需知parse返回一个Result类型，而Result是一个用于Ok或Err成员的枚举。这里使用的match表达式，和之前处理cmp方法返回Ordering时用的一样。</p>
<p>如果parse不能将字符串转换一个数字，它会返回一个包含更多错误信息的Err。Err值不能匹配第一个match分支的Ok(num)模式，但是会匹配第二个分支Err(_)模式：_是一个通配符值，本例中用来匹配所有的Err值，不管其中有任何信息。所以程序会执行第二个分支的动作，continue 意味着进入loop的下一次循环，请求另一个猜测。这样程序就有效地忽略了parse可能遇到的所有错误！</p>
<p>现在所有的事情都是我们期待的了，让我们试试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling guessing_game v0.<span class="number">1.0</span> (file:///projects/guessing_game)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">4.45</span>s</span><br><span class="line">     Running `target/debug/guessing_game`</span><br><span class="line">Guess the number!</span><br><span class="line">The secret number is: <span class="number">61</span></span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">10</span></span><br><span class="line">You guessed: <span class="number">10</span></span><br><span class="line">Too small!</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">99</span></span><br><span class="line">You guessed: <span class="number">99</span></span><br><span class="line">Too big!</span><br><span class="line">Please input your guess.</span><br><span class="line">foo</span><br><span class="line">Please input your guess.</span><br><span class="line"><span class="number">61</span></span><br><span class="line">You guessed: <span class="number">61</span></span><br><span class="line">You win!</span><br></pre></td></tr></table></figure>

<p>牛逼！再有一个小的修改，就能完成猜数字游戏了：还记得程序依然会打印出秘密数字吗？那个是为了便于测试，但是它破坏游戏性。让我们删掉这个打印语句吧。Listing 2-6是最终版本的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 2-6 Complete guessing game code</p>
<p><strong>总结</strong></p>
<p>至此，你成功地构建了猜数字游戏。恭喜你！</p>
<p>这个项目是一个通过动手实践，向你介绍了很多Rust新概念：let,match,函数，使用外部crate等等。在接下来的章节中，你将会学习这些概念的细节。第三章介绍大部分程序语言都有的概念，比如变量，数据类型和函数，以及如何在Rust中使用他们。第四章探索所有权(owership)，一个特性，使得Rust与其他语言不同的特性。第五章讨论结构体和方法的语法，第六章介绍枚举如何工作。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.00:关键字(Keywords)</title>
    <url>/2022/12/29/rust_docs/ch_03_00_common_programming_concepts/</url>
    <content><![CDATA[<h5 id="关键字-Keywords"><a href="#关键字-Keywords" class="headerlink" title="关键字(Keywords)"></a>关键字(Keywords)</h5><p>Rust语言有一个关键字集合，这些关键字预留给语言本使用，和其他大部分语言一样。牢记在心，你不能使用这些单词作为变量名或者函数名。大部分的关键字有其特殊的意义，而且你会用这些关键字来做各种各样的任务在Rust程序里。一些关键词目前没有相应的功能，是为了将来可能添加的功能预留的。可以在Appendix A(<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html)%E6%9F%A5%E7%9C%8B">https://doc.rust-lang.org/book/appendix-01-keywords.html)查看</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.01:隐藏(Shadowing)</title>
    <url>/2022/12/29/rust_docs/ch_03_01_variables_and_mutability/</url>
    <content><![CDATA[<h5 id="隐藏-Shadowing"><a href="#隐藏-Shadowing" class="headerlink" title="隐藏(Shadowing)"></a>隐藏(Shadowing)</h5><p>如你在第二章猜数字游戏教程所见，你可以声明一个新的变量用和前面声明的变量同样的名字。Rustaceans说第一个变量被第二个隐藏(Shadowing)了，意思是第二个变量的值是在程序使用时才看到的。我们可以shadow一个变量使用相同的变量名，并重复地使用let关键字，如下：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先绑定了5给x。然后重新用let x&#x3D;隐藏了x，使得原来的值加1，所以变量的值变为了6。然后，在内部作用域，第三次let声明x, 将之前的值乘以2得到12。当内部作用结束，内部的隐藏结束，并且x变回6。当我们运行这个程序，它运行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:///projects/variables)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">0.31</span>s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: <span class="number">12</span></span><br><span class="line">The value of x is: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>隐藏不同于将变量标记为mut，因为如果我们意外地尝试重新分配这个变量不使用let关键字，我们会得到一个编译错误。通过使用let，我们可以对一个值执行一些转换，但在这些转换完成后，变量是不可变的。</p>
<p>其他的mut和shadowing之间的不同之处是因为当我们再次使用let关键字，我们实际上创建了一个新的变量。例如，假如我们的程序要求用户输入空格来显示文本之间需要多少空格，然后我们希望将输入存储为数字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先spaces变量是一个string类型，然后第二个spaces变量是数字类型。因此shadowing使我们不需使用不同的变量名，如space_str 和 space_num；然而，如果我们尝试使用mut，如下，我们会得到一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误说我们不被允许转变变量的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.<span class="number">1.0</span> (file:<span class="comment">///projects/variables)</span></span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">14</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     spaces = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;<span class="type">str</span>`, found `<span class="type">usize</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `variables` due to previous error</span><br></pre></td></tr></table></figure>

<p>现在，我们探索了变量是如何工作的，我们还有更多的数据类型等着你呢！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.02:无效的数组元素访问</title>
    <url>/2022/12/29/rust_docs/ch_03_02_data_types/</url>
    <content><![CDATA[<h6 id="无效的数组元素访问"><a href="#无效的数组元素访问" class="headerlink" title="无效的数组元素访问"></a>无效的数组元素访问</h6><p>让我们看看发生了什么，如果你尝试访问数组的一个元素，这个元素在数组的结尾之后呢。运行如下的代码，类似于第二章猜数字游戏，从用户输入那里获取数组索引：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The value of the element at index &#123;&#125; is: &#123;&#125;&quot;</span>,</span><br><span class="line">        index, element</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译成功。如果运行这段代码使用cargo run然后输入0，1，2，3，4，这个程序会打印出在数组内对应索引的值。如果你输入一个超出范围的数字，比如10，你会看到输出如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;index out of bounds: the len is 5 but the index is 10&#x27;</span>, src/main.rs:<span class="number">19</span>:<span class="number">19</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你使用这个无效的值索引的时候，程序的结果是在运行时间的错误。程序退出并返回错误信息，并且没有运行最后的println!语句。当你试图用一个索引访问一个元素，Rust会检查你指定的这个索引是否会超过数组的长度。如果索引与数组长度相同或者更大，Rust就会死给你看。这个检查在运行时间，特别在这个例子中，因为编译器在编译完之后就不可能知道用户会输入什么。</p>
<p>这是一个Rust的内存安全原则示例的表现。在很多底层代码语言中，当你提供一个错误的索引，这种类型的检查它们是不做的，无效内存就会被访问，会导致你不知道你到底访问到了别的什么奇奇怪怪的值。Rust项目中会立即退出，而不是允许你继续访问，从而保护你面授此类错误的影响。第九章将会讨论Rust的错误处理。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.03:函数(Functions)</title>
    <url>/2022/12/29/rust_docs/ch_03_03_how_functions_work/</url>
    <content><![CDATA[<h4 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h4><p>函数在Rust代码中是很普遍的。你已经看了在语言中最重要的函数之一：main函数，是很多程序的入口。你也看到了fn关键字，它允许你声明一个新的函数。</p>
<p>Rust代码中的函数和变量使用snake case的代码风格，所有的单词小写并用下划线隔开。这里有一个程序包含了一个函数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let x = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，five函数没有参数并定义了返回值类型，不过函数体只有单单一个5，因为它是一个表达式，可以返回我们想要的值。</p>
<p>让我们看看另外一个例子：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码，会产生一个如下的错误：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cargo run</span><br><span class="line">   Compiling functions v0.<span class="number">1.0</span> (file:///projects/functions)</span><br><span class="line">error[<span class="type">E0308</span>]: mismatched types</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">7</span>:<span class="number">24</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">7</span> | fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">  |    <span class="literal">--------</span>            ^^^ expected `i32`, found `()`</span><br><span class="line">  |    |</span><br><span class="line">  |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line"><span class="number">8</span> |     x + <span class="number">1</span>;</span><br><span class="line">  |          - help: consider removing this semicolon</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0308`.</span><br><span class="line">error: could not compile `functions` due to previous error</span><br></pre></td></tr></table></figure>

<p>主要的错误信息”mismatched types”揭示了这段代码的核心问题所在。定义函数plus_one，然后说要返回一个i32，但是语句不会计算得到一个值，使用单位类型()表示不返回值。因为不返回值与函数返回一个i32类型的值矛盾，从而出现一个错误。在输出中，Rust提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这会修复这个错误。</p>
<p>正确的代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.04:注释(Comments)</title>
    <url>/2022/12/29/rust_docs/ch_03_04_comments/</url>
    <content><![CDATA[<h4 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释(Comments)"></a>注释(Comments)</h4><p>所有的程序设计人员努力使他们的代码更容易理解，但是有时候额外的解释是有必要的。在这种情况下程序设计人员在源代码中留下注释(comments)，编译器会忽略这些注释，但是人阅读源码会发现它很有用。</p>
<p>这里有一个简单的注释例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// So we’re doing something complicated here, long enough that we need</span></span><br><span class="line"><span class="comment">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span></span><br><span class="line"><span class="comment">// explain what’s going on.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释可以放在代码行结尾：</p>
<p>src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>; <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是你经常看到更多是如下的格式，在代码的上方的单独一行注释：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// I’m feeling lucky today</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lucky_number</span> = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 也有其他类型的注释，文档注释(documentation comments)，详细在第14章的”Publishing a Crate to Crates.io” 部分介绍。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03.05:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_03_05_control_flow/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>你做到了！这是相当大的一章：你学习了关于variables, scalar and compound data type, functions, comments, if expressions, and loops! 讨论并练习这些概念。尝试构建如下的程序：</p>
<ul>
<li>相互转换摄氏与华氏温度(Convert temperatures between Fahrenheit and Celsius.)</li>
<li>生成n阶斐波那契数列(Generate th nth Fibonacci number.)</li>
<li>打印圣诞颂歌词，并利用歌词中的重复部分(编写循环)(Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” taking advantage of the repetition in the song.)</li>
</ul>
<p>当你准备好继续的时候，让我们讨论一个其他语言中不常见的概念：所有权(ownership)</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.01:返回值与作用域(Return Values and Scope)</title>
    <url>/2022/12/29/rust_docs/ch_04_01_what_id_ownership/</url>
    <content><![CDATA[<h4 id="返回值与作用域-Return-Values-and-Scope"><a href="#返回值与作用域-Return-Values-and-Scope" class="headerlink" title="返回值与作用域(Return Values and Scope)"></a>返回值与作用域(Return Values and Scope)</h4><p>返回值也可以转移所有权。Listing 4-4展示了一个示例，与Listing4-3一样带有类似的注释。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                        <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                        <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line">  <span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                             <span class="comment">// return value into the function</span></span><br><span class="line">                                             <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">                                             <span class="comment">// moves out to the calling</span></span><br><span class="line">                                             <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a String and returns one</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">                                                      <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-4: Transferring ownership of return values</p>
<p>变量的所有权总是遵循相同的模式：将赋值给另一个变量时移动它。当持有堆中数据的变量离开作用域时，其值将通过drop被清理，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都穿进去再返回来就有点烦人了，除此之外，我们可能想返回函数中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如Listing 4-5。</p>
<p>Filename：src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 4-5: Returning ownership of parameters</p>
<p>但是，对于一个应该是普通的概念来说，这太多的仪式和大量的工作。幸运的是，Rust有一个特性，可以在不用转移所有权的情况下使用值，它叫做引用(references)。</p>
<p>接下来将讲”引用和借用(References and Borrowing)”</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.02:引用的规则(The Rules of References)</title>
    <url>/2022/12/29/rust_docs/ch_04_02_references_and_borrowing/</url>
    <content><![CDATA[<h4 id="引用的规则-The-Rules-of-References"><a href="#引用的规则-The-Rules-of-References" class="headerlink" title="引用的规则(The Rules of References)"></a>引用的规则(The Rules of References)</h4><p>让我们来重新概况一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.03:总结</title>
    <url>/2022/12/29/rust_docs/ch_04_03_slices/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所有权、借用和slice这些概念让Rust程序在编译时保证内存安全。Rust语言提供了跟其他系统编程语言相同的方式来控制你使用内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无需额外编写和调试相关的控制代码。</p>
<p>所有权系统影响了Rust中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书余下的内容。让我们开始第五章吧，来看看如何将多份数据组合进一个struct中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.00:Using Structs to Structure Related Data</title>
    <url>/2022/12/29/rust_docs/ch_05_00_structs/</url>
    <content><![CDATA[<h4 id="Using-Structs-to-Structure-Related-Data"><a href="#Using-Structs-to-Structure-Related-Data" class="headerlink" title="Using Structs to Structure Related Data"></a>Using Structs to Structure Related Data</h4><p>struct or structure 是一个自定义的数据类型，允许你包装和命名多个相关联的值，从而形成一个有意义的组合。如果你熟悉一门面向对象语言，struct就像对象中的数据属性。在本章中，我们会对元组和结构体进行对比和对照。还将演示如何定义和实现实例化结构体，并讨论如何定义关联函数，特别是被称为方法的那种关联函数，以指定与结构体类型相关的行为。你可以在程序中基于结构体和枚举(enum)（在第六章中介绍）创建新类型，以充分利用Rust的编译时类型检查。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 04.00:Understanding Ownership</title>
    <url>/2022/12/29/rust_docs/ch_04_00_understanding_ownership/</url>
    <content><![CDATA[<h4 id="Understanding-Ownership"><a href="#Understanding-Ownership" class="headerlink" title="Understanding Ownership"></a>Understanding Ownership</h4><p>Ownership 是Rust最独特的特性，并且对剩下的部分有着深刻的意义。它能让Rust在不需要垃圾回收(garbage collection)就能保证内存安全，所以能够很好地理解owership是如何工作的是非常重要的。在本章，我们将讲和ownership关联的一些特性：borrowing, slice, 和Rust如何在内存中布局数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.01:结构体数据的所有权(Ownership of Struct Data)</title>
    <url>/2022/12/29/rust_docs/ch_05_01_defining_and_instantiating_structs/</url>
    <content><![CDATA[<h4 id="结构体数据的所有权-Ownership-of-Struct-Data"><a href="#结构体数据的所有权-Ownership-of-Struct-Data" class="headerlink" title="结构体数据的所有权(Ownership of Struct Data)"></a>结构体数据的所有权(Ownership of Struct Data)</h4><p>在Listing 5-1中的<code>User</code>结构体定义中，我们使用了自身拥有所有权的String类型而不是&amp;str字符串slice类型。这是一个有意为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话数据也是有效的。可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期(lifetimes)，这是一个第十章会讨论的Rust功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不是指定生命周期将是无效的，比如这样：</p>
<p>filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会控诉它需要生命周期标识符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling structs v0.<span class="number">1.0</span> (file:<span class="comment">///projects/structs)</span></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">15</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> ~     username: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">4</span>:<span class="number">12</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     email: &amp;<span class="type">str</span>,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> ~ <span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line"><span class="number">2</span> |     active: <span class="type">bool</span>,</span><br><span class="line"><span class="number">3</span> |     username: &amp;<span class="type">str</span>,</span><br><span class="line"><span class="number">4</span> ~     email: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `structs` due to <span class="number">2</span> previous errors=</span><br></pre></td></tr></table></figure>

<p>第十章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们使用像String这类拥有所有权的类型来替代&amp;str这样的引用以修正这个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.02:An Example Program Using Structs</title>
    <url>/2022/12/29/rust_docs/ch_05_02_example_structs/</url>
    <content><![CDATA[<h4 id="An-Example-Program-Using-Structs"><a href="#An-Example-Program-Using-Structs" class="headerlink" title="An Example Program Using Structs"></a>An Example Program Using Structs</h4><p>为了理解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将通过使用单个变量开始，然后重构这个程序，直到用结构体替代它。</p>
<p>让我们用cargo创建一个新的项目叫做<code>rectangles</code>的二进制程序，它获取以像素为单位的矩形的宽度和高度，并计算出矩形的面积。Listing 5-8 展示一个简短的程序：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把<code>dbg!</code>放在表达式放在<code>30 * scale</code>周围，以为你<code>dbg!</code>返回表达式的值的所有权，所以width字段将获得相同的值，就像我们在这里没有<code>dbg!</code>调用一样。我们不希望dbg!拥有rect1的所有权，所以我们在下一次调用dbg!时传递一个引用。下面是这个例子的输出结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.<span class="number">1.0</span> (file:<span class="comment">///projects/rectangles)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.61</span>s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">[src/main.rs:<span class="number">10</span>] <span class="number">30</span> * scale = <span class="number">60</span></span><br><span class="line">[src/main.rs:<span class="number">14</span>] &amp;rect1 = Rectangle &#123;</span><br><span class="line">    width: <span class="number">60</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到第一条输出来自src&#x2F;main.rs第10行，我们正在调用表达式<code>30 * scale</code>，其结果值是60(为整数实现的Debug格式化是只打印它们的值)。在src&#x2F;main.rs第14行的dbg!调用输出&amp;rect1的值，即<code>Rectangle</code>类型。<code>dbg!</code>宏确实很有用。</p>
<p>除了<code>Debug</code>trait，Rust还为我们提供了很多通过derive属性来使用的trait，它们可以为我们的自定义类型增加实用的行为。这些trait和行为被列举在附录C(Appendix C)。第十章会介绍如何通过自定义行为来实现这些trait，同时还有如何创建你自己的trait。除了derive之外，还有很多属性；更多信息见”Rust Reference”的Attribute部分。</p>
<p>我们的<code>area</code>函数是非常特殊的，它只计算长方形的面积。如果这个行为与<code>Rectangle</code>结构体再结合得更紧密一些就更好了，因为它不能用于其他类型。现在让我们看看如何继续重构这些代码，来将<code>area</code>函数协调进<code>Rectangle</code>类型定义的<code>area</code>方法中。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 05.03:总结(Summary)</title>
    <url>/2022/12/29/rust_docs/ch_05_03_method_syntax/</url>
    <content><![CDATA[<h4 id="总结-Summary"><a href="#总结-Summary" class="headerlink" title="总结(Summary)"></a>总结(Summary)</h4><p>结构体让你创建自定义的类型在你的domain中。通过使用结构体，你可以将数据关联起来，使得它看起来更加清晰。在impl块内，你可以定义函数并关联你的类型，而且方法是一个很好的关联方式，它让你的结构体有了可以指定它特定行为的能力。</p>
<p>但是结构体不是唯一的方式来创建自定义类型：让我们转到Rust的枚举(enum)特性来，为你的工具箱再添加一个工具。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.00:Enums and Pattern Matching</title>
    <url>/2022/12/29/rust_docs/ch_06_00_enums_and_pattern_matching/</url>
    <content><![CDATA[<h4 id="Enums-and-Pattern-Matching"><a href="#Enums-and-Pattern-Matching" class="headerlink" title="Enums and Pattern Matching"></a>Enums and Pattern Matching</h4><p>本章中，我们讲述枚举(enumerations)，也称作enums。枚举允许你通过列举可能的成员(variants)来定义一个类型。首先，我们会定义并使用一个枚举来展示它是如何连同数据一起编码信息的。接下来，我们会探索一个特别有用的枚举，叫做<code>Option</code>，它代表一个值，要么是某个值要么是什么都不是。然后会讲到<code>match</code>表达式中使用模式匹配，针对不同的枚举值编写相应要执行的代码。然后会介绍<code>if let</code>，另一个简洁方便处理代码中枚举的结构。</p>
<p>枚举是一个很多语言都有的功能，不过不同语言中其功能各不相同。Rust的枚举与F#，OCaml和Haskell这样的函数式编程语言中的代数数据类型(olgebraic data types)最为相似。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.02:通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</title>
    <url>/2022/12/29/rust_docs/ch_06_02_match/</url>
    <content><![CDATA[<h4 id="通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder"><a href="#通用模式和-占位符-Catch-all-Patterns-and-the-Placeholder" class="headerlink" title="通用模式和_占位符(Catch-all Patterns and the _ Placeholder)"></a>通用模式和_占位符(Catch-all Patterns and the _ Placeholder)</h4><p>使用枚举，我们希望对一些特定的值采取特殊操作，而对其他的值采用默认操作。想象我们正在玩一个游戏，如果你掷出一个骰子的值为3，角色不会移动，而是会得到一顶新奇的帽子。如果你掷出了7，你的角色将会失去新奇的帽子。对于其他的数值，你的角色会在棋盘上移动想的格子。这是一个实现了上述逻辑的<code>match</code>。骰子的结果是硬编码而不是一个随机值，其他的逻辑部分使用了没有函数体的函数来表示，实现它们超出了本例的范围：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        other =&gt; <span class="title function_ invoke__">move_player</span>(other),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前两个分支，匹配模式是字面值3和7，最后一个分支则涵盖了所有其他可能性的值，模式使我们命名为<code>other</code>的一个变量。<code>other</code>分支的代码通过将其传递给<code>move_player</code>函数来使用这个变量。</p>
<p>即使我们没有列出<code>u8</code>所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。这种通配模式满足了<code>match</code>必须穷尽的要求。请注意，我们必须将通过通配分支放在最后，因为模式是按顺序匹配的。如果哦我们在通配分支后添加其他分支，Rust将会警告我们，因为此后的分支永远不会被匹配到。</p>
<p>Rust还提供了一个模式，当我们不想使用通配模式的值时，请使用<code>_</code>，这是一个特殊模式，可以匹配任意值而不用绑定到该值。这告诉Rust我们不会使用这个值，所以Rust也不会警告我们存在未使用的变量。</p>
<p>让我们改变游戏规则：现在，当你掷出的值不是3或7的时候，你必须再次掷出。这种情况下我们不需要使用这个值，所以我们改动代码使用<code>_</code>来替代变量<code>other</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子也满足穷举性要求，因为我们在最后一个分支中明确地忽略了其他的值。我们没有忘记任何东西。</p>
<p>最后，我们再次改动游戏规则，如果投掷出3或者7以外的值，你的回合将无事发生。我们可以使用单元值(unit value：就是空的tuple，在”The Tuple Type”部分有提及)作为<code>_</code>分支的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们明确告诉Rust我们不会使用与前面模式不匹配的值，并且这种情况下我们不想运行任何代码。</p>
<p>更详细的模式匹配相关我们将会在Chapter 18进行讲解。目前，我们继续讨论<code>if let</code>语法，这在<code>match</code>表达式有点冗长的情况下比较有用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.01:The Option Enum and Its Advantages Over Null Values</title>
    <url>/2022/12/29/rust_docs/ch_06_01_defining_an_enum/</url>
    <content><![CDATA[<h3 id="The-Option-Enum-and-Its-Advantages-Over-Null-Values"><a href="#The-Option-Enum-and-Its-Advantages-Over-Null-Values" class="headerlink" title="The Option Enum and Its Advantages Over Null Values"></a>The Option Enum and Its Advantages Over Null Values</h3><p>这一部分探索学习<code>Option</code>，另外一个标准库的枚举定义。<code>Option</code>类型编码了非常常见的场景，其中可以是某个值，也可以都不是。</p>
<p>例如，如果请求一个包含项的列表的第一个值，会得到一个值，如果请求一个空的列表，就什么也不会得到。从类型系统的角度来表达这个概念意思就是编译器需要检查是否处理了所有应该处理的情况，这样就可以避免在其他语言中非常常见的bug.</p>
<p>编程语言的设计通常考虑的是包含哪些特性，但是你排除的特性也很重要。Rust没有许多其他语言所具有的null特性。<code>Null</code>是一个值，表示什么也没有。在带有null特性的语言中，变量总是可以处于两种状态之一：null 或 not-null.</p>
<p>Null的发明者Tony Hoare在他2009年的报告”Null Reference: The Billon Dollar Mistake”中这样说：</p>
<blockquote>
<p>我称之为十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误，漏洞和系统崩溃，在之后的四十多年中造成了十亿美元的苦痛和伤害。</p>
</blockquote>
<p>空值的问题在于，如果你试图将空值用作非空值，会出现某种形式的错误。因为空和非空的属性到处都是，非常容易出现这类错误。</p>
<p>然而，null试图表达的概念仍然是有用的：null是当前由于某种原因无效或者不存在的值。</p>
<p>问题不在于概念，而在于具体的实现。因此，Rust没有空值，但它有一个枚举，可以编码值存在或者不存在的概念。这个枚举就是<code>Option&lt;T&gt;</code>，它由标准库定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Option&lt;T&gt;</code>枚举非常有用，以至于它被包含在relude中；你不需要将它显式地引入作用域。另外，它的成员也是如此（被包含在prelude中），可以不需要<code>Option::</code>前缀来使用<code>Some</code>和<code>None</code>。即便如此<code>Option&lt;T&gt;</code>也仍是常规的枚举，<code>Some&lt;T&gt;</code>和<code>None</code>仍是<code>Option&lt;T&gt;</code>的成员。</p>
<p><code>&lt;T&gt;</code>语法是我们还没讲到的Rust特性。它是一个泛型参数，在Chapter 10我们将会详细讲解。目前，你需要知道的就是<code>&lt;T&gt;</code>意味着<code>Option</code>枚举的<code>Some</code>成员可以包含任意类型的数据，同事每一个用于<code>T</code>位置的具体类型使得<code>Option&lt;T&gt;</code>整体作为不同的类型。这里是一些包含数字类型和字符串类型<code>Option</code>值的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some_number</code>的类型是<code>Option&lt;i32&gt;</code>。<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>，是不同的类型。因为我们在<code>Some</code>成员中指定了值，Rust可以推断出其类型。对于<code>absent_number</code>，Rust需要我们指定<code>Option</code>整体的类型，因为编译器只通过<code>None</code>值无法推断出<code>Some</code>成员保存的值的类型。这里我们告诉Rust我们需要<code>absent_number</code>的类型是<code>Option&lt;i32&gt;</code>。</p>
<p>当我们有一个<code>Some</code>值，我们就知道存在一个值，这个值保存在<code>Some</code>中。当我们有一个值<code>None</code>，在某种意义上，它跟空值是有相同的意义：并没有一个有效的值。那么<code>Option&lt;T&gt;</code>为什么就比Null要好呢？</p>
<p>简单来说，因为<code>Option&lt;T&gt;</code>和<code>T</code>（<code>T</code>可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用<code>Option&lt;T&gt;</code>。例如：这段代码不能编译，因为它尝试将<code>Option&lt;i8&gt;</code>与<code>i8</code>相加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们运行这段代码，我们会得到一个错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling enums v0.1.0 (file:///projects/enums)</span><br><span class="line">error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`</span><br><span class="line"> --&gt; src/main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line">  = help: the following other types implement trait `Add&lt;Rhs&gt;`:</span><br><span class="line">            &lt;&amp;&#x27;a f32 as Add&lt;f32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a f64 as Add&lt;f64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i128 as Add&lt;i128&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i16 as Add&lt;i16&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i32 as Add&lt;i32&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i64 as Add&lt;i64&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a i8 as Add&lt;i8&gt;&gt;</span><br><span class="line">            &lt;&amp;&#x27;a isize as Add&lt;isize&gt;&gt;</span><br><span class="line">          and 48 others</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `enums` due to previous error</span><br></pre></td></tr></table></figure>

<p>铛!铛!铛!事实上，这个错误意味着Rust不知道如何将<code>i8</code>和<code>Option&lt;i8&gt;</code>相加，因为它们是不同类型。在Rust中，当我们有一个值像<code>i8</code>，编译器将会确保我们总是有一个有效的值。我们可以自信地使用而无需做空检查。只有当使用<code>Option&lt;i8&gt;</code>(或者任何用到的类型)我们需要担心可能没有一个有效值，并且编译器将会确保我们在使用值之前处理了空的情况。</p>
<p>换句话说，你必须将<code>Option&lt;T&gt;</code>转换成<code>T</code>之后才能对<code>T</code>进行运算。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空，但实际上是空的情况。</p>
<p>消除错误地假设非空值的风险有助于你对代码更有信心。为了有一个可能为空的值，你必须显式地使用<code>Option&lt;T&gt;</code>。然后，在使用该值时，需要显式地处理值为空的情况。任何地方，一个值不是<code>Option&lt;T&gt;</code>类型，你都可以放心地假设他不是null。这是Rust有意为之的设计决定，目的就是限制null的滥用，以增加Rust代码的安全性。</p>
<p>所以，当你有一个类型为<code>Option&lt;T&gt;</code>的值时，你如何从<code>Some</code>变量中获得<code>T</code>的值呢？<code>Option&lt;T&gt;</code>枚举有大量很有用的方法适用于各种情况；你可以查看它的文档(<a href="https://doc.rust-lang.org/std/option/enum.Option.html)%E3%80%82%E7%86%9F%E6%82%89%60Option">https://doc.rust-lang.org/std/option/enum.Option.html)。熟悉`Option</a><T>&#96;上的方法将对你的Rust之旅很有用哦！</p>
<p>通常，为了使用<code>Option&lt;T&gt;</code>值，你需要有处理每个变量的代码。你希望一些代码只在具有<code>Some&lt;T&gt;</code>值时运行，并且允许这些代码使用内部的<code>T</code>。你希望如果有个<code>None</code>值时运行一些其他的代码，而且这些代码也没有一个<code>T</code>的有效值。<code>match</code>表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 06.03:总结</title>
    <url>/2023/05/16/rust_docs/ch_06_03_if_let/</url>
    <content><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们学习了如何使用枚举创建自定义类型。我们也展示了标准库的<code>Option&lt;T&gt;</code>类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据你需要处理多少种情况来选择使用<code>mathc</code>或者<code>if let</code>来提取或者使用这些值。</p>
<p>你的Rust程序现在能够使用结构体和枚举在你自己的作用域内表现其内容了。在你的API中使用定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。</p>
<p>为了提供一个有条理的API给你的用户，它使用起来很简单易懂，值暴露了你的用户需要的东西，现在我们准备开始学习Rust的模块。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.00:使用包、Crate和模块管理不断增长的项目</title>
    <url>/2023/05/18/rust_docs/ch_07_00_managing_growing_projects_with_packages_crates_and_modules/</url>
    <content><![CDATA[<h2 id="使用包、Crate和模块管理不断增长的项目"><a href="#使用包、Crate和模块管理不断增长的项目" class="headerlink" title="使用包、Crate和模块管理不断增长的项目"></a>使用包、Crate和模块管理不断增长的项目</h2><p>当你编写大型程序时，组织代码将变得越来越重要。通过相关功能进行分组，并将具有不同特性的代码分开，你将可以清楚地在哪里可以找到现实特定特性的代码，以及在哪里可以更改一个特性的工作方式。</p>
<p>到目前为止，我们编写的代码都只在一个文件中的一个模块中。 随着项目不断增长，你应该通过多个模块和多个文件来组织拆分你的代码。一个包可以包含多个二进制crates和一个可选的crate程序库。随着你的包的增长，你可以将部分提取到单独的crates使它变成外部依赖。本章涵盖了所有这些技巧。对于由一组相互关联的包组成的非常大的项目，Cargo提供了工作区(workspaces)，我们将在第14章”Cargo Workspaces”部分学习。</p>
<p>我们还将讨论封装实现的细节，这让你可以高水平重用代码：一旦你实现了一个操作，其他代码可以通过代码的公共接口调用，无需知道你的实现过程是如何运作。编写代码的方式定义了那些部分是其他代码使用的公共部分，那些代码是你保留更改权利的私有实现细节。这是另一种限制，减少你必须记住项目内容细节的数量的方法。</p>
<p>这里还一个相关的概念是作用域(scope)：代码所在的嵌套上下文有一组定义”in scope”的名称。当你阅读，编写和编译代码，程序设计师和编译器需要知道模块，常量或者其他有意义的项。你可以创建作用域并改变那些名称再作用域内还是在作用域外。同一个作用域不能拥有两个相同名称的项；可以使用一些工具来解决名称冲突。</p>
<p>Rust有许多特性允许你来管理你的代码组织结构，包括那些内容可以被公开，那些内容作为私有部分，以及程序每个作用域中的名字。这些功能。有时被称为”模块系统(the module system)”，包括：</p>
<ul>
<li>包(Packages)：Cargo的一个功能，它允许你构建，测试和分享crate。</li>
<li>Crates：一个模块的树形结构，它形成了库或者二进制项目。</li>
<li>模块(Modules)和Use：允许你控制组织结构的作用域和路径的私有性。</li>
<li>路径(path)：一个命名例如结构体，函数或模块等项的方式。</li>
</ul>
<p>在本章，我们将涵盖所有这些特性，讨论他们怎样相互作用，并解释如何使用他们管理作用域。最后，你应该对模块系统有一个坚实的理解，并能够像专业人士一样使用作用域！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.01:包和Crates</title>
    <url>/2023/05/18/rust_docs/ch_07_01_packages_and_crates/</url>
    <content><![CDATA[<h2 id="包和Crates"><a href="#包和Crates" class="headerlink" title="包和Crates"></a>包和Crates</h2><p>模块系统的第一部分我们将介绍包和crate。</p>
<p>crate是Rust编译时最小的代码单位。如果你用<code>rustc</code>而不是<code>cargo</code>来编译一个文件(第一章我们这么做)，编译器还是会将那个文件认作一个crate。crate可以包含模块，模块可以定义在其他文件，然后和crate一起编译，我们会在接下来的章节中遇到。</p>
<p>crate有两种形式：二进制项和库。二进制crate可以被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个<code>main</code>函数来定义当程序被执行的时候所需要做的事情。到目前为止，我们所创建的crate都是二进制crate。</p>
<p>库(Library crates) 没有<code>main</code>函数，而且它们不会编译成可执行文件。相反，它们定义了旨在与多个项目共享的功能。例如，我们在第二章用过的<code>rand</code>函数，用来生成随机数。大多数的Rust开发者说的crate指的都是库，这与其他变成语言中的library概念一致。</p>
<p>crate root是一个资源文件，Rust编译器以它为起始点，并组成crate的根模块(我们将在”Defining Modules to Control Scope and Privacy” 部分深度解析)。</p>
<p>包(package)是提供一系列功能的一个或者多个crate。一个包会包含Cargo.toml文件，阐述如何去创建这些crates。Cargo就是一个包含构建你代码的二进制项的包。Cargo也包含这些二进制项所依赖的库。其他项目也能用Cargo库来实现与Cargo命令行程序一样的逻辑。</p>
<p>包可以包含很多二进制(binary) crate，但是最多只能有一个库(library) crate。包无论是一个库(library crate)还是一个二进制库(binary crate)， 至少要包含一个library crate。</p>
<p>让我们来看看创建包的时候会发生什么。首先，我们输入命令<code>cargo new</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new my-project</span></span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> my-project/src</span></span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>运行<code>cargo new</code>之后，我们使用<code>ls</code>查看Cargo创建了什么，在这个项目目录里，Cargo会给我们创建一个Cargo.toml文件，这就是一个包(package)。这里也有一个src目录包含main.rs文件。用编辑器打开Cargo.toml，并且文件内容里面没有提及src&#x2F;main.rs。因为Cargo遵循的一个约定：src&#x2F;main.rs就是一个与包同名的二进制crate的crate根。同样地，Cargo知道如果包目录中包含src&#x2F;lib.rs，则包带有与其同名的库(library) crate。crate根文件将由Cargo传递给<code>rustc</code>来构建库(library)或者二进制(binary)。</p>
<p>这里，我们有一个只包含src&#x2F;main.rs的包，意味着它只含有一个名为<code>my-project</code>的二进制crate。如果一个包同时含有src&#x2F;main.rs和src&#x2F;lib.rs，则它有两个crate：一个二进制(binary)的和一个库(library)，并且名字都与包相同。通过将文件放在src&#x2F;bin目录下，一个包可以拥有多个二进制crate：每个src&#x2F;bin下的文件都会被编译成一个独立的二进制crate。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.02:在模块中对相关代码进行分组(Grouping Related Code in Modules)</title>
    <url>/2023/05/18/rust_docs/ch_07_02_defining_modules_to_control_scope_and_privacy/</url>
    <content><![CDATA[<h4 id="在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules"><a href="#在模块中对相关代码进行分组-Grouping-Related-Code-in-Modules" class="headerlink" title="在模块中对相关代码进行分组(Grouping Related Code in Modules)"></a>在模块中对相关代码进行分组(Grouping Related Code in Modules)</h4><p>模块让我们在crate中组织代码，以提高可读性和易于重用。模块还允许我们控制items的私有性，因为在module中的代码默认是私有的。Private items是内部实现的细节不对外使用。我们可以选择将模块以及其中的items设置为公共的，这样，外部代码就可以使用并依赖于它们。</p>
<p>例如，让我们编写一个提供餐厅服务功能的library crate。我们将会定义函数的签名，但是函数的主题留空，集中于代码的组织，而不是实现一个餐馆。</p>
<p>在餐厅业中，餐馆的某些部分被称为前台(front of house)，其他的部分称为后台(back of house)。前台是顾客所在的空间；这包括主座的顾客的位置，服务员接单和付款，以及调酒师调酒的地方。后台是主厨和厨师们在厨房，洗碗机清理，经历做行政工作。</p>
<p>这样构建我们的crate，我们可以将这些功能组织成嵌套的模块。创建一个新的库(library)命名为<code>restaurant</code>，通过命令<code>cargo new restaurant --lib</code>。输入如下Listing 7-1代码到src&#x2F;lib.rs来定义一些模块和函数签名。这里是前台部分：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-1: A <code>front_of_house</code>module containing other modules that then contain functions</p>
<p>我们用<code>mod</code>关键字定义一个模块(在上面的例子中定义了<code>front_of_house</code>模块)。并用花括号包围模块的主体。在模块内，我们还可以定义其他模块，就像本例子中的<code>hosting</code>和<code>serving</code>模块。模块还可以hold一些定义的其他items，例如structs, enums, constants, traits, 以及Listing 7-1中的函数。</p>
<p>通过使用模块，我们可以将相关的定义分组到一起，并指出他们为什么相关。程序设计者可以通过使用这段代码，更加容易找到他们想要的定义，因为他们可以基于分组来对代码进行导航，而不需要阅读所有的定义。程序设计者向这段代码中添加一个新功能时，他们也会知道代码应该放置在何处，可以保持程序的组织性。</p>
<p>在前面我们提到了，<code>src/main.rs</code>和<code>src/lib.rs</code>叫做crate根。之所以这么叫它们是因为这两个文件中的任何一个内容都在crate模块结构的根组成了一个名为crate的模块，该结构被称为模块树(module tree)。</p>
<p>Listing 7-2 展示了示例Listing 7-1中的模块树(modules tree)的结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">crate</span></span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<p>Listing 7-2: The module tree for the code in Listing 7-1</p>
<p>这个模块树展示了一些模块内嵌到另一个模块；例如，<code>hosting</code>内嵌在<code>front_of_house</code>之中。这个树结构还展示了一些模块是互为兄弟(siblings)的，这意味着它们定义在同一模块中(<code>hosting</code>和<code>serving</code>被一起定义在<code>front_of_house</code>中)。继续沿用家庭关系的比喻，如果一个模块A被包含在模块B中，我们将模块A称为模块B的子模块，B模块为A的父模块。注意，整个模块树都植根于隐式模块名为<code>crate</code>之下。</p>
<p>模块树可能会让你想起计算机上的文件系统的目录树；这是一个非常恰当的比较！就像文件系统中的目录一样，你用模块来组织你的代码。就像文件目录中的文件，我们需要一个方式来找到我们的模块(modules)。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.03:创建公有的结构体和枚举(Making Structs and Enums Public)</title>
    <url>/2023/05/18/rust_docs/ch_07_03_paths_for_referring_to_an_item_the_the_module_tree/</url>
    <content><![CDATA[<h4 id="创建公有的结构体和枚举-Making-Structs-and-Enums-Public"><a href="#创建公有的结构体和枚举-Making-Structs-and-Enums-Public" class="headerlink" title="创建公有的结构体和枚举(Making Structs and Enums Public)"></a>创建公有的结构体和枚举(Making Structs and Enums Public)</h4><p>我们也可以使用<code>pub</code>来指定结构体和枚举为公有，但是这里有一些额外的使用详情需要注意。如果我们在使用<code>pub</code>定义一个结构体，我们使得这个结构体为公有，但是结构体的字段将仍是私有的。我们可以视情况而定让每一个字段成为公有或者私有。在Listing 7-9中，我们定义了一个公有的<code>back_of_house::Breakfast</code>结构体并且<code>toast</code>为公有字段，而<code>seasonal_fruit</code>为私有字段。该模型以餐厅为例，顾客可以选择随餐面包的类型，但是主厨会根据当季水果和库存来搭配什么水果。可选择的水果变化很快，所以顾客不能选择水果，甚至不能看到他们能得到的水果。</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Order a breakfast in the summer with Rye toast</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// Change our mind about what bread we&#x27;d like</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next line won&#x27;t compile if we uncomment it; we&#x27;re not allowed</span></span><br><span class="line">    <span class="comment">// to see or modify the seasonal fruit that comes with the meal</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-9: A struct with some public fields and some private fields</p>
<p>因为<code>toast</code>字段在<code>back_of_house::Breakfast</code>结构体内是公有的，在<code>eat_at_restaurant</code>中我们可以编写并且读到<code>toast</code>字段使用点(.)号。注意，我们不能在<code>eat_at_restaurant</code>中使用<code>seasonal_fruit</code>字段，因为<code>seasonal_fruit</code>字段是私有的。尝试取消注释修改季节水果字段的值，看看会得到什么错误。</p>
<p>同样，注意因为<code>back_of_house::Breakfast</code>有一个私有字段，这个结构体需要提供一个公有的关联函数来构造一个<code>Breakfast</code>实例(这里是名为<code>summer</code>的函数)。如果<code>Breakfast</code>没有这样一个函数，我们就不能在<code>eat_at_restaurant</code>中创建<code>Breakfast</code>实例，因为我们不能在<code>eat_at_rest_aurant</code>中给<code>seasonal_fruit</code>私有字段设置值。</p>
<p>相反地，如果我们设置枚举为公有，它所有的字段都是公有的。我们只需要在<code>enum</code>关键字前面加上<code>pub</code>即可，如Listing 7-10所示：</p>
<p>src&#x2F;lib.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order1</span> = back_of_house::Appetizer::Soup;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">order2</span> = back_of_house::Appetizer::Salad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 7-10: Designating an enum as public makes all its variants public</p>
<p>因为我们设置了<code>Appetizer</code>为公有枚举，我们可以在<code>eat_at_restaurant</code>中使用<code>Soup</code>和<code>Salad</code>成员变量。</p>
<p>除非设置枚举的变量为公开的，否则枚举就没什么用了；在每种情况下都必须使用<code>pub</code>来声明所有枚举变量，这将是很恼人的设计，所以默认情况下枚举的所有变量都是公有的。结构体在字段为私有的情况通常是有用的，所以结构体字段默认遵循所有内容为私有的普遍规则，除非使用<code>pub</code>声明公有。</p>
<p>这里还涉及<code>pub</code>另外一个情况我们没有讨论到，那就是我们最后要讲的模块功能：<code>use</code>关键字。我们将单独介绍<code>use</code>，然后展示如何结合<code>pub</code>和<code>use</code>起来使用。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.04:全局操作符(The Glob Operator)</title>
    <url>/2023/05/18/rust_docs/ch_07_04_bringing_paths_into_scope_with_the_use_key_word/</url>
    <content><![CDATA[<h4 id="全局操作符-The-Glob-Operator"><a href="#全局操作符-The-Glob-Operator" class="headerlink" title="全局操作符(The Glob Operator)"></a>全局操作符(The Glob Operator)</h4><p>如果想将一个路径下所有公有项引入作用域，可以使用指定路径后跟<code>*</code>，glob操作符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<p>这个<code>use</code>语句会将<code>std::collections</code>中定义的所有的公有项引入到当前作用域。使用全局操作符时一定要多加小心！全局操作符会使得我们难以推导作用域中有什么名称和它们是定义在何处。</p>
<p>全局操作符经常用于测试模块<code>tests</code>中，这时会将所有内容引入作用域；我们将在第十一章”How to Write Tests”部分中讲解。全局操作符有时也用于preclude模式；查看”标准库文档”(<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes)%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%E3%80%82">https://doc.rust-lang.org/std/prelude/index.html#other-preludes)了解更多细节。</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 07.05:总结</title>
    <url>/2023/05/18/rust_docs/ch_07_05_separating_modules_into_different_files/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Rust提供了将包分成多个crate，将crate分成模块，以及通过指定绝对或者相对路径从一个模块引用另一个模块中定义的项的方式。你可以指定绝对路径或者相对路径。这个路径可以通过<code>use</code>声明引入到作用域，所以你可以在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加<code>pub</code>关键字使其定义为公有。</p>
<p>接下来，我们来看一些标准库提供的集合数据类型，你可以利用它们写出更漂亮整洁的代码。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.00:常见集合</title>
    <url>/2023/05/18/rust_docs/ch_08_00_common_collections/</url>
    <content><![CDATA[<h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><p>Rust标准库中包含一些非常有用的数据结构叫做结合(collections).大多数其他的数据类型代表一个特殊的值，但是集合可以包含多个值。不像内建的数组和元组类型，这些集合数据指向堆，意味着在编译时不需要知道数据量，并且可以随着程序运行而增加或减少。每一种集合有不同的性能和消耗，并且选择一个合适的集合，对你当前的情景是需要你慢慢学习的技巧。在本章，我们将会讨论三个集合，它们在Rust编程中很常用：</p>
<ul>
<li>vector 允许你一个挨着一个地存储一系列数量的可变的值</li>
<li>string 是一个字符类型的集合。我们之前已经提到过<code>String</code>类型，但是在本章，我们将更加深入地讨论它。</li>
<li>hash map 允许你用一个特定的key关联一个值(value)，它是成为映射的更通用数据结构的一种实现。</li>
</ul>
<p>要学习标准库提供的其他类型的集合，请查看文档<a href="https://doc.rust-lang.org/std/collections/index.html">std::collections</a></p>
<p>我们将要讨论如何创建和更新vectors, strings，和hash map，以及他们每个类型的独特之处。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.01:丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</title>
    <url>/2023/05/18/rust_docs/ch_08_01_vectors/</url>
    <content><![CDATA[<h4 id="丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements"><a href="#丢弃vector-时也会丢弃其所有元素-Dropping-a-Vector-Drops-Its-Elements" class="headerlink" title="丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)"></a>丢弃vector 时也会丢弃其所有元素(Dropping a Vector Drops Its Elements)</h4><p>像其他数据结构一样，当一个vector离开了它的作用域，它就会被释放，如Listing 8-10所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do stuff with v</span></span><br><span class="line">    &#125; <span class="comment">// &lt;- v goes out of scope and is freed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 8-10: Showing where the vector and its elements are droped</p>
<p>当vector被删除时，它的所有内容也会被删除，这意味着它所持有的整数将被清除。借用检查器确保仅在vector本身有效时才使用对向量内容的任何引用。</p>
<p>接下来，我们将学习下一个集合类型：<code>String</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.02:字符串并不简单</title>
    <url>/2023/05/18/rust_docs/ch_08_02_strings/</url>
    <content><![CDATA[<h4 id="字符串并不简单"><a href="#字符串并不简单" class="headerlink" title="字符串并不简单"></a>字符串并不简单</h4><p>总之，字符串是很复杂的。不同的语言会有不同的选择如何将这种复杂性呈现给程序员。Rust选择将String数据的正确处理作为所有Rust程序的默认行为,这意味着程序员必须在处理UTF-8数据上花更多的心思。这个权衡在其他编程语言中暴露了更多字符串的复杂性,但它可以防止你在开发生命周期的后期处理涉及非ASCII字符的错误。<br>好消息是标准库基于String和&amp;str类型提供了许多功能来正确处理这些复杂的情况。确保查看文档中有用的方法,比如在字符串中搜索的contains和用另一个字符串替换字符串的一部分replace。<br>让我们切换到略微简单一点的内容:哈希映射!</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 08.03:总结</title>
    <url>/2023/05/18/rust_docs/ch_08_03_hash_maps/</url>
    <content><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vector、字符串和哈希 map 会在你的程序需要储存、访问和修改数据时帮助你。这里有一些你应该能够解决的练习问题:</p>
<ul>
<li>给定一系列数字，使用 vector 并返回这个列表的中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希 map 会很有帮助）。</li>
<li>将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加 “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码！</li>
<li>使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字典序排列的列表。</li>
</ul>
<p>标准库 API 文档中描述的这些类型的方法将有助于你进行这些练习！</p>
<p>我们已经开始接触可能会有失败操作的复杂程序了，这也意味着接下来是一个了解错误处理的绝佳时机！</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.00:错误处理</title>
    <url>/2023/05/18/rust_docs/ch_09_00_error_handing/</url>
    <content><![CDATA[<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在软件中错误是很常见的事实。当有时候软件运行错误的时候，Rust有很多处理这些场景的特性。在很多情况下，Rust要求你确认每一个错误发生的可能，并在代码编译前就采取相应的行为。这个必要前提会让你的程序更加健壮：确保你会提前发现错误，并处理得当，在你将代码部署到生产环境之前。</p>
<p>Rust将错误分为两大类：<strong>可恢复的</strong>(<code>recoverable</code>)和<strong>不可恢复的</strong>(<code>unrecoverable</code>)。对于可恢复错误，比如文件未找打错误，我们很可能只是想向用户报告问题并重试操作。不可恢复错误总是系统性bugs，像尝试访问一个超过数组最尾端的位置，此时，我们就会想要程序立刻停止运行。</p>
<p>大多数编程语言无法区分这两种错误，并且都使用同样的方式，使用如exceptions机制。Rust没有exceptions。而是有一个<code>Result&lt;T, E&gt;</code>的类型来处理可恢复错误。另外，当程序发生一个不可恢复的错误，Rust用<code>panic!</code>宏来中止运行程序。</p>
<p>这一章，首次讨论<code>panic!宏</code>，然后讨论有关<code>Result&lt;T, E&gt;</code>返回的值。</p>
<p>另外，我们还要探索如何决定一个错误应该是恢复或者是停止运行。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.01:使用`panic!`的backtrace</title>
    <url>/2023/05/18/rust_docs/ch_09_01_unrecoverable_errors_with_panic/</url>
    <content><![CDATA[<h4 id="使用panic-的backtrace"><a href="#使用panic-的backtrace" class="headerlink" title="使用panic!的backtrace"></a>使用<code>panic!</code>的backtrace</h4><p>让我们来看看另外一个例子，当因为我们自己的代码有bug而导致库函数调用<code>panic!</code>是什么样的。如Listing 9-1所示的代码尝试访问超出范围的vector的索引。</p>
<p>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listing 9-1: Attempting to access an element beyond the end of a vector, which will cause a call to <code>panic!</code></p>
<p>这里，我们尝试去访问第100个元素(索引99就是第100个元素，索引是从0开始的)，但是vector只有3个元素，肯定会报错。在这个场景中，Rust就会panic。使用<code>[]</code>就是企图返回一个元素，但是你传入一个无效的索引，又不会有这个元素，Rust就肯定不会返回正确的结果。</p>
<p>在C语言中，尝试读取数据结构之后的值是未定义行为(undefined behavior)。你可能会得到一个这个位置的对应的值，但是这个可能是任何的值，但就不是你想要访问的值，因为这个位置的值不属于你想要访问的数据结构范围的值。这个被叫做**缓冲区溢出(buffer overread)**，并且可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取存储在数据结构之后不被允许访问的数据。</p>
<p>为了防止这种漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下的错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (file:<span class="comment">///projects/panic)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.27</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>

<p>上面的错误信息指出错误发生在<code>src/main.rs</code>文件的第4行第5个字符，我们尝试访问索引为99的元素。接着一行的信息告诉我们可以设置<code>RUST_BACKTRACE</code>环境变量来获取backtrace查看发生了什么错误。一个backtrace是一个已经被调用直到当前这一个点的所有的函数列表。Backtrace在Rust的工作原理和其他语言一样：阅读backtrace的关键是从头开始读一直到发现你编写的代码；往下则是你调用的代码。这些行可能包含核心Rust代码，标准库代码或用到的crate代码。让我们设置<code>RUST_BACKTRACE</code>环境变量在Listing 9-2中看看都输出了些什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ RUST_BACKTRACE=<span class="number">1</span> cargo run</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">3</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:<span class="number">584</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">1</span>: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">142</span>:<span class="number">14</span></span><br><span class="line">   <span class="number">2</span>: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:<span class="number">84</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">3</span>: &lt;<span class="type">usize</span> <span class="keyword">as</span> core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">242</span>:<span class="number">10</span></span><br><span class="line">   <span class="number">4</span>: core::slice::index::&lt;<span class="keyword">impl</span> <span class="title class_">core</span>::ops::index::Index&lt;I&gt; <span class="keyword">for</span> [T]&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:<span class="number">18</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">5</span>: &lt;alloc::vec::<span class="type">Vec</span>&lt;T,A&gt; <span class="keyword">as</span> core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/<span class="keyword">mod</span>.rs:<span class="number">2591</span>:<span class="number">9</span></span><br><span class="line">   <span class="number">6</span>: panic::main</span><br><span class="line">             at ./src/main.rs:<span class="number">4</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:<span class="number">248</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure>

<p>Listing 9-2: The backtrace generated by a <code>panic!</code>displayed when the environment variable <code>RUST_BACKTRACE</code>is set</p>
<p>真是输出了一大坨啊！操作系统不同，Rust版本不同，你看到的输出可能会有所不同。为了使用这些信息进行回溯，必须启用debug模式。默认就是debug模式，只要在<code>cargo build</code>或者<code>cargo run</code>之后不要加<code>--release</code>参数。</p>
<p>在Listing 9-2的第6行的backtrace指出了我们项目造成的问题：<code>src/main.rs</code>的第4行。如果我们不想我们的程序panic，我们就应该开始检查定位到第一行我们自己写的代码。在Listing 9-1中，我们故意写了造成panic的代码，修复这个panic就是不要去访问超出vector范围的索引。当你的代码在将来panic， 你需要弄清楚代码使用什么数据做了什么样的操作，以及正确情况下代码应该做什么。</p>
<p>本章后面的小节 <a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> Or not to <code>panic!</code>“</a> 部分讲回<code>panic!</code>，详细讲解应该或者不应该用<code>panic!</code>来处理错误情况。接下来一节我们来讲解如何使用<code>Result</code>恢复一个错误。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 09.02:带有结果的可恢复错误</title>
    <url>/2023/10/18/rust_docs/ch_09_02_recoverable_errors_with_result/</url>
    <content><![CDATA[<h3 id="带有结果的可恢复错误"><a href="#带有结果的可恢复错误" class="headerlink" title="带有结果的可恢复错误"></a>带有结果的可恢复错误</h3><p>大多数错误并不严重到需要程序完全停止。有时，当一个函数失败时，其原因可以很容易地解释和响应。例如，如果您尝试打开一个文件，但由于该文件不存在而导致该操作失败，那么您可能希望创建该文件，而不是终止该进程。</p>
<p>回到第二章<code>Result</code>的枚举定义里，有两个成员，<code>Ok</code> 和<code>Err</code>,如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>和<code>E</code>是泛型参数：我们将在第十章详细讨论。目前你需要知道当成功时返回枚举成员<code>Ok</code>，当失败时返回枚举成员<code>Err</code>。由于<code>Result</code>具有这些泛型类型参数，因此我们可以在许多不同的情况下使用<code>Result</code>类型及其上定义的函数，其中我们希望返回的成功值和错误值可能不同。</p>
<p>我们来调用一个返回值类型为<code>Result</code>的函数，因为调用可能会失败。如Listing 9-3我们尝试打开一个文件。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">opend</span>(<span class="string">&quot;hello.txt);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Listing 9-3 Openging a file</p>
<p><code>File::open</code>的返回值是一个<code>Result&lt;T, E&gt;</code>。泛型参数<code>T</code>已经被<code>File::open</code>实现，并填入了成功的值，<code>std::fs::File</code>是一个文件句柄(file handle)。类型<code>E</code>的错误值是<code>std::io::Error</code>。<code>File::open</code>返回类型意思是如果成功就会返回一个文件句柄，并且可以进行读写。这个函数也有可能会调用失败：例如，文件不存在，或者没有权限访问。<code>File::open</code>函数需要有个方式告诉我们是成功或者失败，同时返回给我们文件句柄或者错误信息。这个信息正是Result枚举所传达的。</p>
<p>因此，当<code>File::open</code>调用成功，变量<code>greeting_file_result</code>的值将会是成员<code>Ok</code>并包含一个文件句柄。如果失败，<code>greeting_file_result</code>就是一个<code>Err</code>的实例并包含更多错误信息来展示到底发生了什么错误。</p>
<p>我们需要在Listing9-3中根据<code>File::open</code>的返回值来添加额外的代码。如Listing9-4中所示，这是一个基本的<code>Result</code>的处理工具，就是使用<code>match</code>表达式（我们已经在第六章中讲过了）。<br>Filename:src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-4: Using a match expression to handle the <code>Result</code> variants that might be returned</p>
<p>请注意，与Option enum一样，<code>Result</code>枚举及其成员也通过prelude进入了作用域，因此我们不需要在匹配分支中的Ok和Err成员之前指定<code>Result::</code>。</p>
<p>当结果为<code>Ok</code>时，这段代码将返回<code>Ok</code>中的<code>file</code>，然后我们将该文件句柄值赋给变量<code>greeting_file</code>。在<code>match</code>之后，我们可以使用文件句柄进行读写了。<br><code>match</code>的另外一个分支就会从<code>File::open</code>中得到一个<code>Err</code>的值。在这个示例中，我们现在调用<code>panic!</code>宏(macro)。如果没有一个叫<code>hello.txt</code>的文件在当前文件夹，并且运行了这段代码，我们就会看到如下来自<code>panic!</code>宏的错误输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/error-handling`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;Problem opening the file: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:8:23</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>像往常一样，这个输出告诉我们哪里出了问题。</p>
<h4 id="匹配不同的错误-Matching-on-Different-Errors"><a href="#匹配不同的错误-Matching-on-Different-Errors" class="headerlink" title="匹配不同的错误(Matching on Different Errors)"></a>匹配不同的错误(Matching on Different Errors)</h4><p>Listing9-4无论<code>File::open</code>因为什么失败都会报<code>pannic!</code>错误。然而，我们希望针对不同的失败原因采取不同的行动：如果<code>File::open</code>失败是因为文件不存在，我们想创建一个文件并返回新文件的句柄。如果<code>File::open</code>失败是因为其他原因–比如，因为我们没有打开文件的权限–我们仍然和Listing9-4一样<code>panic!</code>。为此，我们在<code>match</code>内添加一个内部表达式，如Listing 9-5所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-5: Handling different kinds of errors in different ways</p>
<p><code>File::open</code>内部返回的<code>Err</code>的值<code>io::Error</code>，它是标准库提供的数据结构。这个数据结构有一个<code>kind</code>方法可以得到一个<code>io::ErrorKind</code>的值。枚举<code>io::ErrorKind</code>是标准库提供的，并且有不同类型的错误都对应着相应的io操作。我们使用的<code>ErrorKing::NotFound</code>枚举成员表明我们尝试打开一个不存在的文件。所以我们在<code>greeting_file_result</code>上匹配，但我们也在error.kind()上进行内部匹配。</p>
<p>我们希望在内部匹配中检查的条件是<code>error.kind()</code>返回的值是否为<code>ErrorKind</code>枚举的<code>NotFound</code>成员。如果是我，我们将尝试通过<code>File::create</code>创建文件，然而我们创建文件也有可能失败，在<code>match</code>内部我们需要第二个分支来处理。当文件不能创建，一个不同的错误就会被打印。<code>match</code>外部保持不变。因此，除文件不存在的情况之外都会报错。</p>
<h4 id="失败时-panic-的简写-unwrap-和-expect"><a href="#失败时-panic-的简写-unwrap-和-expect" class="headerlink" title="失败时 panic 的简写: unwrap 和 expect"></a>失败时 panic 的简写: unwrap 和 expect</h4><p><code>match</code> 已经很好用了，不过它可能有点冗长并且不总是能很好的表明其意图。<code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <code>unwrap</code>，它的实现就类似于Listing 9-4 中的 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们运行这段代码，并且<code>hello.txt</code>文件不存在，我们就会看到一个错误信息来自<code>unwrap</code>方法调用了<code>panic!</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:4:49</span><br></pre></td></tr></table></figure>
<p>同样，<code>expect</code>方法也可以自定义<code>panic!</code>的错误信息。使用<code>expect</code>而不是<code>unwrap</code>并提供友好的错误信息可以传达您的意图，并使跟踪<code>panic!</code>的来源更容易。<code>expect</code>的语法如下所示：<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs:File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;hello.txt should be included int this project&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以和使用<code>unwrap</code>一样使用<code>expect</code>来返回一个文件句柄或者调用<code>panic!</code>。错误信息通过<code>expect</code>调用<code>panic!</code>时传递，而不是<code>panic!</code>默认的错误信息，展示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;hello.txt should be included in this project: Os &#123;</span><br><span class="line">code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;,</span><br><span class="line">src/main.rs:5:10</span><br></pre></td></tr></table></figure>
<h4 id="传递错误-Propagating-Errors"><a href="#传递错误-Propagating-Errors" class="headerlink" title="传递错误(Propagating Errors)"></a>传递错误(Propagating Errors)</h4><p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。<br>例如：Listing 9-6所示，一个函数读一个文件。如果文件不存在或者不能读，函数就会返回一些错误。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">usename_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">usename_file</span> = <span class="keyword">match</span> username_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> user_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">read_username_from_file</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-6: A function that returns errors to the calling code using <code>match</code></p>
<p>这个函数可以用更短的方式编写，但我们将从手动做很多事情开始，以探索错误处理;最后，我们将展示较短的方法。我们先看一下函数的返回类型：<code> Result&lt;String, io::Error&gt;</code> 。这意味着该函数返回一个类型的 <code>Result&lt;T, E&gt;</code> 值，其中泛型参数 <code>T</code> 已用具体类型填充，泛型类型已用具体类型 <code>String</code>填充，<code>E</code>用<code>io::Error</code>填充。</p>
<p>如果此函数成功且没有任何问题，则调用此函数的代码将收到一个<code>Ok</code>值，该值包含<code>String</code>此函数从文件中读取的username。如果此函数遇到任何问题，调用代码将收到一个 <code>Err</code> 值，该值包含包含有关问题所在的详细信息的实例 <code>io::Error</code> 。我们选择 <code>io::Error</code> 此函数的返回类型，因为这恰好是我们在此函数主体中调用的两个操作返回的错误值的类型： <code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数的主体从调用 <code>File::open</code> 函数开始。然后我们用类似于Listing 9-4 <code>match</code> 中的值来处理 <code>match</code> 该 <code>Result</code> 值。如果成功，模式 <code>File::open</code> 变量中的文件句柄将成为可变变量 <code>username_file</code> 中的值，函数将继续。在这种情况下 <code>Err</code> ，我们不是调用，而是使用 <code>return</code> 关键字提前完全返回函数，并从<code>File::open</code>返回的错误传递出去，模式匹配中的<code>e</code>作为该函数的错误值传递回调用 panic! 代码。</p>
<p>因此，如果我们在<code>username_file</code>中有一个文件句柄，那么该函数将在变量<code>username</code>中创建一个新的<code>String</code>，并调用<code>username_file</code>中文件句柄上的<code>read_to_string</code>方法来将文件的内容读入<code>username</code>。<code>read_to_string</code>方法也返回<code>Result</code>，因为它可能失败，即使<code>File::open</code>打开文件成功，读文件也有可能失败。所以我们需要另一个匹配来处理这个<code>Result</code>:如果<code>read_to_string</code>成功，那么我们的函数就成功了，我们从文件中返回username，这个username现在被<code>Ok</code>封装在<code>username</code>中。如果<code>read_to_string</code>操作失败，返回错误值的方式与处理<code>File::open</code>返回值的匹配中返回错误值的方式相同。然而，我们不需要显式<code>return</code>，因为这是函数中的最后一个表达式。</p>
<p>然后，调用该代码的代码将处理获取包含<code>username</code>的<code>Ok</code>值或包含<code>io::Error</code>的<code>Err</code>值。由调用代码决定如何处理这些值。如果调用代码得到一个<code>Err</code>值，它可能会调用<code>panic!</code>并使程序崩溃，使用默认username，或者从文件以外的其他地方查找username。我们没有足够的信息来了解调用代码实际尝试做什么，所以我们向上传播所有成功或错误信息，以便它正确处理。</p>
<p>这种传播错误的模式在Rust中非常常见，因此Rust为了方便起见提供了问号操作符<code>?</code>。</p>
<h4 id="传播错误的快捷方式-操作符"><a href="#传播错误的快捷方式-操作符" class="headerlink" title="传播错误的快捷方式:?操作符"></a>传播错误的快捷方式:<code>?</code>操作符</h4><p>如Listing9-7所示，实现了一个和Listing9-6相同的<code>read_username_from_file</code>的函数，但是使用了<code>?</code>操作来实现。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-7: A function that returns errors to the calling code using the &#96;?&#96;&#96; operator</p>
<p><code>?</code>操作符放置在<code>Result</code>值之后，其工作方式与Listing 9-6中为处理<code>Result</code>值而定义的匹配表达式几乎相同。如果<code>Result</code>的值为<code>Ok</code>，则该表达式将返回<code>Ok</code>中的值，程序将继续执行。如果该值为<code>Err</code>，则整个函数将返回<code>Err</code>，就像我们使用了<code>return</code>关键字一样，因此错误值将传播到调用代码。</p>
<p>Listing 9-6中的匹配表达式的作用与<code>?</code>操作符所做的事情:错误值有<code>?</code>在标准库中的<code>From</code>trait中定义了from函数，该函数用于将值从一种类型转换为另一种类型。什么时候<code>?</code>操作符调用<code>from</code>函数，接收到的错误类型被转换为当前函数返回类型中定义的错误类型。当函数返回一种错误类型来表示函数可能失败的所有方式时，即使部分可能因许多不同的方式而失败，这也是有用的。</p>
<p>例如，我们可以修改Listing 9-7中的<code>read_username_from_file</code>函数，使其返回一个自定义的错误类型<code>OurError</code>。如果我们还为<code>OurError</code>定义<code>impl From&lt;io::Error&gt;</code>，从<code>io::Error</code>构造<code>OurError</code>的实例，那么<code>?</code>操作符会在<code>read_username_from_file</code>函数体中将调用<code>from</code>并转换错误类型，而无需向函数中添加任何代码。</p>
<p>在Listing 9-7的上下文中，<code>?</code>在<code>File::open</code>调用的末尾将把<code>Ok</code>中的值返回给变量<code>username_file</code>。如果发生错误，<code>?</code>操作符将提前返回，并向调用代码提供任何<code>Err</code>值。同样的道理也适用于<code>?</code>在<code>read_to_string</code>调用结束时。</p>
<p><code>?</code>操作符消除了大量的模板代码，使这个函数的实现更简单。我们甚至可以通过在<code>?</code>之后立即连接方法调用来进一步缩短代码，如Listing 9-8所示。<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-8: Chaining method calls after the <code>?</code> operator</p>
<p>我们将<code>username</code>中<code>String</code>的创建移到了函数的开头;这一点没有改变。我们没有创建一个可变的用户名文件，而是将<code>read_to_string</code>调用直接连接到<code>file::open(&quot;hello.txt&quot;)</code>的结果上。我们还有<code>?</code>当<code>File::open</code>和<code>read_to_string</code>都成功时，我们仍然返回一个包含<code>username</code>的<code>Ok</code>值，而不是返回错误。功能与Listing 9-6和Listing 9-7相同;这是一种不同的，更符合工程学的写法。</p>
<p>Listing 9-9 所示使用了<code>fs::read_to_string</code>将使代码更加简短。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-9: Using <code>fs::read_to_string</code> instead of opening and then reading the file</p>
<p>将文件读入字符串是一种相当常见的操作，因此标准库提供了方便的<code>fs::read_to_string</code>函数，该函数打开文件，创建一个新的<code>String</code>，读取文件的内容，将内容放入该<code>String</code>，并返回它。当然，使用<code>fs::read_to_string</code>并不能让我们有机会解释所有的错误处理，所以我们先用更长的方法来解释。</p>
<h4 id="哪里可以使用-操作"><a href="#哪里可以使用-操作" class="headerlink" title="哪里可以使用?操作"></a>哪里可以使用<code>?</code>操作</h4><p><code>?</code>操作符只能用于返回类型与<code>?</code>操作符兼容的函数中。这是因为<code>?</code>操作符的定义是执行从函数中提前返回一个值，方式与Listing 9-6中定义的<code>match</code>表达式相同。在Listing 9-6中，匹配使用一个<code>Result</code>值，而提前返回臂返回一个<code>Err(e)</code>值。函数的返回类型必须是<code>Result</code>，以便与此返回兼容。</p>
<p>在Listing 9-10中，让我们看看如果使用<code>?</code>返回类型与我们使用的值的类型不兼容的主函数中的操作符<code>?</code>:<br>Filename: src&#x2F;main.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-10: Attempting to use the <code>?</code> in the <code>main</code> function that returns &#96;()&#96;&#96; won’t compile</p>
<p>这段代码打开一个文件，可能会失败。<code>?</code>操作符在<code>File::open</code>返回的<code>Result</code>值之后，但是这个主函数的返回类型是<code>()</code>，而不是<code>Result</code>。当我们编译这段代码时，会得到以下错误消息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling error-handling v0.1.0 (file:///projects/error-handling)</span><br><span class="line">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:4:48</span></span><br><span class="line">  |</span><br><span class="line">3 | fn main() &#123;</span><br><span class="line">  | --------- this function should return `Result` or `Option` to accept `?`</span><br><span class="line">4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">  |                                                ^ cannot use the `?` operator in a function that returns `()`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `error-handling` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个错误指出我们只允许使用<code>?</code>返回<code>Result</code>、<code>Option</code>或其他实现<code>FromResidual</code>的类型的函数中的操作符。</p>
<p>要修复这个错误，您有两种选择。一种选择是更改函数的返回类型，使其与使用的值兼容。只要没有限制，就继续操作。另一种技术是使用<code>match</code>或<code>Result&lt;T, E&gt;</code>方法之一，以任何合适的方式处理<code>Result&lt;T, E&gt;</code>。</p>
<p>错误信息中还提到<code>?</code>也可以与<code>Option&lt;T&gt;</code>值一起使用。就像使用<code>?</code>在<code>Result</code>中，您只能使用<code>?</code>在返回一个<code>Option</code>的函数中使用<code>Option</code>。<code>?</code>操作符在<code>Option&lt;T&gt;</code>上调用时的行为与在<code>Result&lt;T, E&gt;</code>上调用时的行为相似:如果值为<code>None</code>，则在该点将提前从函数返回<code>None</code>。如果值是<code>Some</code>，则<code>Some</code>中的值是表达式的结果值，函数继续执行。Listing 9-11给出了一个函数示例，该函数查找给定格式中第一行的最后一个字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;Hello, world\nHow are you today?&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">last_char_of_first_line</span>(<span class="string">&quot;\nhi&quot;</span>), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-11: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code> value</p>
<p>这个函数返回<code>Option&lt;char&gt;</code>，因为有可能有字符，但也有可能没有。这段代码接受<code>text</code>字符串切片参数并对其调用<code>lines</code>方法，该方法返回一个遍历字符串中的行的迭代器。因为这个函数想要检查第一行，所以它在迭代器上调用<code>next</code>以从迭代器中获取第一个值。如果<code>text</code>是空字符串，对<code>next</code>的调用将返回<code>None</code>，在这种情况下我们使用<code>?</code>停止并从第一行的最后一个字符返回<code>None</code>。如果<code>text</code>不是空字符串，<code>next</code>将返回一个<code>Some</code>值, 其中包含<code>text</code>中第一行的字符串切片。</p>
<p><code>?</code>操作符提取字符串切片，然后调用该字符串切片上的<code>chars</code>来获取其字符的迭代器。我们对第一行的最后一个字符感兴趣，因此调用<code>last</code>来返回迭代器中的最后一项。这是一个选项，因为第一行可能是空字符串，例如，如果文本以空行开头，但在其他行上有字符，如<code>“\nhi”</code>。但是，如果第一行有最后一个字符，它将在<code>Some</code>变体中返回。<code>?</code>运算符在中间给了我们一种简洁的方式来表达这个逻辑，允许我们实现</p>
<p>注意，您可以使用<code>?</code>操作符对返回<code>Result</code>的函数中的<code>Result</code>进行操作，您可以使用?操作符在返回<code>Option</code>的函数中对<code>Option</code>进行操作，但不能混合匹配。<code>?</code>操作符不会自动将<code>Result</code>转换为<code>Option</code>，反之亦然;在这些情况下，您可以使用诸如<code>Result</code>上的<code>ok</code>方法或<code>Option</code>上的<code>ok_or</code>方法来显式地进行转换。</p>
<p>到目前为止，我们使用的所有主要函数都是<code>return()</code>。<code>main</code>函数的特殊之处在于它是可执行程序的入口和出口点，它的返回类型是有限制的，这样程序才能按照预期的方式运行。</p>
<p>幸运的是，<code>main</code>也可以返回<code>Result&lt;()， E&gt;</code>。Listing 9-12拥有Listing 9-10的代码，但我们将<code>main</code>的返回类型更改为<code>Result&lt;()</code>， <code>Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加返回值<code>Ok(())</code>。这段代码现在可以编译了:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Listing 9-12: Changing main to return <code>Result&lt;(), E&gt;</code> allows the use of the <code>?</code> operator on <code>Result</code> values</p>
<p><code>Box&lt;dyn Error&gt;</code>类型是一个<code>trait</code>对象，我们将在第17章使用允许不同类型值的<code>trait</code>对象一节中讨论它。现在，您可以读取<code>Box&lt;dyn Error&gt;</code>来表示任何类型的错误。使用<code>?</code>允许在错误类型为<code>Box&lt;dyn error &gt;</code>的主函数中返回<code>Result</code>值，因为它允许提前返回任何<code>Err</code>值。即使这个主函数的主体只会返回<code>std::io::Error</code>类型的错误，通过指定<code>Box&lt;dyn Error&gt;</code>，即使将返回其他错误的更多代码添加到main的主体中，该签名仍然是正确的。</p>
<p>当<code>main</code>函数返回<code>Result&lt;()， E&gt;</code>时，如果<code>main</code>函数返回<code>Ok(())</code>，可执行程序将以<code>0</code>的值退出;如果<code>main</code>函数返回<code>Err</code>值，可执行程序将以非<code>0</code>的值退出。用C编写的可执行程序在退出时返回整数:成功退出的程序返回整数<code>0</code>，出错的程序返回非0的整数。Rust还从可执行文件返回整数，以与此约定兼容。</p>
<p>main函数可以返回任何实现<code>std::process::Termination</code> trait的类型，它包含一个可以返回<code>ExitCode</code>的函数<code>report</code>。有关为您自己的类型实现<code>Termination</code>特性的更多信息，请参阅标准库文档。</p>
<p>到现在，我们已经详细讨论了调用<code>panic!</code>或者返回<code>Result</code>。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么看到别人过得好，我就心里好难受呢？</title>
    <url>/2023/08/18/rust_docs/why/</url>
    <content><![CDATA[<h3 id="为什么看到别人过得好，我就心里好难受呢？"><a href="#为什么看到别人过得好，我就心里好难受呢？" class="headerlink" title="为什么看到别人过得好，我就心里好难受呢？"></a>为什么看到别人过得好，我就心里好难受呢？</h3><p>早上刚来到公司，一个深圳有房，长得高又帅，身价已然超过95%深圳人的同事发出这样的灵魂拷问：为什么看到别人过得好，我就心里好难受呢？</p>
<h4 id="来看看AI如何看待："><a href="#来看看AI如何看待：" class="headerlink" title="来看看AI如何看待："></a>来看看AI如何看待：</h4><blockquote>
<p>根据你的描述,你已经达到了生活物质上很高的满足度,拥有自己的房产,生活质量远超过大多数人。但即便如此,看见别人过得很好,你还是会感到心理难受。这主要还是出于以下几个原因:</p>
<ol>
<li>心理比较并不会随着物质生活的提高而消失。人们的社会比较心理往往与生活状态相关不大,更加源自内在的不安全感。所以即便生活质量很高,这种比较心理仍然存在。</li>
<li>你可能理想化别人拥有的东西。比如羡慕别人拥有的人际关系,职业成就,生活状态等,而忽视了自己已经拥有的很多东西。这也会带来难受的感觉。</li>
<li>你期望得到的不仅是物质生活。人的内心渴望往往不仅限于物质层面,也包括精神层面,如获得认同,建立亲密关系,实现自我价值等。如果这些方面没有得到满足,也会感到心理上的难受。</li>
<li>你可能在某些方面感到不满意。尽管生活总体质量很高,但在情感生活,人际交往,事业发展等某一具体方面,你可能还是感到不如意或不足,这也是产生难受心理的原因之一。<br>所以,要解决这个问题,重点不在于提高生活质量,而是要在心理和精神层面获得安定。学会理性看待他人,不必过度羡慕别人所拥有的一切。关注自己的内心真实需求,努力在各个方面获得满足和进步。培养自己独立稳定的心态,增强自我价值感。这些可以有效地帮助你摆脱这种由社会比较所带来的难受情绪。</li>
</ol>
</blockquote>
<p>根据我党的判断，我们现在仍处于社会主义初级阶段，现阶段中国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。也是涵盖了上述矛盾心理内涵的。近些年，特别是改革开放之后，中国高速发展，让一部分人抓住了高速发展的红利，以不匹配自己能力增长的速度拥有了超速增长的财富和资产。即身心发展和财富发展并不平衡，导致了内心不够充盈，格局尚未完全打开，自我定位错乱。矛盾逐渐凸显扭曲就会发生这样莫名奇怪的心理。</p>
<p>实际上，在深圳这种高度发达，贫富差距巨大的快节奏生活的城市，大部分年轻人都特别焦虑，焦虑的本质就是日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。大部分年轻人都是来自外地十八线小城市或者小县城，或者农村。回不去，留不下随着时间的推移，越来越焦虑。这部分人特别像小资产阶级的表现：</p>
<blockquote>
<p>作为劳动者，在思想上倾向于无产阶级，作为私有者，又倾向于资产阶级，极易受资产阶级思想的影响。因此，在反对封建主义的斗争中既具有革命性，同时也存在政治上的动摇性、斗争中的软弱性和革命的不彻底性。</p>
</blockquote>
<p>让我想起了抓猴子的故事里伸手进树洞紧紧抓住坚果，即使猎人来了也舍不得放手。这个猴子是我们每个人。</p>
<p>对于这种外因短时间无法改变的问题，我们只能改变内因了。看看AI又会给出什么样的建议呢？</p>
<blockquote>
<p>这里有些简单实用的建议可以帮助你摆脱由社会比较带来的难受心理:</p>
<ol>
<li>转移注意力。当你开始羡慕别人或感到自卑时,立即转移注意力,不要过多聚焦在别人身上。可以换个环境,做点运动,转而关注自己喜欢的事物。这可以有效地改变心情。</li>
<li>记录自己的收获。时常记录自己生活中已经实现的小成就和收获,提醒自己生活的美好之处。这可以建立信心,也让你意识到自己已经拥有很多。</li>
<li>限制社交媒体使用。社交媒体上人们主要分享生活的美好时刻,这会助长羡慕心理。适当限制使用社交媒体,关注生活中真实的一面。</li>
<li>珍惜你所拥有的。时常想想你已经拥有但当作理所当然的东西,会让你觉得很满足和幸运。这可以避免过度关注别人拥有的。</li>
<li>关注自己的需求。理解自己真正想要什么,并努力实现,这可以让你没有时间和精力过度关注别人,也会让你感到人生有目标和意义。</li>
<li>施比受更有福。当你羡慕别人时,想想你能为别人带来什么好处。关注别人的需求,提供帮助,这可以让你转移注意力,也会带来成就感。</li>
<li>培养内在安定。通过冥想,听音乐,上瑜伽课等方式,培养安定的心态。当内心足够安定,外界的比较就不会那么轻易影响你。<br>这些实用的方法,帮助调节心态,关注自我,减少对他人生活的过度比较,可以有效地让你摆脱社会比较带来的难受情绪。需要时间去实践,但效果会非常显著。</li>
</ol>
</blockquote>
<p>这些方法对我都很有启发，对与解决自身的焦虑也很受用。生活在快节奏的深圳，周围人都是狠角色，焦虑对每个人来说是常态。人生的各个阶段也会有不同的焦虑，只有学会面对焦虑，利用焦虑，焦虑也可以是人类进步的助推器。加油吧，少年郎！</p>
]]></content>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>Growth and Government</title>
    <url>/2023/11/24/sam_altman/growth-and-government/</url>
    <content><![CDATA[<p>这是一篇11年前于2013年3月5日,山姆 奥特曼写的一篇探讨了经济增长和政府的关系。他认为，政府可以在某些情况下促进经济增长，但在其他情况下，政府的干预可能会阻碍经济增长。</p>
<p>作者提到，政府可以通过提供教育和基础设施来促进经济增长，这些投资可以帮助提高人们的技能和生产力，并促进创新。此外，政府还可以通过减少管制和税收来鼓励企业家精神和创新。</p>
<p>然而，作者也指出了政府过度干预可能会对经济产生负面影响。他认为，政府应该避免过度管制和税收，并确保市场能够有效地运作。如果政府过度干预市场，可能会导致资源的浪费和低效率。</p>
<p>总之，作者认为政府可以在某些情况下促进经济增长，但需要谨慎地权衡利弊，并确保市场能够自由运作。</p>
<h1 id="Growth-and-Government-增长与政府"><a href="#Growth-and-Government-增长与政府" class="headerlink" title="Growth and Government 增长与政府"></a>Growth and Government 增长与政府</h1><p>TL;DR Without economic growth, democracy doesn’t work because voters occupy a zero-sum system.<br>TL;DR：没有经济增长，民主就无法运作，因为选民占据的是零和博弈体系。</p>
<p>The first piece of startup wisdom I heard was “increasing your sales will fix all problems”.   This turns out to be another way of phrasing Paul Graham’s point that growth is critical, which is true for all sorts of reasons—for example, justifying high valuations to raise large amounts of capital in the early days, attracting the best people and paying them with equity, providing a buffer to allow for some mistakes, and smoothing over internal tensions.<br>我听到的第一条创业智慧是“增加销售额将解决所有问题”。  事实证明，这是保罗·格雷厄姆（Paul Graham）的观点的另一种表达方式，即增长至关重要，出于各种原因，这都是正确的——例如，在早期证明高估值以筹集大量资金是合理的，吸引最优秀的人才并以股权支付他们，提供缓冲以允许一些错误， 并抚平内部紧张局势。</p>
<p>I believe that growth is not only critical for startups, but for most systems.   Either you’re growing, or you’re slowly dying.  Perfect equilibrium is rare.<br>我相信增长不仅对初创公司至关重要，而且对大多数系统也至关重要。  要么你在成长，要么你在慢慢死去。 完美的平衡是罕见的。</p>
<p>One system that seems to be in early death throes is the United States government.  There’s a lot of political rancor, which is particularly puzzling when one considers that in the 2012 presidential election, Obama and Romney said roughly the same thing.  Dysfunction is high—the sequester, which was supposed to be so unpalatable it would never take effect, actually (and likely temporarily) happened last Friday because the parties couldn’t agree on an alternative. There’s a lot of arguing over insignificant issues—enough, in fact, to distract us from the fact that no one has new ideas on the big issues.  We have trillion dollar deficits and no plan to reduce them, and yet the media focus on the sideshows.<br>一个似乎处于早期死亡阵痛中的系统是美国政府。 有很多政治仇恨，当人们考虑到在2012年总统大选中，奥巴马和罗姆尼说了大致相同的话时，这尤其令人费解。 功能失调很严重——本来应该非常难吃以至于永远不会生效的隔离，实际上（而且可能是暂时的）发生在上周五，因为双方无法就替代方案达成一致。关于无关紧要的问题有很多争论——事实上，这足以分散我们的注意力，让我们忽视这样一个事实，即没有人对重大问题有新的想法。 我们有数万亿美元的赤字，但没有减少赤字的计划，但媒体却把注意力集中在杂耍上。</p>
<p>A good metric for government dysfunction is inability to pass a budget, either leading to a government shutdown or a continuing resolution, which lets agencies continue to operate on the previous budget, for a theoretically short time period until we can agree on a new one.  Passing a budget is a fundamental job of Congress and the President.<br>衡量政府功能失调的一个很好的指标是无法通过预算，要么导致政府关闭，要么导致持续决议，这让各机构在理论上很短的时间内继续按照以前的预算运作，直到我们能够就新的预算达成一致。 通过预算是国会和总统的一项基本工作。</p>
<p>As far as I can tell, the US government managed to make it about 200 years without any shutdowns.  We had one in 1976, and then a bunch more in the 70s and 80s, plus 3 in the 90s, including one that lasted 21 days.  Shutdowns have fallen out of fashion, and now we just operate with continuing resolutions, and lots of them—for example, 21 for the 2001 budget alone.  The real issue with shutdowns and continuing resolutions is the same—inability to agree on a federal budget.<br>据我所知，美国政府设法做到了大约 200 年而没有任何停工。 我们在 1976 年有一个，然后在 70 年代和 80 年代又有一堆，再加上 90 年代的 3 个，包括一个持续了 21 天。 停摆已经过时了，现在我们只是在持续的决议下运作，而且很多决议——例如，仅2001年预算就有21项决议。 关门和持续决议的真正问题是一样的——无法就联邦预算达成一致。</p>
<p>Every few months, there’s brief discussion of some sort of grand bargain, but it always ends in deferral—even the deferrals get deferred!  Everyone feels screwed, and almost no one feels like the government is doing a great job.   We can’t agree on anything, and anyone that proposes doing something radically different doesn’t get elected.<br>每隔几个月，就会有关于某种大交易的简短讨论，但它总是以推迟而告终——即使是推迟也会被推迟！ 每个人都觉得自己搞砸了，几乎没有人觉得政府做得很好。  我们无法就任何事情达成一致，任何提议做一些完全不同的事情的人都不会当选。</p>
<p>But democracy (I’m using democracy to include republics and other forms of government where the people get an effectively direct say in who the leaders are) worked in the US for a long time—we were able to make real progress, pass budgets, be the world superpower, evolve as a country, etc.  Something has changed.<br>但是民主（我用民主来包括共和国和其他形式的政府，人民对谁是领导人有有效的直接发言权）在美国工作了很长时间——我们能够取得真正的进步，通过预算，成为世界超级大国，作为一个国家发展，等等。 有些事情发生了变化。</p>
<p>The US has been blessed with economic growth for a very long time, first due to natural resources and massive amounts of land in which to expand, and then due to a period of technological progress rarely matched in human history that lasted approximately until we realized just how dangerous nuclear bombs really were and got scared of new technology.  But the frontier is long over, and although technological innovation has continued at a blistering rate for computers and the Internet, it seems to have slowed down in most other industries.<br>很长一段时间以来，美国一直享有经济增长的福气，首先是由于自然资源和大量可供扩张的土地，然后是由于人类历史上罕见的技术进步时期，这种进步大约持续到我们意识到核弹到底有多危险并害怕新技术。 但这个前沿早已结束，尽管计算机和互联网的技术创新继续以极快的速度发展，但在大多数其他行业似乎已经放缓。</p>
<p>Growth may be the root cause of American exceptionalism—things consistently got better every decade largely because we were growing.  People from other countries wanted to live here, we led the world in technological innovation, social mobility was high because everyone was getting richer, and we had the resources to get involved around the world.  This is still at least partially true.<br>增长可能是美国例外论的根本原因——情况每十年就会变得更好，这主要是因为我们在成长。 来自其他国家的人们想住在这里，我们在技术创新方面引领世界，社会流动性很高，因为每个人都越来越富有，我们有资源参与世界各地的活动。 这至少部分是正确的。</p>
<p>But growth has slowed quite a bit.  Here is a graph of real GDP percentage growth in the United States from 1950 until now, with a trendline.  The trendline goes from just under 5% to just under 2%.  This is a much more significant drop than it appears, because it compounds exponentially.<br>但增长已经放缓了不少。 这是一张从1950年至今美国实际GDP增长百分比的图表，并带有趋势线。 趋势线从略低于 5% 到略低于 2%。 这是一个比看起来要大得多的下降，因为它呈指数级复合。</p>
<div align="center"> <img src="/images/samaltman-medium_Ycc26Om.png"/></div>

<p>A shocking data point about how things are going is that the median real net worth for households headed by someone under 35 dropped 68% from 1984 to 2009, to $3,662.  For those over 65, it increased 42% to $170,494 (largely due to a gain in property values).  This disparity is good evidence of a lack of real growth (and also a very unstable situation where an older generation benefits at the expense of a younger).<br>关于事情进展的一个令人震惊的数据点是，从1984年到2009年，以35岁以下的人为户主的家庭的实际净资产中位数下降了68%，至3,662美元。对于65岁以上的人，它增加了42%，达到170,494美元（主要是由于房产价值的增加）。这种差距很好地证明了缺乏实际增长（也是一种非常不稳定的情况，即老一代人以牺牲年轻人为代价而受益）。</p>
<p>Here are two more graphs, the first showing the US unemployment rate (the real numbers are perhaps worse, as people drop out of the work force) and the second showing the US interest rate, both of which make a case for slowing growth:<br>这里还有两张图表，第一张显示美国失业率（实际数字可能更糟，因为人们退出劳动力市场），第二张显示美国利率，两者都表明经济增长放缓：</p>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_pa0IzIq.png"/></div>
<div align="center"> <img src="/images/samlatman-growth-and-government-medium_tXYg4oM.png.png"/></div>
All of that said, in absolute sense I’d much rather live in the world of today than 1950—it’s tough for me to imagine living in a world without the Internet.  However, in the same way that one can feel acceleration but not velocity, people seem more sensitive to the annual rate of improvement than the absolute quality of life.  So even though people should be happier in an absolutely better world, no one wants to stand still on the hedonic treadmill.
综上所述，从绝对意义上讲，我宁愿生活在今天的世界，而不是1950年——我很难想象生活在一个没有互联网的世界里。 然而，就像人们可以感觉到加速度但不能感觉到速度一样，人们似乎对每年的改善速度比绝对的生活质量更敏感。 因此，尽管人们应该在一个绝对更好的世界中更快乐，但没有人愿意在享乐的跑步机上停滞不前。

<p>Most of us want our lives to get better every year—the hedonic treadmill is a pain that way.  In a democracy, we theoretically vote for what we believe will improve our lives the most.  In a system with economic growth, things can improve for everyone.  In a system without growth, or even one with very little growth, that’s not the case—if things improve for me, it has to come at the expense of things getting worse for you.  Without growth, we’re voting against someone else’s interest as much as we’re voting for our own.  This ends with lots of fighting and everyone feeling screwed, broken into factions, and unmotivated.  Democracy does not work well in a zero-sum world.  Autocratic political systems probably work better with growth too, but the effect of a lack of growth is likely less pronounced right up until the revolution.<br>我们大多数人都希望我们的生活每年都变得更好——享乐跑步机就是这样一种痛苦。在民主国家，从理论上讲，我们会投票选出我们认为最能改善我们生活的东西。在一个经济增长的体系中，每个人都可以改善情况。在一个没有增长的系统中，甚至在一个几乎没有增长的系统中，情况并非如此——如果事情对我来说有所改善，那一定是以你变得更糟为代价的。没有增长，我们就是在投票反对别人的利益，就像我们投票支持自己的利益一样。这以大量的战斗结束，每个人都感到被搞砸了，分裂成派系，没有动力。民主在零和博弈的世界里运作不通。专制政治制度在增长方面可能也更有效，但缺乏增长的影响可能直到革命之前才那么明显。</p>
<p>So we need to get growth back, unless we want to see this grand experiment end.  Our politicians don’t seem to have any good ideas about how to do this.  Saying “I believe in America” and hoping that proof by vigorous assertion starts working is not a strategy.<br>因此，我们需要恢复增长，除非我们想看到这个伟大的实验结束。 我们的政客们似乎对如何做到这一点没有任何好主意。 说“我相信美国”，并希望通过有力的断言来证明开始起作用，这不是一种策略。</p>
<p>I believe democracy only works in a non-zero-sum world.  We are losing jobs that we will never get back, we are borrowing money and spending it on anything but real investment, and it feels like we are managing a slow decline.  Without growth, we will head towards a special case of Malthusian dystopia where we have plenty of junk food but not enough of anything else.<br>我相信民主只有在非零和博弈的世界中才能发挥作用。 我们正在失去永远无法挽回的工作，我们正在借钱并将其花在除实际投资之外的任何事情上，感觉我们正在缓慢下降。 没有增长，我们将走向马尔萨斯反乌托邦的一个特例，在那里我们有很多垃圾食品，但其他任何东西都不够。</p>
<p>Growth is what we should be focusing on.  Growth is great—it lets us run deficits, it means the country is not zero-sum, it lets us invest in innovation and continual improvement in infrastructure, it provides a buffer for a little mismanagement, and it means tomorrow will be better than today.  Contrary to what one might expect, growth provides long-term stability.<br>增长是我们应该关注的。 增长是伟大的——它让我们能够实现赤字，这意味着国家不是零和博弈，它让我们投资于创新和基础设施的持续改善，它为一点管理不善提供了缓冲，这意味着明天会比今天更好。 与人们的预期相反，增长提供了长期的稳定性。</p>
<p>We must return to real growth, growth where we do more with less.  Borrowing money to get ninety growth cents on the dollar does not count, although that may work for a while.  We have to figure out how to fix the real problems with technological innovation—cheaper and cleaner energy, better healthcare (15.2% of GDP in 2008 and 18.2% of GDP in 2011), better transportation, food production, and defense.  GDP growth is probably the only way to fix our national debt and entitlement problems, and it’d be better to have real growth than inflationary growth.<br>我们必须回归真正的增长，即我们用更少的资源做更多的增长。 借钱以获得90美分的美元增长不算数，尽管这可能会在一段时间内奏效。 我们必须弄清楚如何通过技术创新来解决真正的问题——更便宜、更清洁的能源、更好的医疗保健（2008年占GDP的15.2%，2011年占GDP的18.2%）、更好的交通、粮食生产和国防。 GDP增长可能是解决我们国家债务和福利问题的唯一途径，实际增长比通货膨胀增长要好。</p>
<p>How to best drive economic growth is a difficult question.  It’s easy to say we should just invest in science and technology, and although that’s probably right it’s easier said than done.  The government is historically bad at picking winners to invest in, but our leaders can perhaps help reverse the cultural shift from pro-science to anti-science.  Our current culture has shifted to be anti-science; the fear of things like genetically modified food and robots is obviously in the way of growth.<br>如何最好地推动经济增长是一个难题。 说我们应该投资科学技术很容易，虽然这可能是对的，但说起来容易做起来难。 从历史上看，政府不善于挑选赢家进行投资，但我们的领导人或许可以帮助扭转从亲科学到反科学的文化转变。 我们目前的文化已经转变为反科学;对转基因食品和机器人等事物的恐惧显然阻碍了增长。</p>
<p>We should strive to make jobs in science and technology more appealing than jobs in finance (incidentally, it should be a big red flag for growth when the brightest young people start going into finance, since they aren’t actually creating any more wealth, just redistributing it).  Startups are probably the best way to do this—startups let people that develop a new technology get rich, instead of just making GE slightly richer.  So we should encourage startups in whatever way we can.<br>我们应该努力使科学和技术领域的工作比金融领域的工作更具吸引力（顺便说一句，当最聪明的年轻人开始进入金融领域时，这应该是增长的一大危险信号，因为他们实际上并没有创造更多的财富，只是重新分配财富）。 创业公司可能是做到这一点的最好方式——创业公司让开发新技术的人致富，而不仅仅是让通用电气稍微富裕一点。 因此，我们应该尽我们所能鼓励创业公司。</p>
<p>Another issue is the structure of our national budget.  We have, in startup parlance, a high burn, and most of it can’t be considered ‘investment’ but is instead ‘expense’.  Spending money on things like infrastructure improvement or new technology that are likely to generate more money in the future helps growth; spending money on the so-called entitlement programs, and parts of the military, does not.  Of course medical care and defense are important, and we have to have them—this is a tough balancing act.  In some cases, the competitive nature of the private sector may provide a better path.  Sooner or later, we are going to have an ugly conversation about our national budget—we can delay it for a long time but not forever.  The government, when it needs to spend money at all, should aim to invest.  Considering what will drive growth is a useful framework for thinking about the best use of resources.<br>另一个问题是我国国家预算的结构。 用创业公司的话来说，我们有很高的消耗，其中大部分不能被视为“投资”，而是“费用”。 把钱花在基础设施改善或新技术等可能在未来产生更多资金的事情上有助于增长;把钱花在所谓的福利计划和部分军队上，则不会。 当然，医疗和防御很重要，我们必须拥有它们——这是一个艰难的平衡行为。 在某些情况下，私营部门的竞争性质可能提供更好的途径。 迟早，我们将就我们的国家预算进行一场丑陋的对话——我们可以推迟很长时间，但不会永远拖延。 当政府需要花钱时，它应该以投资为目标。 考虑什么将推动增长是思考资源最佳利用的有用框架。</p>
<p>We should not fear innovation or globalization.  Robots are going to replace human workers in lots of factories; jobs that do require human labor are going to continue to move to the lowest-cost place.  But that’s ok, and these sorts of jobs are not what will generate economic growth for us anyway.  We should strive to be a net exporter of ideas and technologies.  For example, the US makes the best software in the world today.  It’d be disastrous for us if that stopped happening.  We should also design the best supersonic jet engines, the best nuclear power plants, and the best agricultural technology.<br>我们不应该害怕创新或全球化。 机器人将取代许多工厂的人类工人;确实需要人力的工作将继续转移到成本最低的地方。 但这没关系，无论如何，这些工作都不会为我们带来经济增长。 我们应该努力成为思想和技术的净输出国。 例如，美国制造了当今世界上最好的软件。 如果这种情况停止发生，对我们来说将是灾难性的。 我们还应该设计最好的超音速喷气发动机、最好的核电站和最好的农业技术。</p>
<p>We should understand that as a consequence of technology and an economy of ideas, the gap between the rich and the poor will likely increase from its already high-seeming levels.  There is good and bad to this, but we should be careful not to legislate against it, which will hurt growth.   Technology magnifies differences in innate ability; startups provide a framework to get compensated for it.  But GDP growth ought to improve the quality of life for everyone, and no growth will reduce quality of life for everyone except the very rich.  A safety net for legitimately poor people is a good thing, and probably becomes more necessary in a world with this sort of divergence.  Quality of life should improve for everyone; the bigger issue will likely be that people are very sensitive to relative fairness.<br>我们应该明白，由于技术和思想经济，贫富差距可能会从已经很高的水平扩大。 这有好有坏，但我们应该小心，不要立法反对它，这会损害增长。  技术放大了先天能力的差异;初创公司提供了一个框架来获得补偿。 但GDP增长应该改善每个人的生活质量，除了富人之外，任何增长都不会降低每个人的生活质量。 为合法的穷人提供安全网是一件好事，在一个存在这种分歧的世界里，它可能变得更加必要。 每个人的生活质量都应该得到改善;更大的问题可能是人们对相对公平非常敏感。</p>
<p>Pro-growth tax and legal changes are a good idea.  As a consequence of a high burn rate, we have to have high taxes.  But other countries don’t have this structural challenge, and so some other countries have lower tax rates than we do.  That makes them an appealing place to start a business or live.  By reducing our burn rate, we can reduce taxes. We don’t need to go crazy here—there are a lot of other factors that make the US a very attractive place to start a new company.  But it would certainly help.  And tax policy should reward activity that drives growth.<br>促进增长的税收和法律变化是个好主意。 由于高烧钱率，我们必须征收高税。 但其他国家没有这种结构性挑战，因此其他一些国家的税率比我们低。 这使它们成为创业或居住的有吸引力的地方。 通过降低我们的燃烧率，我们可以减少税收。我们不需要在这里发疯——还有很多其他因素使美国成为创办新公司的非常有吸引力的地方。 但这肯定会有所帮助。 税收政策应该奖励推动增长的活动。</p>
<p>There are some easy legal changes we can make to increase growth.  Immigration for entrepreneurs and skilled technology workers is an obvious one; we should want the best people creating value here, not elsewhere in the world.  Tort reform is another—legal protection is of course important, but it’s gotten so silly that it discourages innovation.<br>我们可以做出一些简单的法律改变来促进增长。 企业家和熟练技术工人的移民是显而易见的;我们应该希望最优秀的人才在这里创造价值，而不是在世界其他地方。 侵权法改革是另一回事——法律保护当然很重要，但它变得如此愚蠢，以至于阻碍了创新。</p>
<p>There is a lot more we can do.  Most of it is difficult, but growth it is the critical issue.<br>我们可以做的还有很多。 其中大部分是困难的，但增长是关键问题。</p>
<p>As a closing thought, the Airbnb founders used to draw a forward-looking growth graph that they wanted to hit.  It was their number one priority; they put it up on their desks, on their refrigerator, and on the mirror in their bathroom.  You build what you measure, and they built growth.  That seemed to work pretty well for them.<br>最后，Airbnb的创始人曾经画出他们想要达到的前瞻性增长图。 这是他们的首要任务;他们把它放在桌子上、冰箱上和浴室的镜子上。 你建立你所衡量的东西，他们建立增长。 这对他们来说似乎很有效。</p>
<p>It’s not as easy if you’re the US government.  But probably not impossible, either, and it would at least point us in the right direction.<br>如果你是美国政府，那就没那么容易了。 但可能也不是不可能，它至少会为我们指明正确的方向。</p>
]]></content>
      <categories>
        <category>sam_altman</category>
      </categories>
      <tags>
        <tag>sam altman</tag>
      </tags>
  </entry>
  <entry>
    <title>Creational Design Patterns</title>
    <url>/2023/11/26/design-pattern/Creational-Design-Patterns/</url>
    <content><![CDATA[<h1 id="Creational-Design-Patterns-创建设计模式"><a href="#Creational-Design-Patterns-创建设计模式" class="headerlink" title="Creational Design Patterns 创建设计模式"></a>Creational Design Patterns 创建设计模式</h1><p>Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.<br>创建设计模式提供了各种对象创建机制，这些机制提高了灵活性和现有代码的重用性。</p>
<h2 id="Factory-Method-工厂方法"><a href="#Factory-Method-工厂方法" class="headerlink" title="Factory Method 工厂方法"></a>Factory Method 工厂方法</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/87KZ5eDmwjmWiKFEoA02lw">
    <img src="/images/factory-method-logo.png"/>
    Factory Method 工厂方法
    <a/>
</div>

<hr>
<h2 id="Abstract-Factory-抽象工厂模式"><a href="#Abstract-Factory-抽象工厂模式" class="headerlink" title="Abstract Factory 抽象工厂模式"></a>Abstract Factory 抽象工厂模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/ArraO8MpfdiSG7JiqJwZsQ">
    <img src="/images/abstract-factory-logo.png"/>
    Abstract Factory 抽象工厂模式
    <a/>
</div>

<hr>
<h2 id="Builder-建造者模式"><a href="#Builder-建造者模式" class="headerlink" title="Builder 建造者模式"></a>Builder 建造者模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/av15yLamVtV8D1bjLBxk4Q">
    <img src="/images/builder-logo.png"/>
    Builder 建造者模式
    <a/>
</div>

<hr>
<h2 id="Protopype-原型模式"><a href="#Protopype-原型模式" class="headerlink" title="Protopype 原型模式"></a>Protopype 原型模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/IG55Nn98d_PU382-VOGNhQ">
    <img src="/images/prototype-logo.png"/>
    Protopype 原型模式
    <a/>
</div>

<hr>
<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><div align="center"> 
    <a href="https://mp.weixin.qq.com/s/Mpp-i9mm2KZsi4DPxZWLmg">
    <img src="/images/singleton-logo.png"/>
    Singleton 单例模式
    <a/>
</div>
]]></content>
      <categories>
        <category>design-pattern</category>
      </categories>
  </entry>
</search>
